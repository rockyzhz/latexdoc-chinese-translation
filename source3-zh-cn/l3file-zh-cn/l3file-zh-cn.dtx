% \iffalse meta-comment
%
%% File: l3file.dtx
%
% Copyright (C) 1990-2024 The LaTeX Project
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "l3kernel bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/latex3/latex3
%
% for those people who are interested.
%
%<*driver>
\documentclass[full,kernel]{l3doc}
% ^^A ================ 中文版特别设置 ============================
\usepackage[fontset=source]{ctex}
\ctexset{contentsname={\hfil 目\quad 录\hfil}}
% ^^A \addtolength{\columnseprule}{.4pt}
% ^^A \addtolength{\columnsep}{.5\ccwd}
% ^^A \AtBeginDocument{\addtocontents{toc}{\protect\begin{multicols}{2}}}
% ^^A \AtEndDocument{\addtocontents{toc}{\protect\end{multicols}}}
\IndexPrologue
  {
    \section*{索引}
    \markboth{索引}{索引}
    \addcontentsline{toc}{section}{索引}
    斜体数字指向相应条目描述的页面，
    下划线数字指向定义的代码行，
    其它的都指向使用条目的页面。
  }
\makeatletter
\patchcmd{\l@section}
  {\hfil}
  {\leaders\hbox{\normalfont$\m@th\mkern \@dotsep mu\hbox{.}\mkern \@dotsep mu$}\hfill}
  {}{}
\ExplSyntaxOn
\cs_set_protected:Npn \__codedoc_print_end_definition:
  {
    \seq_set_map:NNn \l__codedoc_tmpa_seq
      \g__codedoc_nested_names_seq
      { \__codedoc_macro_end_wrap_item:n {##1} }
      %%
    \int_compare:nTF { \seq_count:N \l__codedoc_tmpa_seq <= 3 }
      {
        \seq_use:Nnnn \l__codedoc_tmpa_seq
          { \,~和~ } { \,,~ } { \,,~和~ }
      }
      { \seq_item:Nn \l__codedoc_tmpa_seq {1}\,~以及其它的 }
    \@ 定义结束。
    \__codedoc_print_documented:
  }
\cs_set_protected:Npn \__codedoc_print_documented:
  {
    \seq_gset_filter:NNn \g__codedoc_nested_names_seq
      \g__codedoc_nested_names_seq
      {
        ! \bool_lazy_any_p:n
          {
            { \__codedoc_if_macro_internal_p:n {##1} }
            { \l__codedoc_macro_deprecated_bool }
            { \l__codedoc_macro_nodoc_bool }
          }
      }
    \seq_if_empty:NF \g__codedoc_nested_names_seq
      {
        \int_set:Nn \l__codedoc_tmpa_int
          { \seq_count:N \g__codedoc_nested_names_seq }
        \int_compare:nNnTF \l__codedoc_tmpa_int = 1 {这个} {这些}
        \bool_if:NTF \l__codedoc_macro_var_bool {变量} {函数}
        \int_compare:nNnTF \l__codedoc_tmpa_int = 1 {} {}
        被记录在第
        \__codedoc_get_hyper_target:eN
          { \seq_item:Nn \g__codedoc_nested_names_seq { 1 } }
          \l__codedoc_tmpa_tl
        \exp_args:Ne \pageref { \l__codedoc_tmpa_tl } 页。
      }
    \seq_gclear:N \g__codedoc_nested_names_seq
  }
\cs_set_protected:Npn \__codedoc_special_index_module:nnnnN #1#2#3#4#5
  {
    \use:e
      {
        \exp_not:n { \__codedoc_special_index_aux:nnnnnn {#1} {#2} }
          \tl_if_empty:nTF {#3}
            { { } { } { } }
            {
              \str_if_eq:nnTF {#3} { TeX }
                {
                  { TeX~和~LaTeX2e }
                  { \string\TeX{}~和~\string\LaTeXe{} }
                }
                {
                  {#3}
                  { \string\pkg{#3} }
                }
              { \bool_if:NT #5 { ~内部 } ~命令： }
            }
      }
          {#4}
  }
\ExplSyntaxOff
\makeatother
% ^^A =================== 设置颜色 ===============================
\usepackage{xcolor}
\definecolor{spot}{HTML}{003399}
\definecolor{code}{HTML}{a25e26}
\definecolor{verb}{HTML}{007f00}
\let\OriginalMF\MacroFont
\def\MacroFont{\color{spot}\OriginalMF}
\makeatletter
\pretocmd{\macrocode}{\def\macro@font{\color{code}\OriginalMF}\def\MacroFont{\color{code}\OriginalMF}}{}{}
\makeatother
\AtBeginEnvironment{quote}{\color{verb}}
\AtBeginEnvironment{flushleft}{\tt\color{verb}}
\AtBeginEnvironment{verbatim}{\color{verb}\def\MacroFont{\color{verb}\OriginalMF}}
\ExplSyntaxOn
\pretocmd{\__codedoc_typeset_functions:}{\color{spot}\arrayrulecolor{spot}}{}{}
\patchcmd{\__codedoc_macro_typeset_one:nN}{\llap}{\color{spot}\llap}{}{}
\patchcmd{\__codedoc_typeset_aux:n}{\color[gray]{0.5}}{\color{spot}}{}{}
\ExplSyntaxOff
\hypersetup{%
  colorlinks=true,
  linkcolor=spot,
  urlcolor=spot,
  citecolor=spot,
  bookmarksopen=false,
  bookmarksnumbered=false,
  plainpages=false}
% ^^A ================ 中文版设置结束 ============================

\begin{document}
\DocInput{\jobname.dtx}
\PrintIndex
\end{document}
%</driver>
% \fi
%
% \title{^^A
%   \huge\bfseries\color{spot}\pkg{l3file} 模块\\\Large 文件与 I/O 操作^^A
% }
%
% \author{}
% \date{\vspace*{-2ex}
%  \begin{tabular}{c@{\hspace{\ccwd}}c@{\hspace{2\ccwd}}l}
%  \LaTeX{} 项目组\thanks
%    {^^A
%      E-mail:
%        \href{mailto:latex-team@latex-project.org}
%          {latex-team@latex-project.org}^^A
%    }^^A
%    & 2024年1月04日 & 发布\\[6pt]
%     张泓知 & \zhtoday & 【译】
%  \end{tabular}
%       }
%
% \maketitle
%
% \tableofcontents
% \newpage
% \begin{documentation}
%
% 该模块提供用于处理外部文件的函数。其中一些函数适用于整个文件，
% 具有前缀 \cs[no-index]{file_\ldots}，而其他一些用于逐行处理文件，
% 具有前缀 \cs[no-index]{ior_\ldots}（读取）或 \cs[no-index]{iow_\ldots}（写入）。
%
% 需要记住的是，在读取外部文件时，\TeX{} 尝试使用操作系统路径和
% \TeX{} 文件数据库中的条目来定位它们（大多数 \TeX{} 系统使用此类数据库）。
% 因此，\TeX{} 的“当前路径”比其他程序的要宽泛一些。
%
% 对于期望一个 \meta{file name} 参数的函数，此参数可以包含字面项和可展开内容，
% 在完全展开时应为所需的文件名。活动字符（如 \cs{l_char_active_seq} 中声明的）
% 不会被展开，允许直接在文件名中使用它们。引号标记（|"|）在文件名中不允许，
% 因为它们被一些 \TeX{} 原语内部保留使用。
%
% 文件名的开头和结尾会被修剪空格：
% 这反映了一些文件系统不允许或在这些位置与空格不可预测地交互的事实。
% 当没有给出扩展名时，这将仅从名称开头修剪空格。
%
% \section{输入输出流管理}
%
% 由于 \TeX{} 引擎的输入和输出流数量有限，在 \LaTeX3 中不支持程序员直接
% 使用这些流。相反，维护一个内部的流池，这些流会根据需要被分配和释放给
% 其他模块使用。因此，程序员应该在不再需要流时关闭它们，以释放它们供其他
% 进程使用。
%
% 注意，I/O 操作是全局的：流都应该以全局名称声明并相应地处理。
%
% \begin{function}[added = 2011-09-26, updated = 2011-12-27]
%   {\ior_new:N, \ior_new:c, \iow_new:N, \iow_new:c}
%   \begin{syntax}
%     \cs{ior_new:N} \meta{stream}
%     \cs{iow_new:N} \meta{stream}
%   \end{syntax}
%   全局保留 \meta{stream} 的名称，根据需要用于读取或写入。直到使用相应
%   的 \cs[no-index]{\ldots_open:Nn} 函数打开 \meta{stream} 之前，它不会被打开。
%   尝试使用未打开的 \meta{stream} 是一个错误，并且 \meta{stream} 将表现
%   得像相应的 \cs[no-index]{c_term_\ldots}。
% \end{function}
%
% \begin{function}[updated = 2012-02-10]{\ior_open:Nn, \ior_open:cn}
%   \begin{syntax}
%     \cs{ior_open:Nn} \meta{stream} \Arg{file name}
%   \end{syntax}
%   使用 \meta{stream} 作为文件访问的控制序列，打开 \meta{file name} 以供读取。
%   如果 \meta{stream} 已经打开，则在新操作开始之前关闭它。立即可以访问
%   \meta{stream}，并将保留给 \meta{file name} 直到给出 \cs{ior_close:N} 指令
%   或 \TeX{} 运行结束。如果找不到文件，将引发错误。
% \end{function}
%
% \begin{function}[added = 2013-01-12, TF]{\ior_open:Nn, \ior_open:cn}
%   \begin{syntax}
%     \cs{ior_open:NnTF} \meta{stream} \Arg{file name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   使用 \meta{stream} 作为文件访问的控制序列，打开 \meta{file name} 以供读取。
%   如果 \meta{stream} 已经打开，则在新操作开始之前关闭它。立即可以访问
%   \meta{stream}，并将保留给 \meta{file name} 直到给出 \cs{ior_close:N} 指令
%   或 \TeX{} 运行结束。然后将 \meta{true code} 插入到输入流中。如果找不到文件，
%   不会引发错误，而是将 \meta{false code} 插入到输入流中。
% \end{function}
%
% \begin{function}[updated = 2012-02-09]
%   {\iow_open:Nn, \iow_open:NV, \iow_open:cn, \iow_open:cV}
%   \begin{syntax}
%     \cs{iow_open:Nn} \meta{stream} \Arg{file name}
%   \end{syntax}
%   使用 \meta{stream} 作为文件访问的控制序列，打开 \meta{file name} 以供写入。
%   如果 \meta{stream} 已经打开，则在新操作开始之前关闭它。立即可以访问
%   \meta{stream}，并将保留给 \meta{file name} 直到给出 \cs{iow_close:N} 指令
%   或 \TeX{} 运行结束。打开文件以写入会清除文件中的任何现有内容（即写入不是追加的）。
% \end{function}
%
% \begin{function}[added = 2019-05-08]{\ior_shell_open:Nn}
%   \begin{syntax}
%     \cs{ior_shell_open:Nn} \meta{stream} \Arg{shell~command}
%   \end{syntax}
%   使用 \meta{stream} 作为访问控制序列，打开由 \meta{shell command} 输出
%   创建的伪文件以供读取。如果 \meta{stream} 已经打开，则在新操作开始之前关闭它。
%   立即可以访问 \meta{stream}，并将保留给 \meta{shell command} 直到给出
%   \cs{ior_close:N} 指令或 \TeX{} 运行结束。如果禁用了管道系统调用，将引发错误。
%
%   有关处理 \meta{shell command} 的详细信息，请参见 \cs{sys_get_shell:nnNTF}。
% \end{function}
%
% \begin{function}[added = 2023-05-25]{\iow_shell_open:Nn}
%   \begin{syntax}
%     \cs{iow_shell_open:Nn} \meta{stream} \Arg{shell~command}
%   \end{syntax}
%   使用 \meta{stream} 作为访问控制序列，打开由 \meta{shell command} 输出
%   创建的伪文件以供写入。如果 \meta{stream} 已经打开，则在新操作开始之前关闭它。
%   立即可以访问 \meta{stream}，并将保留给 \meta{shell command} 直到给出
%   \cs{iow_close:N} 指令或 \TeX{} 运行结束。如果禁用了管道系统调用，将引发错误。
%
%   有关处理 \meta{shell command} 的详细信息，请参见 \cs{sys_get_shell:nnNTF}。
% \end{function}
%
% \begin{function}[updated = 2012-07-31]
%   {\ior_close:N, \ior_close:c, \iow_close:N, \iow_close:c}
%   \begin{syntax}
%     \cs{ior_close:N} \meta{stream}
%     \cs{iow_close:N} \meta{stream}
%   \end{syntax}
%   关闭 \meta{stream}。在完成对流的使用时，应始终关闭它们，以确保它们
%   保持可用于其他程序员。
% \end{function}
%
% \begin{function}[added = 2021-05-11]
%   {
%     \ior_show:N, \ior_show:c, \ior_log:N, \ior_log:c,
%     \iow_show:N, \iow_show:c, \iow_log:N, \iow_log:c
%   }
%   \begin{syntax}
%     \cs{ior_show:N} \meta{stream}
%     \cs{ior_log:N} \meta{stream}
%     \cs{iow_show:N} \meta{stream}
%     \cs{iow_log:N} \meta{stream}
%   \end{syntax}
%   显示（在终端或日志文件中）与（读取或写入）\meta{stream} 关联的文件名。
% \end{function}
%
% \begin{function}[added = 2017-06-27]
%   {
%     \ior_show_list:, \ior_log_list:,
%     \iow_show_list:, \iow_log_list:
%   }
%   \begin{syntax}
%     \cs{ior_show_list:}
%     \cs{ior_log_list:}
%     \cs{iow_show_list:}
%     \cs{iow_log_list:}
%   \end{syntax}
%   显示（在终端或日志文件中）与每个已打开（读取或写入）流关联的文件名列表。
%   这用于跟踪问题。
% \end{function}
%
% \subsection{从文件读取}
%
% 在 \pkg{expl3} 中，从文件读取和从终端读取是分开的过程。函数
% \cs{ior_get:NN} 和 \cs{ior_str_get:NN} 及其相应的分支版本设计用于
% 处理\emph{文件}。
%
% \begin{function}[noTF, added = 2012-06-24, updated = 2019-03-23]{\ior_get:NN}
%   \begin{syntax}
%     \cs{ior_get:NN} \meta{stream} \meta{token list variable}
%     \cs{ior_get:NNTF} \meta{stream} \meta{token list variable} \meta{true code} \meta{false code}
%   \end{syntax}
%   该函数从文件输入 \meta{stream} 读取一行或多行（直到找到相等数量的左右大括号），
%   并将结果存储在局部的 \meta{token list} 变量中。从 \meta{stream} 读取的内容由
%   \TeX{} 根据函数使用时的类别码和 \tn{endlinechar} 进行记号化。在正常设置下，
%   不以注释字符~|%| 结尾的任何行都将换行符转换为空格，因此例如输入
%   \begin{verbatim}
%      a b  c
%   \end{verbatim}
%   将得到一个记号列表 \verb*|a b c |。任何空白行都会被转换为记号 \cs{par}。
%   因此，可以使用类似以下的测试跳过空白行：
%   \begin{verbatim}
%      \ior_get:NN \l_my_stream \l_tmpa_tl
%      \tl_set:Nn \l_tmpb_tl { \par }
%      \tl_if_eq:NNF \l_tmpa_tl \l_tmpb_tl
%      ...
%   \end{verbatim}
%   还要注意，如果读取多行以匹配大括号，那么结果的记号列表可能包含 \cs{par} 记号。
%   在非分支版本中，如果 \meta{stream} 未打开，则将 \meta{tl var} 设置为 \cs{q_no_value}。
%   \begin{texnote}
%     该受保护的宏是对 \TeX{} 原始命令 \tn{read} 的换行。无论设置如何，\TeX{} 都会在
%     将字符按照当前类别码转换为记号之前将每行中的尾随空格和制表符（字符代码为 32 和 9）
%     替换为换行符（字符代码为 \tn{endlinechar}，如果 \tn{endlinechar} 为负或太大则被省略）。
%     使用默认设置，行首的空格也会被忽略。
%   \end{texnote}
% \end{function}
%
% \begin{function}[noTF, added = 2016-12-04, updated = 2019-03-23]
%   {\ior_str_get:NN}
%   \begin{syntax}
%     \cs{ior_str_get:NN} \meta{stream} \meta{token list variable}
%     \cs{ior_str_get:NNTF} \meta{stream} \meta{token list variable} \meta{true code} \meta{false code}
%   \end{syntax}
%   该函数从文件输入 \meta{stream} 读取一行并将结果存储在局部的 \meta{token list} 变量中。
%   材料从 \meta{stream} 中作为带有类别码 $12$（其他）的一系列记号读取，空格字符除外，
%   空格字符的类别码为 $10$（空格）。此过程会保留多个空格字符。它总是只读取一行，
%   输入中的任何空白行都导致 \meta{token list variable} 为空。与 \cs{ior_get:NN} 不同，
%   行尾不接受任何特殊处理。因此，输入
%   \begin{verbatim}
%      a b  c
%   \end{verbatim}
%   将得到一个记号列表 |a b  c|，其中字母 |a|、|b| 和 |c| 的类别码为 12。
%   在非分支版本中，如果 \meta{stream} 未打开，则将 \meta{tl var} 设置为 \cs{q_no_value}。
%   \begin{texnote}
%     该受保护的宏是对 \eTeX{} 原始命令 \tn{readline} 的换行。无论设置如何，
%     \TeX{} 都会删除每行中的尾随空格和制表符（字符代码为 32 和 9）。
%     但是，该原始命令通常添加的行尾字符不包括在 \cs{ior_str_get:NN} 的结果中。
%   \end{texnote}
% \end{function}
%
% 所有映射都在当前组级别完成，\emph{即}下面讨论的 \meta{function} 或 \meta{code} 中
% 进行的任何局部赋值在循环后仍然有效。
%
% \begin{function}[added = 2012-02-11]{\ior_map_inline:Nn}
%   \begin{syntax}
%     \cs{ior_map_inline:Nn} \meta{stream} \Arg{inline function}
%   \end{syntax}
%   对通过调用 \cs{ior_get:NN} 获得的每组 \meta{lines} 应用 \meta{inline function}，
%   直到达到文件结尾。 \TeX{} 忽略从读取的文件中的任何尾随换行标记。 \meta{inline function}
%   应包含接收 \meta{line} 为 |#1| 的代码。
% \end{function}
%
% \begin{function}[added = 2012-02-11]{\ior_str_map_inline:Nn}
%   \begin{syntax}
%     \cs{ior_str_map_inline:Nn} \meta{stream} \Arg{inline function}
%   \end{syntax}
%   将 \meta{inline function} 应用于 \meta{stream} 中的每个 \meta{line}。从 \meta{stream}
%   读取的材料作为一系列类别码为 $12$（其他）的记号进行，空格字符除外，它们的类别码为 $10$
%   （空格）。 \meta{inline function} 应包含接收 \meta{line} 为 |#1| 的代码。请注意，
%   \TeX{} 会从每行输入中删除尾随的空格和制表符（字符代码为 32 和 9）。
%   \TeX{} 还会忽略从读取的文件中的任何尾随换行标记。
% \end{function}
%
% \begin{function}[added = 2019-01-13]{\ior_map_variable:NNn}
%   \begin{syntax}
%     \cs{ior_map_variable:NNn} \meta{stream} \meta{tl~var} \Arg{code}
%   \end{syntax}
%   对通过调用 \cs{ior_get:NN} 获得的每组 \meta{lines}，将 \meta{lines} 存储在 \meta{tl~var} 中，
%   然后应用 \meta{code}。 \meta{code} 通常会使用 \meta{variable}，但不强制要求。
%   对 \meta{variable} 的赋值是局部的。循环后，它的值为最后一组 \meta{lines}，如果 \meta{stream} 为空，
%   则为其原始值。 \TeX{} 忽略从读取的文件中的任何尾随换行标记。这个函数通常比 \cs{ior_map_inline:Nn} 更快。
% \end{function}
%
% \begin{function}[added = 2019-01-13]{\ior_str_map_variable:NNn}
%   \begin{syntax}
%     \cs{ior_str_map_variable:NNn} \meta{stream} \meta{variable} \Arg{code}
%   \end{syntax}
%   对 \meta{stream} 中的每个 \meta{line}，将 \meta{line} 存储在 \meta{variable} 中，
%   然后应用 \meta{code}。从 \meta{stream} 中读取的材料作为一系列类别码为 $12$（其他）的
%   记号进行，空格字符除外，它们的类别码为 $10$（空格）。 \meta{code} 通常会使用
%   \meta{variable}，但不强制要求。对 \meta{variable} 的赋值是局部的。循环后，
%   它的值为最后一个 \meta{line}，如果 \meta{stream} 为空，则为其原始值。
%   请注意，\TeX{} 会从每行输入中删除尾随的空格和制表符（字符代码为 32 和 9）。
%   \TeX{} 还会忽略从读取的文件中的任何尾随换行标记。这个函数通常比 \cs{ior_str_map_inline:Nn} 更快。
% \end{function}
%
% \begin{function}[added = 2012-06-29]{\ior_map_break:}
%   \begin{syntax}
%     \cs{ior_map_break:}
%   \end{syntax}
%   用于在处理完 \meta{stream} 的所有行之前终止 \cs[no-index]{ior_map_\ldots} 函数。
%   这通常发生在条件语句内部，例如
%   \begin{verbatim}
%     \ior_map_inline:Nn \l_my_ior
%       {
%         \str_if_eq:nnTF { #1 } { bingo }
%           { \ior_map_break: }
%           {
%             % Do something useful
%           }
%       }
%   \end{verbatim}
%   在 \cs[no-index]{ior_map_\ldots} 场景之外使用会导致低级别的 \TeX{} 错误。
%   \begin{texnote}
%     当映射被中断时，可能会在从输入流中取出更多项目之前插入额外的记号。这取决于映射函数的设计。
%   \end{texnote}
% \end{function}
%
% \begin{function}[added = 2012-06-29]{\ior_map_break:n}
%   \begin{syntax}
%     \cs{ior_map_break:n} \Arg{code}
%   \end{syntax}
%   用于在处理完 \meta{stream} 的所有行之前终止 \cs[no-index]{ior_map_\ldots} 函数，
%   在映射结束后插入 \meta{code}。这通常发生在条件语句内部，例如
%   \begin{verbatim}
%     \ior_map_inline:Nn \l_my_ior
%       {
%         \str_if_eq:nnTF { #1 } { bingo }
%           { \ior_map_break:n { <code> } }
%           {
%             % Do something useful
%           }
%       }
%   \end{verbatim}
%   在 \cs[no-index]{ior_map_\ldots} 场景之外使用会导致低级别的 \TeX{} 错误。
%   \begin{texnote}
%     当映射被中断时，可能会在插入 \meta{code} 之前插入额外的记号。
%     这取决于映射函数的设计。
%   \end{texnote}
% \end{function}
%
% \begin{function}[updated = 2012-02-10, EXP, pTF]{\ior_if_eof:N}
%   \begin{syntax}
%     \cs{ior_if_eof_p:N} \meta{stream} \\
%     \cs{ior_if_eof:NTF} \meta{stream} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   测试在读取操作期间是否已经到达文件 \meta{stream} 的末尾。如果 \meta{stream} 未打开，
%   测试还将返回 \texttt{true} 值。
% \end{function}
%
% \subsection{从终端读取}
%
% \begin{function}[added = 2019-03-23]{\ior_get_term:nN, \ior_str_get_term:nN}
%   \begin{syntax}
%     \cs{ior_get_term:nN} \meta{prompt} \meta{token list variable}
%   \end{syntax}
%   该函数从终端读取一行或多行（直到找到相等数量的左右大括号），并将结果存储在
%   \meta{token list} 变量中。记号化过程与 \cs{ior_get:NN} 或 \cs{ior_str_get:NN}
%   中描述的相同。当 \meta{prompt} 为空时，\TeX{} 将等待输入，不提供任何其他指示：
%   通常，程序员将使用 \cs{iow_term:n} 等提供适当文本。如果给定了 \meta{prompt}，
%   它将出现在终端上，后面跟着一个 |=|，例如
%   \begin{verbatim}
%     prompt=
%   \end{verbatim}
% \end{function}
%
% \subsection{写入文件}
%
% \begin{function}[updated = 2012-06-05]
%   {
%     \iow_now:Nn, \iow_now:NV, \iow_now:Ne,
%     \iow_now:cn, \iow_now:cV, \iow_now:ce
%   }
%   \begin{syntax}
%     \cs{iow_now:Nn} \meta{stream} \Arg{tokens}
%   \end{syntax}
%   此函数立即将 \meta{tokens} 写入指定的 \meta{stream}
%   （即在 \cs{iow_now:Nn} 扩展时调用写操作）。
% \end{function}
%
% \begin{function}{\iow_log:n, \iow_log:e}
%   \begin{syntax}
%     \cs{iow_log:n} \Arg{tokens}
%   \end{syntax}
%   该函数将给定的 \meta{tokens} 立即写入日志（transcript）文件：
%   这是 \cs{iow_now:Nn} 的专用版本。
% \end{function}
%
% \begin{function}{\iow_term:n, \iow_term:e}
%   \begin{syntax}
%     \cs{iow_term:n} \Arg{tokens}
%   \end{syntax}
%   该函数将给定的 \meta{tokens} 立即写入终端文件：
%   这是 \cs{iow_now:Nn} 的专用版本。
% \end{function}
%
% \begin{function}
%   {
%     \iow_shipout:Nn, \iow_shipout:Ne,
%     \iow_shipout:cn, \iow_shipout:ce
%   }
%   \begin{syntax}
%     \cs{iow_shipout:Nn} \meta{stream} \Arg{tokens}
%   \end{syntax}
%   此函数在当前页面最终确定时（即在排版输出时）将 \meta{tokens} 写入指定的
%   \meta{stream}。 \texttt{e}-type 变体在使用函数时扩展 \meta{tokens}，
%   但在将生成的记号写入 \meta{stream} 时\emph{不}扩展
%   （\emph{cf.}~\cs{iow_shipout_e:Nn}）。
%   \begin{texnote}
%     使用 \pkg{expl3} 与除 \LaTeX{} 之外的格式时，使用 \cs{iow_newline:} 插入的
%     换行符或使用 \cs{iow_wrap:nnnN} 插入的换行代码在 \cs{iow_shipout:Nn} 的
%     参数中不会被 \TeX{} 识别。这可能导致插入额外的不需要的换行。
%   \end{texnote}
% \end{function}
%
% \begin{function}[updated = 2023-09-17]
%   {
%     \iow_shipout_e:Nn, \iow_shipout_e:Ne,
%     \iow_shipout_e:cn, \iow_shipout_e:ce
%   }
%   \begin{syntax}
%     \cs{iow_shipout_e:Nn} \meta{stream} \Arg{tokens}
%   \end{syntax}
%   此函数在当前页面最终确定时（即在排版输出时）将 \meta{tokens} 写入指定的
%   \meta{stream}。 \meta{tokens} 在写入时扩展，以及在使用函数时的任何扩展。这使
%   这些函数适用于包含在页面构建过程中最终确定的材料（例如页码整数）。
%   \begin{texnote}
%     这是对 \TeX{} 原始命令 \tn{write} 的换行。
%     使用 \pkg{expl3} 与除 \LaTeX{} 之外的格式时，使用 \cs{iow_newline:} 插入的
%     换行符或使用 \cs{iow_wrap:nnnN} 插入的换行代码在 \cs{iow_shipout:Nn} 的
%     参数中不会被 \TeX{} 识别。这可能导致插入额外的不需要的换行。
%   \end{texnote}
% \end{function}
%
% \begin{function}[EXP]{\iow_char:N}
%   \begin{syntax}
%     \cs{iow_char:N} |\|\meta{char}
%   \end{syntax}
%   将 \meta{char} 插入输出流中。在消息中尝试写入难以处理的字符
%   （例如 |%|，|{|，|}| 等）时非常有用，例如：
%   \begin{verbatim}
%     \iow_now:Ne \g_my_iow { \iow_char:N \{ text \iow_char:N \} }
%   \end{verbatim}
%   如果在不扩展的情况下进行写入（例如在 \cs{iow_now:Nn} 的第二个参数中），
%   该函数将不起作用。
% \end{function}
%
% \begin{function}[EXP]{\iow_newline:}
%   \begin{syntax}
%     \cs{iow_newline:}
%   \end{syntax}
%   用于在写入文件时在 \meta{tokens} 中添加新行的函数。如果在不扩展的情况下进行
%   写入（例如在 \cs{iow_now:Nn} 的第二个参数中），该函数将不起作用。
%   \begin{texnote}
%     使用 \pkg{expl3} 与除 \LaTeX{} 之外的格式时，由 \cs{iow_newline:}
%     插入的字符在 \TeX{} 中不被识别，这可能导致插入额外的不需要的换行。
%     这个问题只影响 \cs{iow_shipout:Nn}、\cs{iow_shipout_e:Nn}
%     和原始操作的直接使用。
%   \end{texnote}
% \end{function}
%
% \subsection{让输出的文字换行}
%
% \begin{function}[added = 2012-06-28, updated = 2017-12-04]
%   {\iow_wrap:nnnN, \iow_wrap:nenN}
%   \begin{syntax}
%     \cs{iow_wrap:nnnN} \Arg{text} \Arg{run-on text} \Arg{set up} \meta{function}
%   \end{syntax}
%   该函数将 \meta{text} 换行到每行固定的字符数中。在每行开始换行的地方，
%   插入 \meta{run-on text}。所针对的行字符计数是 \cs{l_iow_line_count_int} 的
%   值减去除第一行外所有行的 \meta{run-on text} 字符数，对于第一行，目标字符
%   数只是 \cs{l_iow_line_count_int}，因为没有 \meta{run-on text}。函数会详尽
%   扩展 \meta{text} 和 \meta{run-on text}，进行以下替换：
%   \begin{itemize}
%     \item |\\| 或 \cs{iow_newline:} 可以用于强制换行，
%     \item \verb*|\ | 可以用于表示强制空格
%       （例如在控制序列之后），
%     \item |\#|、|\%|、|\{|、|\}|、|\~| 可以用于表示相应的字符，
%     \item \cs{iow_wrap_allow_break:} 可以用于允许换行而不插入空格，
%     \item \cs{iow_indent:n} 可以用于缩进 \meta{text} 的一部分
%       （而不是 \meta{run-on text}）。
%   \end{itemize}
%   通过使用 \meta{set up}，可以向换行添加其他功能，该函数在换行发生之前执行：
%   这可能包括覆盖列出的替换。
%
%   \meta{text} 中不希望在换行时扩展的可扩展材料应使用 \cs{token_to_str:N}、
%   \cs{tl_to_str:n}、\cs{tl_to_str:N} 等转换为字符串。
%
%   换行操作的结果作为带大括号的参数传递给 \meta{function}，通常是换行
%   写操作的换行器。 \cs{iow_wrap:nnnN} 的输出
%   （即传递给 \meta{function} 的参数）由类别代码为 \enquote{other}
%   （类别代码为~12）的字符组成，空格除外，其类别代码为 \enquote{space}
%   （类别代码为~10）。这意味着输出在写入文件时不会进一步扩展。
%
%   \begin{texnote}
%     在内部，\cs{iow_wrap:nnnN} 对 \meta{text} 执行 \texttt{e}-type 扩展以扩展它。
%     这是以 \cs{exp_not:N} 或 \cs{exp_not:n} 可以用于防止材料扩展的方式完成的。
%     但是，与转换为字符串相比，这在概念上不够清晰，因此转换为字符串是处理
%     \meta{text} 中可扩展材料的受支持方法。
%   \end{texnote}
% \end{function}
%
% \begin{function}[added = 2023-04-25]{\iow_wrap_allow_break:}
%   \begin{syntax}
%     \cs{iow_wrap_allow_break:}
%   \end{syntax}
%   在 \cs{iow_wrap:nnnN} 的第一个参数中（例如在消息中）插入一个允许换行的断点。
%   如果没有发生换行，此函数对输出不添加任何内容。
% \end{function}
%
% \begin{function}[added = 2011-09-21]{\iow_indent:n}
%   \begin{syntax}
%     \cs{iow_indent:n} \Arg{text}
%   \end{syntax}
%   在 \cs{iow_wrap:nnnN} 的第一个参数中（例如在消息中），通过四个空格缩进
%   \meta{text}。此函数不会导致换行，并且仅影响从 \meta{text} 范围内开始的行。
%   如果希望缩进的 \meta{text} 应出现在与周围文本不同的行上，请使用 |\\| 强制换行。
% \end{function}
%
% \begin{variable}[added = 2012-06-24]{\l_iow_line_count_int}
%   由 \cs{iow_wrap:nnnN} 函数写入的行中的最大字符数。
%   此值取决于正在使用的 \TeX{} 系统：标准值为 $78$，通常适用于未修改的
%   \TeX{} Live 和 \hologo{MiKTeX} 系统。
% \end{variable}
%
% \subsection{输入输出流常量和变量}
%
% \begin{variable}[added = 2017-12-11]{\g_tmpa_ior, \g_tmpb_ior}
%   全局使用的临时输入流。这些从不被内核代码使用，因此对于任何由 \LaTeX3 定义的函数都是安全的。
%   但是，它们可能会被其他非内核代码覆盖，因此只应用于短期存储。
% \end{variable}
%
% \begin{variable}{\c_log_iow, \c_term_iow}
%   常量输出流，用于写入日志和终端（以及日志）。
% \end{variable}
%
% \begin{variable}[added = 2017-12-11]{\g_tmpa_iow, \g_tmpb_iow}
%   全局使用的临时输出流。这些从不被内核代码使用，因此对于任何由 \LaTeX3 定义的函数都是安全的。
%   但是，它们可能会被其他非内核代码覆盖，因此只应用于短期存储。
% \end{variable}
%
% \subsection{原始条件语句}
%
% \begin{function}[EXP]{\if_eof:w}
%   \begin{syntax}
%     \cs{if_eof:w} \meta{stream}
%     ~~\meta{true code}
%     \cs{else:}
%     ~~\meta{false code}
%     \cs{fi:}
%   \end{syntax}
%   检查 \meta{stream} 是否返回 \enquote{end of file}，对于不存在的文件为真。 \cs{else:} 分支是可选的。
%   \begin{texnote}
%     这是 \TeX{} 原语 \tn{ifeof}。
%   \end{texnote}
% \end{function}
%
% \section{文件操作}
%
% \subsection{基本文件操作}
%
% \begin{variable}[added = 2017-06-21]
%   {
%     \g_file_curr_dir_str,
%     \g_file_curr_name_str,
%     \g_file_curr_ext_str
%   }
%   包含当前文件的目录、名称和扩展名。如果文件是在没有显式路径的情况下加载的
%   （即它在 \TeX{} 搜索路径中），则目录为空，并且除了它与根目录完全相等的情况外，
%   不以 |/| 结尾。 \meta{name} 和 \meta{ext} 部分共同组成文件名，因此 \meta{name}
%   部分可以被视为当前文件的“作业名称”。
%
%   请注意，\TeX{} 不提供有关主文件（顶层文件）的 \meta{dir} 和 \meta{ext} 部分的信息，
%   并且此文件的 \meta{dir} 和 \meta{ext} 组件始终为空。此外，这里的 \meta{name}
%   将等于 \cs{c_sys_jobname_str}，这可能与实际文件名不同（如果使用 |--jobname| 设置）。
% \end{variable}
%
% \begin{variable}[added = 2017-06-18, updated = 2023-06-15]
%   {\l_file_search_path_seq}
%   每个条目都是在寻找文件时应搜索的目录的路径。每个路径可以是相对的或绝对的，而且无需包括尾随的斜杠。
%   空格无需引用。
%
%   \begin{texnote}
%     在 \LaTeXe{} 中作为包工作时，\pkg{expl3} 将自动将当前 \tn{input@path} 添加到
%     \cs{l_file_search_path_seq} 的值集中。
%   \end{texnote}
% \end{variable}
%
% \begin{function}[EXP, pTF, updated = 2023-09-18]
%   {\file_if_exist:n, \file_if_exist:V}
%   \begin{syntax}
%     \cs{file_if_exist_p:n} \Arg{file name}
%     \cs{file_if_exist:nTF} \Arg{file name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   展开 \cs{file name} 的参数以得到字符串，然后使用当前 \TeX{} 搜索路径和由
%   \cs{l_file_search_path_seq} 控制的其他路径搜索此字符串。
% \end{function}
%
% \subsection{关于文件和文件内容的信息}
%
% 本节中的函数返回关于文件的信息，作为 \pkg{expl3} 的 \texttt{str} 数据，\emph{但是}，
% 非可展开的函数如果请求的文件未找到，则将其返回值设置为 \cs{q_no_value}。
% 因此，对文件名、哈希值、大小等的比较应使用 \cs{str_if_eq:nnTF} 而不是 \cs{tl_if_eq:nnTF} 等。
%
% \begin{function}[rEXP, added = 2019-11-19]
%   {
%     \file_hex_dump:n,   \file_hex_dump:V,
%     \file_hex_dump:nnn, \file_hex_dump:Vnn
%   }
%   \begin{syntax}
%     \cs{file_hex_dump:n} \Arg{file name}
%     \cs{file_hex_dump:nnn} \Arg{file name} \Arg{start index} \Arg{end index}
%   \end{syntax}
%   使用当前 \TeX{} 搜索路径和由 \cs{l_file_search_path_seq} 控制的其他路径搜索
%   \meta{file name}，然后扩展为输入流中文件内容的十六进制转储。文件以字节形式读取，
%   这意味着与文本文件中使用的行结束符相比，将有不同的结果。同一文件将在不同引擎之间产生相同的结果：
%   使用的算法在所有情况下都是相同的。当未找到文件时，扩展的结果为空。对于 \Arg{start index}
%   和 \Arg{end index} 的工作原理与 \cs{str_range:nnn} 中描述的相同。
% \end{function}
%
% \begin{function}[noTF, added = 2019-11-19]
%   {
%     \file_get_hex_dump:nN, \file_get_hex_dump:VN,
%     \file_get_hex_dump:nnnN, \file_get_hex_dump:VnnN
%   }
%   \begin{syntax}
%     \cs{file_get_hex_dump:nN} \Arg{file name} \meta{tl var}
%     \cs{file_get_hex_dump:nnnN} \Arg{file name} \Arg{start index} \Arg{end index} \meta{tl var}
%   \end{syntax}
%   将 \meta{tl var} 设置为应用于 \meta{file} 的 \cs{file_hex_dump:n}/\cs{file_hex_dump:nnn} 的结果。
%   如果未找到文件，\meta{tl var} 将设置为 \cs{q_no_value}。
% \end{function}
%
% \begin{function}[rEXP, added = 2019-09-03]
%   {\file_mdfive_hash:n, \file_mdfive_hash:V}
%   \begin{syntax}
%     \cs{file_mdfive_hash:n} \Arg{file name}
%   \end{syntax}
%   使用当前 \TeX{} 搜索路径和由 \cs{l_file_search_path_seq} 控制的其他路径搜索
%   \meta{file name}，然后扩展为输入流中从文件内容生成的 MD5 摘要。
%   文件以字节形式读取，这意味着与文本文件中使用的行结束符相比，将有不同的结果。
%   同一文件将在不同引擎之间产生相同的结果：使用的算法在所有情况下都是相同的。
%   当未找到文件时，扩展的结果为空。
% \end{function}
%
% \begin{function}[noTF, added = 2017-07-11, updated = 2019-02-16]
%   {\file_get_mdfive_hash:nN, \file_get_mdfive_hash:VN}
%   \begin{syntax}
%     \cs{file_get_mdfive_hash:nN} \Arg{file name} \meta{tl var}
%   \end{syntax}
%   将 \meta{tl var} 设置为应用于 \meta{file} 的 \cs{file_mdfive_hash:n} 的结果。
%   如果未找到文件，\meta{tl var} 将设置为 \cs{q_no_value}。
% \end{function}
%
% \begin{function}[rEXP, added = 2019-09-03]{\file_size:n, \file_size:V}
%   \begin{syntax}
%     \cs{file_size:n} \Arg{file name}
%   \end{syntax}
%   使用当前 \TeX{} 搜索路径和由 \cs{l_file_search_path_seq} 控制的其他路径搜索
%   \meta{file name}，然后扩展为输入流中文件的大小（以字节为单位）。
%   当未找到文件时，扩展的结果为空。
% \end{function}
%
% \begin{function}[noTF, added = 2017-07-09, updated = 2019-02-16]
%   {\file_get_size:nN, \file_get_size:VN}
%   \begin{syntax}
%     \cs{file_get_size:nN} \Arg{file name} \meta{tl var}
%   \end{syntax}
%   将 \meta{tl var} 设置为应用于 \meta{file} 的 \cs{file_size:n} 的结果。
%   如果未找到文件，\meta{tl var} 将设置为 \cs{q_no_value}。
%   在较旧版本的 \XeTeX{} 中不可用。
% \end{function}
%
% \begin{function}[rEXP, added = 2019-09-03]
%   {\file_timestamp:n, \file_timestamp:V}
%   \begin{syntax}
%     \cs{file_timestamp:n} \Arg{file name}
%   \end{syntax}
%   使用当前 \TeX{} 搜索路径和由 \cs{l_file_search_path_seq} 控制的其他路径搜索
%   \meta{file name}，然后扩展为输入流中文件的修改时间戳。
%   时间戳的格式为 |D:|\meta{year}\meta{month}\meta{day}\meta{hour}^^A
%   \meta{minute}\meta{second}\meta{offset}，后者可以是 |Z|（UTC）或
%   \meta{plus-minus}\meta{hours}|'|\meta{minutes}|'|。
%   当未找到文件时，扩展的结果为空。
%   在较旧版本的 \XeTeX{} 中不可用。
% \end{function}
%
% \begin{function}[noTF, added = 2017-07-09, updated = 2019-02-16]
%   {\file_get_timestamp:nN, \file_get_timestamp:VN}
%   \begin{syntax}
%     \cs{file_get_timestamp:nN} \Arg{file name} \meta{tl var}
%   \end{syntax}
%   将 \meta{tl var} 设置为应用于 \meta{file} 的 \cs{file_timestamp:n} 的结果。
%   如果未找到文件，\meta{tl var} 将设置为 \cs{q_no_value}。
%   在较旧版本的 \XeTeX{} 中不可用。
% \end{function}
%
% \begin{function}[added = 2019-05-13, updated = 2019-09-20, pTF, EXP]
%   {
%     \file_compare_timestamp:nNn,
%     \file_compare_timestamp:nNV,
%     \file_compare_timestamp:VNn,
%     \file_compare_timestamp:VNV
%   }
%   \begin{syntax}
%     \cs{file_compare_timestamp_p:nNn} \Arg{file-1} \meta{comparator} \Arg{file-2}
%     \cs{file_compare_timestamp:nNnTF} \Arg{file-1} \meta{comparator} \Arg{file-2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   比较两个 \meta{文件} 的时间戳，如 \meta{comparator} 所示，并根据需要插入 \meta{true code} 或 \meta{false code}。
%   未找到的文件将被视为任何找到的文件都更旧。这允许例如下面的构造：
%   \begin{verbatim}
%     \file_compare_timestamp:nNnT { source-file } > { derived-file }
%       {
%         % Code to regenerate derived file
%       }
%   \end{verbatim}
%   在派生文件完全不存在时工作。两个不存在文件的时间戳被视为不同。
%   在较旧版本的 \XeTeX{} 中不可用。
% \end{function}
%
% \begin{function}[noTF, updated = 2019-02-16]
%   {\file_get_full_name:nN, \file_get_full_name:VN}
%   \begin{syntax}
%     \cs{file_get_full_name:nN} \Arg{file name} \meta{tl}
%     \cs{file_get_full_name:nNTF} \Arg{file name} \meta{tl} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   在详细说明了 \cs{file_if_exist:nTF} 的路径中搜索 \meta{file name}，如果找到，
%   将 \meta{tl var} 设置为文件的完全限定名，即路径和文件名。
%   当给定的 \meta{file name} 没有扩展名但找到的文件有扩展名 |.tex| 时，这包括扩展名 |.tex|。
%   在非分支版本中，如果文件不存在，\meta{tl var} 将设置为 \cs{q_no_value}。
% \end{function}
%
% \begin{function}[added = 2019-09-03, rEXP]{\file_full_name:n, \file_full_name:V}
%   \begin{syntax}
%     \cs{file_full_name:n} \Arg{file name}
%   \end{syntax}
%   在详细说明了 \cs{file_if_exist:nTF} 的路径中搜索 \meta{file name}，
%   如果找到，将文件的完全限定名，即路径和文件名，留在输入流中。
%   当在路径上未找到文件时，扩展为空。
% \end{function}
%
% \begin{function}[added = 2017-06-23, updated = 2020-06-24]
%   {\file_parse_full_name:nNNN, \file_parse_full_name:VNNN}
%   \begin{syntax}
%     \cs{file_parse_full_name:nNNN} \Arg{full name} \meta{dir} \meta{name} \meta{ext}
%   \end{syntax}
%   解析 \meta{full name} 并将其拆分为三个部分，通过设置相应的本地字符串变量返回每个部分：
%   \begin{itemize}
%     \item \meta{dir}：\meta{file path} 中到最后一个 |/|（路径分隔符）的所有内容。
%       与系统的 \texttt{PATH} 变量和相关函数一样，\meta{dir} \emph{不}包括末尾的 |/|，
%       除非它指向根目录。如果没有路径（只有文件名），\meta{dir} 为空。
%     \item \meta{name}：从最后一个 |/| 后的内容到最后一个 |.|，其中这两个字符都是可选的。
%       如果 \meta{full name} 仅包含目录名，则 \meta{name} 为空。
%     \item \meta{ext}：最后一个 |.| 后的所有内容（包括点）。如果在最后一个 |/| 后没有 |.|，
%       \meta{ext} 为空。
%   \end{itemize}
%
%   在解析之前，\meta{full name} 会扩展，直到只剩下不可展开的记号，但活动字符也不会扩展。
%   引号（|"|）在文件名中无效，并从输入中丢弃。
% \end{function}
%
% \begin{function}[EXP, added = 2020-06-24]
%   {\file_parse_full_name:n, \file_parse_full_name:V}
%   \begin{syntax}
%     \cs{file_parse_full_name:n} \Arg{full name}
%   \end{syntax}
%   解析 \meta{full name}，如 \cs{file_parse_full_name:nNNN} 中所述，
%   并在输入流中留下 \meta{dir}、\meta{name} 和 \meta{ext}，每个都在一对大括号中。
% \end{function}
%
% \begin{function}[EXP, added = 2020-06-24]
%   {\file_parse_full_name_apply:nN, \file_parse_full_name_apply:VN}
%   \begin{syntax}
%     \cs{file_parse_full_name_apply:nN} \Arg{full name} \meta{function}
%   \end{syntax}
%   解析 \meta{full name}，如 \cs{file_parse_full_name:nNNN} 中所述，
%   并将 \meta{dir}、\meta{name} 和 \meta{ext} 作为参数传递给 \meta{function}，
%   每个作为一个 \texttt{n}-类型的参数，按此顺序。
% \end{function}
% 
% \subsection{访问文件内容}
%
% \begin{function}[noTF, added = 2019-01-16, updated = 2019-02-16]
%   {\file_get:nnN, \file_get:VnN}
%   \begin{syntax}
%     \cs{file_get:nnN} \Arg{file name} \Arg{setup} \meta{tl}
%     \cs{file_get:nnNTF} \Arg{file name} \Arg{setup} \meta{tl} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   将 \meta{tl} 定义为 \meta{file name} 的内容。
%   可以通过 \meta{setup} 参数设置适当的类别码。
%   如果找不到文件，非分支版本将 \meta{tl} 设置为 \cs{q_no_value}。
%   分支版本在分配给 \meta{tl} 后，如果找到文件，运行 \meta{true code}，否则运行 \meta{false code}。
%   文件内容将使用当前类别码制度进行记号化。
% \end{function}
%
% \begin{function}[updated = 2017-06-26]{\file_input:n, \file_input:V}
%   \begin{syntax}
%     \cs{file_input:n} \Arg{file name}
%   \end{syntax}
%   在详细说明了 \cs{file_if_exist:nTF} 的路径中搜索 \meta{file name}，如果找到，
%   将文件作为附加的 \LaTeX{} 源读入。此函数记录所有已读取的文件用于信息，
%   并更新文件名堆栈。如果找不到文件，将引发错误。
% \end{function}
%
% \begin{function}[added = 2023-05-18, EXP]
%   {\file_input_raw:n, \file_input_raw:V}
%   \begin{syntax}
%     \cs{file_input_raw:n} \Arg{file name}
%   \end{syntax}
%   在详细说明了 \cs{file_if_exist:nTF} 的路径中搜索 \meta{file name}，如果找到，
%   将文件作为附加的 \TeX{} 源读入。不跟踪有关文件的任何数据。
%   如果找不到文件，不采取任何措施。
%   \begin{texnote}
%     此函数仅用于必须纯展开读取文件的上下文，例如在 \tn{halign} 中的表格单元格的开头。
%   \end{texnote}
% \end{function}
%
% \begin{function}[added = 2014-07-02]
%   {
%     \file_if_exist_input:n,
%     \file_if_exist_input:V,
%     \file_if_exist_input:nF,
%     \file_if_exist_input:VF
%   }
%   \begin{syntax}
%     \cs{file_if_exist_input:n} \Arg{file name}
%     \cs{file_if_exist_input:nF} \Arg{file name} \Arg{false code}
%   \end{syntax}
%   在详细说明了当前 \TeX{} 搜索路径和 \cs{l_file_search_path_seq} 中包含的其他路径中搜索 \meta{file name}。
%   如果找到，则如 \cs{file_input:n} 中所述将文件作为附加的 \LaTeX{} 源读入，否则插入 \meta{false code}。
%   请注意，与 \cs{file_input:n} 不同，这些函数如果找不到文件不会引发错误。
% \end{function}
%
% \begin{function}[added = 2017-07-07]{\file_input_stop:}
%   \begin{syntax}
%     \cs{file_input_stop:}
%   \end{syntax}
%   结束由 \cs{file_input:n} 或类似函数开始的文件读取，直到达到文件末尾为止。
%   如果由于错误而终止文件读取，应优先使用 \cs[index = msg_critical:nn]{msg_critical:nn(nn)}。
%   \begin{texnote}
%     此函数必须单独使用在一行上：\TeX{} 逐行读取文件，因此仍将读取当前行中的任何其他记号。
%
%     如果该函数隐藏在另一个函数中（这将是正常情况），这也是真的，即在源文件中
%     同一行上的所有记号仍将被处理。将其定义放在一个行上并不起作用，因为它是在使用它的行上计算的！
%   \end{texnote}
% \end{function}
%
% \begin{function}{\file_show_list:, \file_log_list:}
%   \begin{syntax}
%     \cs{file_show_list:}
%     \cs{file_log_list:}
%   \end{syntax}
%   这些函数列出由 \LaTeXe{} 命令加载的所有文件，这些命令填充了 \tn{@filelist}，
%   或者由 \cs{file_input:n} 加载的文件。虽然 \cs{file_show_list:} 在终端显示列表，
%   \cs{file_log_list:} 仅将其输出到日志文件中。
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{l3file} 代码实现}
%
% \TestFiles{m3file001}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% \subsection{输入操作}
%
%    \begin{macrocode}
%<@@=ior>
%    \end{macrocode}
%
% \subsubsection{变量和常量}
%
% \begin{variable}{\l_@@_internal_tl}
%   用作短期临时变量。
%    \begin{macrocode}
\tl_new:N  \l_@@_internal_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_@@_term_ior}
%   从终端（带有提示符）读取时使用正数但不存在的流号。与写入不同，没有从日志读取的概念。
%    \begin{macrocode}
\int_const:Nn \c_@@_term_ior { 16 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_streams_seq}
%   用作堆栈的当前可用输入流列表。
%    \begin{macrocode}
\seq_new:N \g_@@_streams_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_stream_tl}
%   用于从堆栈中恢复原始流号。
%    \begin{macrocode}
\tl_new:N \l_@@_stream_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_streams_prop}
%   跟踪与每个流关联的文件的名称的属性列表。要获取包模式下保留的流的正确数量，需要查询底层机制。
%   对于 \LaTeXe{} 和 plain \TeX{}，此数据存储在 |\count16| 中：如果加载了 \pkg{etex} 宏包，
%   我们需要减去 $1$，因为该寄存器保存要使用的下一个流的编号。在 \ConTeXt{} 中，我们需要查看 |\count38|，
%   但没有减法：与原始的 plain \TeX{}/\LaTeXe{} 机制一样，它保存了分配的\emph{最后}一个流的值。
%    \begin{macrocode}
\prop_new:N \g_@@_streams_prop
\int_step_inline:nnn
  { 0 }
  {
    \cs_if_exist:NTF \contextversion
      { \tex_count:D 38 ~ }
      {
        \tex_count:D 16 ~ %
        \cs_if_exist:NT \loccount { - 1 }
      }
  }
  {
    \prop_gput:Nnn \g_@@_streams_prop {#1} { Reserved~by~format }
  }
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{流管理}
%
% \begin{macro}{\ior_new:N, \ior_new:c}
%   通过将名称定义为使用终端来保留新流。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_new:N #1 { \cs_new_eq:NN #1 \c_@@_term_ior }
\cs_generate_variant:Nn \ior_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_tmpa_ior, \g_tmpb_ior}
%   常用的临时空间。
%    \begin{macrocode}
\ior_new:N \g_tmpa_ior
\ior_new:N \g_tmpb_ior
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\ior_open:Nn, \ior_open:cn}
%   使用条件版本，如果找不到文件，则引发错误。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_open:Nn #1#2
  { \ior_open:NnF #1 {#2} { \__kernel_file_missing:n {#2} } }
\cs_generate_variant:Nn \ior_open:Nn { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_file_name_tl}
%   数据存储。
%    \begin{macrocode}
\tl_new:N \l_@@_file_name_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[TF]{\ior_open:Nn, \ior_open:cn}
% 辅助宏在\TeX{}、\LaTeXe{}和\LaTeX3路径中搜索文件，然后将找到的文件传递给处理流的底层函数。
% 当文件未找到时，|full_name|为空。
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \ior_open:Nn #1#2 { T , F , TF }
  {
    \file_get_full_name:nNTF {#2} \l_@@_file_name_tl
      {
        \__kernel_ior_open:No #1 \l_@@_file_name_tl
        \prg_return_true:
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \ior_open:Nn { c } { T , F , TF }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_new:N}
% 流需要在\tn{newread}之前进行预留才能由\pkg{ior}管理。
% 为防止\pkg{ior}受到\tn{newread}重新定义的影响，此宏被保存在此处，使用私有名称。
% 复杂的代码确保\cs{@@_new:N}不是\tn{outer}，尽管plain \TeX{}的\tn{newread}是\tn{outer}的。
% 对于\ConTeXt{}，我们必须处理\tn{newread}的重新定义，它实际上检查定义之前的情况。
%    \begin{macrocode}
\exp_args:NNf \cs_new_protected:Npn \@@_new:N
  { \exp_args:NNc \exp_after:wN \exp_stop_f: { newread } }
\cs_if_exist:NT \contextversion
  {
    \cs_new_eq:NN \@@_new_aux:N \@@_new:N
    \cs_gset_protected:Npn \@@_new:N #1
      {
        \cs_undefine:N #1
        \@@_new_aux:N #1
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__kernel_ior_open:Nn, \__kernel_ior_open:No}
% \begin{macro}{\@@_open_stream:Nn}
% 流分配本身利用了所有可用流的列表。保持同步很重要，采用两部分方法实现：
% 已被\pkg{ior}占用但现在可用的任何流都会被跟踪，因此首先尝试这些。
% 如果失败，则向plain \TeX{}或\LaTeXe{}请求新的流并使用该数字（经过一些转换）。
%    \begin{macrocode}
\cs_new_protected:Npn \__kernel_ior_open:Nn #1#2
  {
    \ior_close:N #1
    \seq_gpop:NNTF \g_@@_streams_seq \l_@@_stream_tl
      { \@@_open_stream:Nn #1 {#2} }
      {
        \@@_new:N #1
        \__kernel_tl_set:Ne \l_@@_stream_tl { \int_eval:n {#1} }
        \@@_open_stream:Nn #1 {#2}
      }
  }
\cs_generate_variant:Nn \__kernel_ior_open:Nn { No }
%    \end{macrocode}
% 在这里，我们采取防御性措施，以防使用\LuaTeX{}和无扩展名的文件名。
%    \begin{macrocode}
\cs_new_protected:Npe \@@_open_stream:Nn #1#2
  {
    \tex_global:D \tex_chardef:D #1 = \exp_not:N \l_@@_stream_tl \scan_stop:
    \prop_gput:NVn \exp_not:N \g_@@_streams_prop #1 {#2}
    \tex_openin:D #1
      \sys_if_engine_luatex:TF
        { {#2} }
        {  \exp_not:N \__kernel_file_name_quote:n {#2} \scan_stop: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\ior_shell_open:Nn}
% \begin{macro}{\@@_shell_open:nN, \@@_shell_open:oN}
% 实际上比标准的打开或输入版本要容易得多！
% 在调用\cs{__kernel_ior_open:Nn}时，文件上添加了管道以表示shell命令，但尚未添加引号，稍后由\cs{__kernel_file_name_quote:n}添加。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_shell_open:Nn #1#2
  {
    \sys_if_shell:TF
      { \@@_shell_open:oN { \tl_to_str:n {#2} } #1 }
      { \msg_error:nn { kernel } { pipe-failed } }
  }
\cs_new_protected:Npn \@@_shell_open:nN #1#2
  {
    \tl_if_in:nnTF {#1} { " }
      {
        \msg_error:nne
          { kernel } { quote-in-shell } {#1}
      }
      { \__kernel_ior_open:Nn #2 { |#1 } }
  }
\cs_generate_variant:Nn \@@_shell_open:nN { o }
\msg_new:nnnn { kernel } { pipe-failed }
  { Cannot~run~piped~system~commands. }
  {
    LaTeX~tried~to~call~a~system~process~but~this~was~not~possible.\\
    Try~the~"--shell-escape"~(or~"--enable-pipes")~option.
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\ior_close:N, \ior_close:c}
%   关闭流意味着在\TeX{}级别摆脱它，并从各种数据结构中删除。
%   除非传递的名称是无效的流编号（在范围$[0,15]$之外），否则可以关闭它。
%   另一方面，只有在尚未在堆栈中时才将其添加到堆栈中，以避免重复堆积。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_close:N #1
  {
    \int_compare:nT { -1 < #1 < \c_@@_term_ior }
      {
        \tex_closein:D #1
        \prop_gremove:NV \g_@@_streams_prop #1
        \seq_if_in:NVF \g_@@_streams_seq #1
          { \seq_gpush:NV \g_@@_streams_seq #1 }
        \cs_gset_eq:NN #1 \c_@@_term_ior
      }
  }
\cs_generate_variant:Nn \ior_close:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ior_show:N, \ior_log:N, \@@_show:NN}
%   寻找流在\cs{g_@@_streams_prop}列表中，然后根据情况显示流是否打开或关闭。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_show:N { \@@_show:NN \tl_show:n }
\cs_generate_variant:Nn \ior_show:N { c }
\cs_new_protected:Npn \ior_log:N { \@@_show:NN \tl_log:n }
\cs_generate_variant:Nn \ior_log:N { c }
\cs_new_protected:Npn \@@_show:NN #1#2
  {
    \__kernel_chk_defined:NT #2
      {
        \prop_get:NVNTF \g_@@_streams_prop #2 \l_@@_internal_tl
          {
            \exp_args:Ne #1
              { \token_to_str:N #2 ~ open: ~ \l_@@_internal_tl }
          }
          { \exp_args:Ne #1 { \token_to_str:N #2 ~ closed } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ior_show_list:, \ior_log_list:}
% \begin{macro}{\@@_list:N}
%   显示属性列表，但带有一些\enquote{漂亮的打印}。参见\pkg{l3msg}模块。
%   消息的第一个参数是|ior|（与|iow|相对），第二个参数为空如果没有读取流打开，
%   否则非空（使用\cs{msg_show_item_unbraced:nn}格式化的流列表）。
%   消息\texttt{show-streams}的代码负责将|ior|/|iow|翻译为英语。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_show_list: { \@@_list:N \msg_show:nneeee }
\cs_new_protected:Npn \ior_log_list: { \@@_list:N \msg_log:nneeee }
\cs_new_protected:Npn \@@_list:N #1
  {
    #1 { kernel } { show-streams }
      { ior }
      {
        \prop_map_function:NN \g_@@_streams_prop
          \msg_show_item_unbraced:nn
      }
      { } { }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{读取输入}
%
% \begin{macro}{\if_eof:w}
%   原始条件
%    \begin{macrocode}
\cs_new_eq:NN \if_eof:w \tex_ifeof:D
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\ior_if_eof:N}
%   为了测试某个特定的输入流是否耗尽，提供了以下条件。
%   原始测试只能处理范围$[0,15]$内的数字，所以我们捕获异常情况（它们已经耗尽）。
%    \begin{macrocode}
\prg_new_conditional:Npnn \ior_if_eof:N #1 { p , T , F , TF }
  {
    \if_int_compare:w -1 < #1
      \if_int_compare:w #1 < \c_@@_term_ior
        \if_eof:w #1
          \prg_return_true:
        \else:
          \prg_return_false:
        \fi:
      \else:
        \prg_return_true:
      \fi:
    \else:
      \prg_return_true:
    \fi:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ior_get:NN, \@@_get:NN}
% \begin{macro}[TF]{\ior_get:NN}
%   在这里我们从文件中读取。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_get:NN #1#2
  { \ior_get:NNF #1 #2 { \tl_set:Nn #2 { \q_no_value } } }
\cs_new_protected:Npn \@@_get:NN #1#2
  { \tex_read:D #1 to #2 }
\prg_new_protected_conditional:Npnn \ior_get:NN #1#2 { T , F , TF }
  {
    \ior_if_eof:NTF #1
      { \prg_return_false: }
      {
        \@@_get:NN #1 #2
        \prg_return_true:
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\ior_str_get:NN, \@@_str_get:NN}
% \begin{macro}[TF]{\ior_str_get:NN}
%   作为字符串读取是一个更复杂的换行器，因为我们希望
%   删除换行字符并在之后恢复它。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_str_get:NN #1#2
  { \ior_str_get:NNF #1 #2 { \tl_set:Nn #2 { \q_no_value } } }
\cs_new_protected:Npn \@@_str_get:NN #1#2
  {
    \exp_args:Nno \use:n
      {
        \int_set:Nn \tex_endlinechar:D { -1 }
        \tex_readline:D #1 to #2
        \int_set:Nn \tex_endlinechar:D
      }   { \int_use:N \tex_endlinechar:D }
  }
\prg_new_protected_conditional:Npnn \ior_str_get:NN #1#2 { T , F , TF }
  {
    \ior_if_eof:NTF #1
      { \prg_return_false: }
      {
        \@@_str_get:NN #1 #2
        \prg_return_true:
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\c_@@_term_noprompt_ior}
%   用于无提示的读取。
%    \begin{macrocode}
\int_const:Nn \c_@@_term_noprompt_ior { -1 }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\ior_get_term:nN, \ior_str_get_term:nN}
% \begin{macro}{\@@_get_term:NnN}
%   从终端获取最好使用漂亮的打印。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_get_term:nN #1#2
  { \@@_get_term:NnN \@@_get:NN {#1} #2 }
\cs_new_protected:Npn \ior_str_get_term:nN #1#2
  { \@@_get_term:NnN \@@_str_get:NN {#1} #2 }
\cs_new_protected:Npn \@@_get_term:NnN #1#2#3
  {
    \group_begin:
      \tex_escapechar:D = -1 \scan_stop:
      \tl_if_blank:nTF {#2}
        { \exp_args:NNc #1 \c_@@_term_noprompt_ior }
        { \exp_args:NNc #1 \c_@@_term_ior }
          {#2}
    \exp_args:NNNv \group_end:
    \tl_set:Nn #3 {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\ior_map_break:, \ior_map_break:n}
%   常规映射中断函数。
%    \begin{macrocode}
\cs_new:Npn \ior_map_break:
  { \prg_map_break:Nn \ior_map_break: { } }
\cs_new:Npn \ior_map_break:n
  { \prg_map_break:Nn \ior_map_break: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ior_map_inline:Nn, \ior_str_map_inline:Nn}
% \begin{macro}{\@@_map_inline:NNn}
% \begin{macro}{\@@_map_inline:NNNn}
% \begin{macro}{\@@_map_inline_loop:NNN}
%   在输入流上进行映射可以基于令牌或字符串进行，因此设置了两者。
%   在其中，有一个检查，以避免读取文件末尾之外的内容，因此使用了两次
%   \cs{ior_if_eof:N}及其底层相似物\cs{if_eof:w}。
%   该映射不能嵌套使用相同的流两次，因为流只有一个\enquote{当前行}。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_map_inline:Nn
  { \@@_map_inline:NNn \@@_get:NN }
\cs_new_protected:Npn \ior_str_map_inline:Nn
  { \@@_map_inline:NNn \@@_str_get:NN }
\cs_new_protected:Npn \@@_map_inline:NNn
  {
    \int_gincr:N \g__kernel_prg_map_int
    \exp_args:Nc \@@_map_inline:NNNn
      { @@_map_ \int_use:N \g__kernel_prg_map_int :n }
  }
\cs_new_protected:Npn \@@_map_inline:NNNn #1#2#3#4
  {
    \cs_gset_protected:Npn #1 ##1 {#4}
    \ior_if_eof:NF #3 { \@@_map_inline_loop:NNN #1#2#3 }
    \prg_break_point:Nn \ior_map_break:
      { \int_gdecr:N \g__kernel_prg_map_int }
  }
\cs_new_protected:Npn \@@_map_inline_loop:NNN #1#2#3
  {
    #2 #3 \l_@@_internal_tl
    \if_eof:w #3
      \exp_after:wN \ior_map_break:
    \fi:
    \exp_args:No #1 \l_@@_internal_tl
    \@@_map_inline_loop:NNN #1#2#3
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\ior_map_variable:NNn, \ior_str_map_variable:NNn}
% \begin{macro}{\@@_map_variable:NNNn}
% \begin{macro}{\@@_map_variable_loop:NNNn}
%   由于\TeX{}原语（\tn{read}或\tn{readline}）以与令牌列表分配相同的方式分配读取的令牌，
%   我们只需调用相应的原语。为了提高速度，使用原语条件检查循环结束。
%    \begin{macrocode}
\cs_new_protected:Npn \ior_map_variable:NNn
  { \@@_map_variable:NNNn \ior_get:NN }
\cs_new_protected:Npn \ior_str_map_variable:NNn
  { \@@_map_variable:NNNn \ior_str_get:NN }
\cs_new_protected:Npn \@@_map_variable:NNNn #1#2#3#4
  {
    \ior_if_eof:NF #2 { \@@_map_variable_loop:NNNn #1#2#3 {#4} }
    \prg_break_point:Nn \ior_map_break: { }
  }
\cs_new_protected:Npn \@@_map_variable_loop:NNNn #1#2#3#4
  {
    #1 #2 #3
    \if_eof:w #2
      \exp_after:wN \ior_map_break:
    \fi:
    #4
    \@@_map_variable_loop:NNNn #1#2#3 {#4}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{输出操作}
%
%    \begin{macrocode}
%<@@=iow>
%    \end{macrocode}
%
% 这里与输入操作有很多相似之处，至少对于许多基本操作来说是这样。
% 因此，从前面的材料中复制了相当多的内容，进行了一些小的修改。
%
% \subsubsection{变量和常量}
%
% \begin{variable}{\l_@@_internal_tl}
%   用作短期临时变量。
%    \begin{macrocode}
\tl_new:N  \l_@@_internal_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_log_iow, \c_term_iow}
%   在这里，我们为写入到传输文件（\cs{c_log_iow}）和同时写入到终端和传输文件（\cs{c_term_iow}）分配了两个输出流。
%   最近的\LuaTeX{}提供$128$个写入流；我们还将\cs{c_term_iow}用作第一个不允许写入流，因此其值取决于引擎。
%    \begin{macrocode}
\int_const:Nn \c_log_iow  { -1 }
\int_const:Nn \c_term_iow
  {
    \bool_lazy_and:nnTF
      { \sys_if_engine_luatex_p: }
      { \int_compare_p:nNn \tex_luatexversion:D > { 80 } }
      { 128 }
      { 16 }
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_streams_seq}
%   一个当前可用的输出流列表，用作堆栈。
%    \begin{macrocode}
\seq_new:N \g_@@_streams_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_stream_tl}
%   用于从堆栈中恢复原始流编号。
%    \begin{macrocode}
\tl_new:N \l_@@_stream_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_streams_prop}
%   就像读取一样，根据要检查的寄存器编号进行适当的调整。
%    \begin{macrocode}
\prop_new:N \g_@@_streams_prop
\int_step_inline:nnn
  { 0 }
  {
    \cs_if_exist:NTF \contextversion
      { \tex_count:D 39 ~ }
      {
        \tex_count:D 17 ~
        \cs_if_exist:NT \loccount { - 1 }
      }
  }
  {
    \prop_gput:Nnn \g_@@_streams_prop {#1} { Reserved~by~format }
  }
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{内部辅助}
%
% \begin{variable}{\s_@@_mark,\s_@@_stop}
%   内部扫描标记。
%    \begin{macrocode}
\scan_new:N \s_@@_mark
\scan_new:N \s_@@_stop
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP]{\@@_use_i_delimit_by_s_stop:nw}
%   到扫描标记的函数。
%    \begin{macrocode}
\cs_new:Npn \@@_use_i_delimit_by_s_stop:nw #1 #2 \s_@@_stop {#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\q_@@_nil}
%   内部 quark 。
%    \begin{macrocode}
\quark_new:N \q_@@_nil
%    \end{macrocode}
% \end{variable}
%
% \subsection{流管理}
%
% \begin{macro}{\iow_new:N, \iow_new:c}
%   通过将名称定义为写入终端来保留新流：奇怪但至少一致。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_new:N #1 { \cs_new_eq:NN #1 \c_term_iow }
\cs_generate_variant:Nn \iow_new:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_tmpa_iow, \g_tmpb_iow}
%   常规的临时空间。
%    \begin{macrocode}
\iow_new:N \g_tmpa_iow
\iow_new:N \g_tmpb_iow
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_new:N}
%   与读取流一样，复制\tn{newwrite}，确保它不是\tn{outer}。
%   对于\ConTeXt{}，我们必须处理\tn{newwrite}的工作方式与我们自己的相同的事实：在更改定义之前，它实际上会进行检查。
%    \begin{macrocode}
\exp_args:NNf \cs_new_protected:Npn \@@_new:N
  { \exp_args:NNc \exp_after:wN \exp_stop_f: { newwrite } }
\cs_if_exist:NT \contextversion
  {
    \cs_new_eq:NN \@@_new_aux:N \@@_new:N
    \cs_gset_protected:Npn \@@_new:N #1
      {
        \cs_undefine:N #1
        \@@_new_aux:N #1
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_file_name_tl}
%  数据存储。
%    \begin{macrocode}
\tl_new:N \l_@@_file_name_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\iow_open:Nn, \iow_open:NV, \iow_open:cn, \iow_open:cV}
% \begin{macro}{\@@_open_stream:Nn, \@@_open_stream:NV}
%   与读取相同的思路，但不包括路径，也不需要允许有条件版本。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_open:Nn #1#2
  {
    \__kernel_tl_set:Ne \l_@@_file_name_tl
      { \__kernel_file_name_sanitize:n {#2} }
    \iow_close:N #1
    \seq_gpop:NNTF \g_@@_streams_seq \l_@@_stream_tl
      { \@@_open_stream:NV #1 \l_@@_file_name_tl }
      {
        \@@_new:N #1
        \__kernel_tl_set:Ne \l_@@_stream_tl { \int_eval:n {#1} }
        \@@_open_stream:NV #1 \l_@@_file_name_tl
      }
  }
\cs_generate_variant:Nn \iow_open:Nn { NV , c , cV }
\cs_new_protected:Npn \@@_open_stream:Nn #1#2
  {
    \tex_global:D \tex_chardef:D #1 = \l_@@_stream_tl \scan_stop:
    \prop_gput:NVn \g_@@_streams_prop #1 {#2}
    \tex_immediate:D \tex_openout:D
        #1 \__kernel_file_name_quote:n {#2} \scan_stop:
  }
\cs_generate_variant:Nn \@@_open_stream:Nn { NV }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\iow_shell_open:Nn}
% \begin{macro}{\@@_shell_open:nN, \@@_shell_open:oN}
%   与\texttt{ior}版本非常相似。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_shell_open:Nn #1#2
  {
    \sys_if_shell:TF
      { \@@_shell_open:oN { \tl_to_str:n {#2} } #1 }
      { \msg_error:nn { kernel } { pipe-failed } }
  }
\cs_new_protected:Npn \@@_shell_open:nN #1#2
  {
    \tl_if_in:nnTF {#1} { " }
      {
        \msg_error:nne
          { kernel } { quote-in-shell } {#1}
      }
      { \__kernel_iow_open:Nn #2 { |#1 } }
  }
\cs_generate_variant:Nn \@@_shell_open:nN { o }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\iow_close:N, \iow_close:c}
%   关闭流不完全是打开的逆操作。首先，关闭操作比打开操作更容易，
%   其次，由于流实际上是一个数字，我们可以直接使用它来显示已释放的槽。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_close:N #1
  {
    \int_compare:nT { \c_log_iow < #1 < \c_term_iow }
      {
        \tex_immediate:D \tex_closeout:D #1
        \prop_gremove:NV \g_@@_streams_prop #1
        \seq_if_in:NVF \g_@@_streams_seq #1
          { \seq_gpush:NV \g_@@_streams_seq #1 }
        \cs_gset_eq:NN #1 \c_term_iow
      }
  }
\cs_generate_variant:Nn \iow_close:N { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\iow_show:N, \iow_log:N, \@@_show:NN}
%   在\cs{g_@@_streams_prop}列表中查找流，然后根据情况显示流是否打开或关闭。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_show:N { \@@_show:NN \tl_show:n }
\cs_generate_variant:Nn \iow_show:N { c }
\cs_new_protected:Npn \iow_log:N { \@@_show:NN \tl_log:n }
\cs_generate_variant:Nn \iow_log:N { c }
\cs_new_protected:Npn \@@_show:NN #1#2
  {
    \__kernel_chk_defined:NT #2
      {
        \prop_get:NVNTF \g_@@_streams_prop #2 \l_@@_internal_tl
          {
            \exp_args:Ne #1
              { \token_to_str:N #2 ~ open: ~ \l_@@_internal_tl }
          }
          { \exp_args:Ne #1 { \token_to_str:N #2 ~ closed } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\iow_show_list:, \iow_log_list:}
% \begin{macro}{\@@_list:N}
%   与输入一样，但是辅助函数的副本，以便名称是正确的。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_show_list: { \@@_list:N \msg_show:nneeee }
\cs_new_protected:Npn \iow_log_list: { \@@_list:N \msg_log:nneeee }
\cs_new_protected:Npn \@@_list:N #1
  {
    #1 { kernel } { show-streams }
      { iow }
      {
        \prop_map_function:NN \g_@@_streams_prop
          \msg_show_item_unbraced:nn
      }
      { } { }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{延迟写入}
%
% \begin{macro}
%   {
%     \iow_shipout_e:Nn, \iow_shipout_e:Ne,
%     \iow_shipout_e:cn, \iow_shipout_e:ce
%   }
%   首先是简单部分，这是原语，期望其参数用大括号括起来。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_shipout_e:Nn #1#2
  { \tex_write:D #1 {#2} }
\cs_generate_variant:Nn \iow_shipout_e:Nn { Ne , c, ce }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \iow_shipout:Nn, \iow_shipout:Ne,
%     \iow_shipout:Nx,
%     \iow_shipout:cn, \iow_shipout:ce,
%     \iow_shipout:cx
%   }
%   有了\eTeX{}，不带扩展的延迟写入很容易。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_shipout:Nn #1#2
  { \tex_write:D #1 { \exp_not:n {#2} } }
\cs_generate_variant:Nn \iow_shipout:Nn { Ne , c, ce }
\cs_generate_variant:Nn \iow_shipout:Nn { Nx , cx }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{立即写入}
%
% \begin{macro}{\__kernel_iow_with:Nnn}
% \begin{macro}{\@@_with:nNnn, \@@_with:oNnn}
%   如果整数~|#1| 等于~|#2|，则只需将~|#3| 保留在输入流中。
%   否则，将旧值传递给辅助函数，该函数将整数设置为新值，运行代码，然后还原整数。
%    \begin{macrocode}
\cs_new_protected:Npn \__kernel_iow_with:Nnn #1#2
  {
    \int_compare:nNnTF {#1} = {#2}
      { \use:n }
      { \@@_with:oNnn { \int_use:N #1 } #1 {#2} }
  }
\cs_new_protected:Npn \@@_with:nNnn #1#2#3#4
  {
    \int_set:Nn #2 {#3}
    #4
    \int_set:Nn #2 {#1}
  }
\cs_generate_variant:Nn \@@_with:nNnn { o }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}
%   {
%     \iow_now:Nn, \iow_now:NV, \iow_now:Ne,
%     \iow_now:Nx,
%     \iow_now:cn, \iow_now:cV, \iow_now:ce,
%     \iow_now:cx
%   }
%   该例程将第二个参数写入输出流，不进行扩展。
%   如果此流未打开，则输出转到终端。如果第一个参数根本不是输出流，我们会得到一个内部错误。
%   我们不使用\tn{write}执行的扩展来获得|Nx|变体，因为它与\texttt{x}-扩展在细微的方面有所不同，即，不需要将宏参数字符加倍。
%   我们使用\cs{__kernel_iow_with:Nnn}将\tn{newlinechar}设置为$10$，以支持格式，例如plain \TeX{}：否则，\cs{iow_newline:} 将无法工作。
%   我们对\cs{iow_shipout:Nn}或\cs{iow_shipout_x:Nn}不执行此操作，因为在这些情况下，\TeX{}在出航时查看\tn{newlinechar}的值。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_now:Nn #1#2
  {
    \__kernel_iow_with:Nnn \tex_newlinechar:D { `\^^J }
      { \tex_immediate:D \tex_write:D #1 { \exp_not:n {#2} } }
  }
\cs_generate_variant:Nn \iow_now:Nn { NV , Ne , c , cV , ce }
\cs_generate_variant:Nn \iow_now:Nn { Nx , cx }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\iow_log:n, \iow_log:e, \iow_log:x}
% \begin{macro}{\iow_term:n, \iow_term:e, \iow_term:x}
%   直接写入日志和终端相对较容易。
%   由于我们需要两个\texttt{e}-类型的变体进行引导，因此在这里进行重新定义。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_log:n  { \iow_now:Nn \c_log_iow  }
\cs_set_protected:Npn \iow_log:e  { \iow_now:Ne \c_log_iow  }
\cs_generate_variant:Nn \iow_log:n { x }
\cs_new_protected:Npn \iow_term:n { \iow_now:Nn \c_term_iow }
\cs_set_protected:Npn \iow_term:e { \iow_now:Ne \c_term_iow }
\cs_generate_variant:Nn \iow_term:n { x }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{写入的特殊字符}
%
% \begin{macro}{\iow_newline:}
%   全局变量，保存强制将新行写入输出流时的字符。
%    \begin{macrocode}
\cs_new:Npn \iow_newline: { ^^J }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\iow_char:N}
%   用于将任何转义字符写入输出流的函数。
%    \begin{macrocode}
\cs_new_eq:NN \iow_char:N \cs_to_str:N
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{将行硬换行到字符计数}
%
% 此处的代码实现了通用的硬换行函数。这用于消息系统，但设计为可用于其他用途。
%
% \begin{variable}{\l_iow_line_count_int}
%   这是可以写入终端的一行字符的\enquote{原始}数量。
%   标准值是\TeX{} Live和\hologo{MiKTeX}通常使用的行长度。
%    \begin{macrocode}
\int_new:N  \l_iow_line_count_int
\int_set:Nn \l_iow_line_count_int { 78 }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_newline_tl}
%   插入产生新行的记号列表，带有\meta{run-on text}。
%    \begin{macrocode}
\tl_new:N \l_@@_newline_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_line_target_int}
%   这存储目标行数：每行字符的完整数量，减去每行开头的引导部分。
%    \begin{macrocode}
\int_new:N \l_@@_line_target_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_set_indent:n}
% \begin{macro}{\@@_unindent:w}
% \begin{variable}{\l_@@_one_indent_tl, \l_@@_one_indent_int}
%   \texttt{one_indent}变量保存一个缩进标记及其长度。
%   \cs{@@_unindent:w}辅助函数删除一个缩进。
%   函数\cs{@@_set_indent:n}（可能是公共的）以一致的方式设置缩进。默认设置为四个空格。
%    \begin{macrocode}
\tl_new:N \l_@@_one_indent_tl
\int_new:N \l_@@_one_indent_int
\cs_new:Npn \@@_unindent:w { }
\cs_new_protected:Npn \@@_set_indent:n #1
  {
    \__kernel_tl_set:Ne \l_@@_one_indent_tl
      { \exp_args:No \__kernel_str_to_other_fast:n { \tl_to_str:n {#1} } }
    \int_set:Nn \l_@@_one_indent_int
      { \str_count:N \l_@@_one_indent_tl }
    \exp_last_unbraced:NNo
      \cs_set:Npn \@@_unindent:w \l_@@_one_indent_tl { }
  }
\exp_args:Ne \@@_set_indent:n { \prg_replicate:nn { 4 } { ~ } }
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\l_@@_indent_tl, \l_@@_indent_int}
%   当前缩进（\cs{l_@@_one_indent_tl}的一些副本）及其字符数。
%    \begin{macrocode}
\tl_new:N \l_@@_indent_tl
\int_new:N \l_@@_indent_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_line_tl, \l_@@_line_part_tl}
%   这些分别保存当前文本行和要添加到它的部分行。
%    \begin{macrocode}
\tl_new:N \l_@@_line_tl
\tl_new:N \l_@@_line_part_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_line_break_bool}
%   指示行是否精确地在块边界处中断的布尔值。
%    \begin{macrocode}
\bool_new:N \l_@@_line_break_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_wrap_tl}
%   用于解标记之前的扩展步骤，以及用于换行文本的输出：完全展开，行不会过长。
%    \begin{macrocode}
\tl_new:N \l_@@_wrap_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_@@_wrap_marker_tl}
% \begin{variable}
%   {
%     \c_@@_wrap_end_marker_tl,
%     \c_@@_wrap_newline_marker_tl,
%     \c_@@_wrap_allow_break_marker_tl,
%     \c_@@_wrap_indent_marker_tl,
%     \c_@@_wrap_unindent_marker_tl
%   }
%   换行代码的每个特殊操作都以相同可识别的字符串\cs{c_@@_wrap_marker_tl}开头。
%   看到该\enquote{word}后，换行代码读取一个空格分隔的参数，以知道要执行的操作。
%   此处设置\tn{escapechar}并不是非常重要，但使\cs{c_@@_wrap_marker_tl}看起来略微更漂亮。
%    \begin{macrocode}
\group_begin:
  \int_set:Nn \tex_escapechar:D { -1 }
  \tl_const:Ne \c_@@_wrap_marker_tl
    { \tl_to_str:n { \^^I \^^O \^^W \^^_ \^^W \^^R \^^A \^^P } }
\group_end:
\tl_map_inline:nn
  { { end } { newline } { allow_break } { indent } { unindent } }
  {
    \tl_const:ce { c_@@_wrap_ #1 _marker_tl }
      {
        \c_@@_wrap_marker_tl
        #1
        \c_catcode_other_space_tl
      }
  }
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{macro}{\iow_wrap_allow_break:}
% \begin{macro}[EXP]{\@@_wrap_allow_break:}
% \begin{macro}[EXP]{\@@_wrap_allow_break_error:}
%   我们将\cs{iow_wrap_allow_break:n}设置为在消息外部产生错误。
%   在换行消息中，如果有效，它设置为\cs{@@_wrap_allow_break:}，否则为\cs{@@_wrap_allow_break_error:}。
%   第二个是可展开产生错误。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_wrap_allow_break:
  {
    \msg_error:nnnn { kernel } { iow-indent }
      { \iow_wrap:nnnN } { \iow_wrap_allow_break: }
  }
\cs_new:Npe \@@_wrap_allow_break: { \c_@@_wrap_allow_break_marker_tl }
\cs_new:Npn \@@_wrap_allow_break_error:
  {
    \msg_expandable_error:nnnn { kernel } { iow-indent }
      { \iow_wrap:nnnN } { \iow_wrap_allow_break: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\iow_indent:n}
% \begin{macro}[EXP]{\@@_indent:n}
% \begin{macro}[EXP]{\@@_indent_error:n}
%   我们将\cs{iow_indent:n}设置为在消息外部产生错误。
%   在换行消息中，如果有效，它设置为\cs{@@_indent:n}，否则为\cs{@@_indent_error:n}。
%   第一个在其参数之前放置增加缩进的指令，以及之后放置减少缩进的指令。
%   第二个是可展开产生错误。请注意，没有强制换行，因此缩进仅在下一行开始时更改。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_indent:n #1
  {
    \msg_error:nnnnn { kernel } { iow-indent }
      { \iow_wrap:nnnN } { \iow_indent:n } {#1}
    #1
  }
\cs_new:Npe \@@_indent:n #1
  {
    \c_@@_wrap_indent_marker_tl
    #1
    \c_@@_wrap_unindent_marker_tl
  }
\cs_new:Npn \@@_indent_error:n #1
  {
    \msg_expandable_error:nnnnn { kernel } { iow-indent }
      { \iow_wrap:nnnN } { \iow_indent:n } {#1}
    #1
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\iow_wrap:nnnN, \iow_wrap:nenN}
%   主要的换行函数工作如下。首先给出|\\|、\verb*|\ |等格式化命令正确的定义以及执行给定的设置~|#3|。
%   \verb*|\ |的定义使用\enquote{other} space而不是正常空格，因为后者可能被\TeX{}吸收以结束数字或其他\texttt{f}-type扩展。
%   如果定义了\cs{conditionally@traceoff}，则使用它；它由\pkg{trace}宏包引入，抑制换行代码的不相关跟踪。
%    \begin{macrocode}
\cs_new_protected:Npn \iow_wrap:nnnN #1#2#3#4
  {
    \group_begin:
      \cs_if_exist_use:N \conditionally@traceoff
      \int_set:Nn \tex_escapechar:D { -1 }
      \cs_set:Npe \{ { \token_to_str:N \{ }
      \cs_set:Npe \# { \token_to_str:N \# }
      \cs_set:Npe \} { \token_to_str:N \} }
      \cs_set:Npe \% { \token_to_str:N \% }
      \cs_set:Npe \~ { \token_to_str:N \~ }
      \int_set:Nn \tex_escapechar:D { 92 }
      \cs_set_eq:NN \\ \iow_newline:
      \cs_set_eq:NN \  \c_catcode_other_space_tl
      \cs_set_eq:NN \iow_wrap_allow_break: \@@_wrap_allow_break:
      \cs_set_eq:NN \iow_indent:n \@@_indent:n
      #3
%    \end{macrocode}
%   然后完全展开输入：在宏包模式中，扩展使用\LaTeXe{}的\tn{protect}机制，与\tn{typeout}相同。
%   在通用模式中，此设置无用但无害。一旦展开完成，将\cs{iow_indent:n}重置为其错误定义：它只在\cs{iow_wrap:nnnN}的第一个参数中起作用。
%    \begin{macrocode}
      \cs_set_eq:NN \protect \token_to_str:N
      \__kernel_tl_set:Ne \l_@@_wrap_tl {#1}
      \cs_set_eq:NN \iow_wrap_allow_break: \@@_wrap_allow_break_error:
      \cs_set_eq:NN \iow_indent:n \@@_indent_error:n
%    \end{macrocode}
%   然后，设置换行标记（两次赋值完全展开，然后转换为字符串），并初始化行的目标计数（第一行的目标计数为\cs{l_iow_line_count_int}）。
%    \begin{macrocode}
      \__kernel_tl_set:Ne \l_@@_newline_tl { \iow_newline: #2 }
      \__kernel_tl_set:Ne \l_@@_newline_tl { \tl_to_str:N \l_@@_newline_tl }
      \int_set:Nn \l_@@_line_target_int
        { \l_iow_line_count_int - \str_count:N \l_@@_newline_tl + 1 }
%    \end{macrocode}
%   完整性检查。
%    \begin{macrocode}
      \int_compare:nNnT { \l_@@_line_target_int } < 0
        {
          \tl_set:Nn \l_@@_newline_tl { \iow_newline: }
          \int_set:Nn \l_@@_line_target_int
            { \l_iow_line_count_int + 1 }
        }
%    \end{macrocode}
%   然后是对输入的循环，它将换行的结果存储在\cs{l_@@_wrap_tl}中。循环后，将结果的文本传递给作为后处理器给定的函数。
%   \cs{tl_to_str:N}步骤将\enquote{other}空格转换回普通空格。\texttt{f}-expansion从\cs{l_@@_wrap_tl}中移除前导空格。
%    \begin{macrocode}
      \@@_wrap_do:
    \exp_args:NNf \group_end:
    #4 { \tl_to_str:N \l_@@_wrap_tl }
  }
\cs_generate_variant:Nn \iow_wrap:nnnN { ne }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_do:, \@@_wrap_fix_newline:w, \@@_wrap_start:w}
%   转义空格并将换行符更改为\cs{c_@@_wrap_newline_marker_tl}。
%   设置一些变量，特别是\cs{l_@@_wrap_tl}的初始值：
%   空格停止主换行函数的\texttt{f}-扩展，\cs{use_none:n}去除后续代码插入的换行符。
%   主循环包括反复调用\texttt{chunk}辅助程序，以换行由（换行符或缩进）标记界定的块。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_do:
  {
    \__kernel_tl_set:Ne \l_@@_wrap_tl
      {
        \exp_args:No \__kernel_str_to_other_fast:n \l_@@_wrap_tl
        \c_@@_wrap_end_marker_tl
      }
    \__kernel_tl_set:Ne \l_@@_wrap_tl
      {
        \exp_after:wN \@@_wrap_fix_newline:w \l_@@_wrap_tl
          ^^J \q_@@_nil ^^J \s_@@_stop
      }
    \exp_after:wN \@@_wrap_start:w \l_@@_wrap_tl
  }
\cs_new:Npn \@@_wrap_fix_newline:w #1 ^^J #2 ^^J
  {
    #1
    \if_meaning:w \q_@@_nil #2
      \@@_use_i_delimit_by_s_stop:nw
    \fi:
    \c_@@_wrap_newline_marker_tl
    \@@_wrap_fix_newline:w #2 ^^J
  }
\cs_new_protected:Npn \@@_wrap_start:w
  {
    \bool_set_false:N \l_@@_line_break_bool
    \tl_clear:N \l_@@_line_tl
    \tl_clear:N \l_@@_line_part_tl
    \tl_set:Nn \l_@@_wrap_tl { ~ \use_none:n }
    \int_zero:N \l_@@_indent_int
    \tl_clear:N \l_@@_indent_tl
    \@@_wrap_chunk:nw { \l_iow_line_count_int }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_chunk:nw, \@@_wrap_next:nw}
%   辅助程序\texttt{chunk}和\texttt{next}间接定义，
%   以获取\cs{c_catcode_other_space_tl}和\cs{c_@@_wrap_marker_tl}的扩展。
%   \texttt{next}辅助程序调用与标记类型相对应的函数（其|##2|），
%   可以是\texttt{newline}、\texttt{indent}、\texttt{unindent}或\texttt{end}。
%   \texttt{chunk}辅助程序的第一个参数是字符的目标数，第二个是要换行的字符串。
%   如果块为空，只需调用\texttt{next}。否则，设置调用\cs{@@_wrap_line:nw}的调用，
%   包括如果当前行为空则包括缩进，并在\cs{@@_wrap_end_chunk:w}辅助程序之前包括一个尾随空格（|#1|）。
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1#2
  {
    \cs_new_protected:Npn \@@_wrap_chunk:nw ##1##2 #2
      {
        \tl_if_empty:nTF {##2}
          {
            \tl_clear:N \l_@@_line_part_tl
            \@@_wrap_next:nw {##1}
          }
          {
            \tl_if_empty:NTF \l_@@_line_tl
              {
                \@@_wrap_line:nw
                  { \l_@@_indent_tl }
                  ##1 - \l_@@_indent_int ;
              }
              { \@@_wrap_line:nw { } ##1 ; }
            ##2 #1
            \@@_wrap_end_chunk:w 7 6 5 4 3 2 1 0 \s_@@_stop
          }
      }
    \cs_new_protected:Npn \@@_wrap_next:nw ##1##2 #1
      { \use:c { @@_wrap_##2:n } {##1} }
  }
\exp_args:NVV \@@_tmp:w \c_catcode_other_space_tl \c_@@_wrap_marker_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_line:nw}
% \begin{macro}[EXP]
%   {
%     \@@_wrap_line_loop:w,
%     \@@_wrap_line_aux:Nw,
%     \@@_wrap_line_seven:nnnnnnn,
%     \@@_wrap_line_end:NnnnnnnnN,
%     \@@_wrap_line_end:nw,
%     \@@_wrap_end_chunk:w
%   }
%   接下来是\Arg{string} \meta{int expr} |;|。它将\meta{string}和来自当前块的\meta{int expr}字符存储到\cs{l_@@_line_part_tl}中。
%   字符以8个为一组抓取，并由\texttt{line_loop}辅助程序将其留在\cs{l_@@_line_part_tl}中。
%   当还有$k<8$个要找到时，\texttt{line_aux}辅助程序调用\texttt{line_end}辅助程序，后跟（单个数字）$k$，然后是$7-k$个空的花括号组，
%   然后是块的剩余字符。 \texttt{line_end}辅助程序将来自块的$k$个字符留在行部分中，然后结束赋值。
%   暂时忽略\cs{use_none:nnnnn}行。如果下一个字符是空格，则可以在此处换行：
%   将找到的内容存储到结果中并获取下一行。否则，需要一些工作来找到断点。
%   到目前为止，我们忽略了如果块短于请求的字符数会发生什么：这由\texttt{end_chunk}辅助程序处理，
%   它被代码的其余部分视为字符处理。它最终被调用为\texttt{line_loop}辅助程序的参数之一|#2|--|#9|，
%   或者作为\texttt{line_end}辅助程序的参数之一|#2|--|#8|。在这两种情况下，停止赋值并计算尚需多少字符。
%   请注意，当我们有七个参数需要清理时，必须插入\cs{exp_stop_f:}来停止\cs{exp:w}。奇怪的\cs{use_none:nnnnn}确保所需的数据位于正确的位置。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_line:nw #1
  {
    \tex_edef:D \l_@@_line_part_tl { \if_false: } \fi:
    #1
    \exp_after:wN \@@_wrap_line_loop:w
    \int_value:w \int_eval:w
  }
\cs_new:Npn \@@_wrap_line_loop:w #1 ; #2#3#4#5#6#7#8#9
  {
    \if_int_compare:w #1 < 8 \exp_stop_f:
      \@@_wrap_line_aux:Nw #1
    \fi:
    #2 #3 #4 #5 #6 #7 #8 #9
    \exp_after:wN \@@_wrap_line_loop:w
    \int_value:w \int_eval:w #1 - 8 ;
  }
\cs_new:Npn \@@_wrap_line_aux:Nw #1#2#3 \exp_after:wN #4 ;
  {
    #2
    \exp_after:wN \@@_wrap_line_end:NnnnnnnnN
    \exp_after:wN #1
    \exp:w \exp_end_continue_f:w
    \exp_after:wN \exp_after:wN
    \if_case:w #1 \exp_stop_f:
         \prg_do_nothing:
    \or: \use_none:n
    \or: \use_none:nn
    \or: \use_none:nnn
    \or: \use_none:nnnn
    \or: \use_none:nnnnn
    \or: \use_none:nnnnnn
    \or: \@@_wrap_line_seven:nnnnnnn
    \fi:
    { } { } { } { } { } { } { } #3
  }
\cs_new:Npn \@@_wrap_line_seven:nnnnnnn #1#2#3#4#5#6#7 { \exp_stop_f: }
\cs_new:Npn \@@_wrap_line_end:NnnnnnnnN #1#2#3#4#5#6#7#8#9
  {
    #2 #3 #4 #5 #6 #7 #8
    \use_none:nnnnn \int_eval:w 8 - ; #9
    \token_if_eq_charcode:NNTF \c_space_token #9
      { \@@_wrap_line_end:nw { } }
      { \if_false: { \fi: } \@@_wrap_break:w #9 }
  }
\cs_new:Npn \@@_wrap_line_end:nw #1
  {
    \if_false: { \fi: }
    \@@_wrap_store_do:n {#1}
    \@@_wrap_next_line:w
  }
\cs_new:Npn \@@_wrap_end_chunk:w
    #1 \int_eval:w #2 - #3 ; #4#5 \s_@@_stop
  {
    \if_false: { \fi: }
    \exp_args:Nf \@@_wrap_next:nw { \int_eval:n { #2 - #4 } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_wrap_break:w}
% \begin{macro}[EXP]
%   {
%     \@@_wrap_break_first:w,
%     \@@_wrap_break_none:w,
%     \@@_wrap_break_loop:w,
%     \@@_wrap_break_end:w,
%   }
%   这里定义的函数是间接定义的：\cs{@@_tmp:w} 最终会以一个“其他”空格作为其参数调用。
%   目标是从\cs{l_@@_line_part_tl}中移除最后一个空格之后的部分。
%   在大多数情况下，这是通过反复调用\texttt{break_loop}辅助程序完成的，该程序在达到尾随空格之前留下“单词”（由空格分隔）：
%   然后其参数 |##3| 是 |?| \cs{@@_wrap_break_end:w} 而不是单个标记，而\texttt{break_end}辅助程序在分配中留下直到最后一个空格的行，然后调用\cs{@@_wrap_line_end:nw}来完成行并继续下一个。
%   如果\cs{l_@@_line_part_tl}中没有空格，那么\texttt{break_first}辅助程序调用\texttt{break_none}辅助程序。
%   在这种情况下，如果当前行为空，则将完整的单词（包括 |##4|，超出我们抓取的字符之外的字符）添加到行中，使其过长。
%   否则，该单词用于下一行（并且由于存在标记，因此删除到目前为止的行的最后一个空格）。
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1
  {
    \cs_new:Npn \@@_wrap_break:w
      {
        \tex_edef:D \l_@@_line_part_tl
          { \if_false: } \fi:
            \exp_after:wN \@@_wrap_break_first:w
            \l_@@_line_part_tl
            #1
            { ? \@@_wrap_break_end:w }
            \s_@@_mark
      }
    \cs_new:Npn \@@_wrap_break_first:w ##1 #1 ##2
      {
        \use_none:nn ##2 \@@_wrap_break_none:w
        \@@_wrap_break_loop:w ##1 #1 ##2
      }
    \cs_new:Npn \@@_wrap_break_none:w ##1##2 #1 ##3 \s_@@_mark ##4 #1
      {
        \tl_if_empty:NTF \l_@@_line_tl
          { ##2 ##4 \@@_wrap_line_end:nw { } }
          { \@@_wrap_line_end:nw { \@@_wrap_trim:N } ##2 ##4 #1 }
      }
    \cs_new:Npn \@@_wrap_break_loop:w ##1 #1 ##2 #1 ##3
      {
        \use_none:n ##3
        ##1 #1
        \@@_wrap_break_loop:w ##2 #1 ##3
      }
    \cs_new:Npn \@@_wrap_break_end:w ##1 #1 ##2 ##3 #1 ##4 \s_@@_mark
      { ##1 \@@_wrap_line_end:nw { } ##3 }
  }
\exp_args:NV \@@_tmp:w \c_catcode_other_space_tl
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_wrap_next_line:w}
%   在这里检测到特殊情况，即一行的结尾与块的结尾重合，以避免产生虚假的空行。
%   否则，调用\cs{@@_wrap_line:nw}来查找下一行的字符（记得考虑缩进）。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_next_line:w #1#2 \s_@@_stop
  {
    \tl_clear:N \l_@@_line_tl
    \token_if_eq_meaning:NNTF #1 \@@_wrap_end_chunk:w
      {
        \tl_clear:N \l_@@_line_part_tl
        \bool_set_true:N \l_@@_line_break_bool
        \@@_wrap_next:nw { \l_@@_line_target_int }
      }
      {
        \@@_wrap_line:nw
          { \l_@@_indent_tl }
          \l_@@_line_target_int - \l_@@_indent_int ;
          #1 #2 \s_@@_stop
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_allow_break:n}
%   在换行完块后调用这个函数。由于\texttt{allow\_break}标记不应插入空格，因此通常\cs{l_@@_line_part_tl}以空格结尾（除非在行的开头？），我们移除它。
%   然后继续下一个块，确保调整行的目标字符数，以防我们删除了一个空格。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_allow_break:n #1
  {
    \__kernel_tl_set:Ne \l_@@_line_tl
      { \l_@@_line_tl \@@_wrap_trim:N \l_@@_line_part_tl }
    \bool_set_false:N \l_@@_line_break_bool
    \tl_if_empty:NTF \l_@@_line_part_tl
      { \@@_wrap_chunk:nw {#1} }
      { \exp_args:Nf \@@_wrap_chunk:nw { \int_eval:n { #1 + 1 } } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_indent:n, \@@_wrap_unindent:n}
%   这些函数在换行完块后，在遇到\texttt{indent}/\texttt{unindent}标记时调用。
%   将行部分（前一个块的最后一行部分）添加到行中，并重置表示存在换行的布尔值。
%   最重要的是，从当前缩进（整数和记号列表）中添加或删除一个缩进。
%   最后，继续换行。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_indent:n #1
  {
    \tl_put_right:Ne \l_@@_line_tl { \l_@@_line_part_tl }
    \bool_set_false:N \l_@@_line_break_bool
    \int_add:Nn \l_@@_indent_int { \l_@@_one_indent_int }
    \tl_put_right:No \l_@@_indent_tl { \l_@@_one_indent_tl }
    \@@_wrap_chunk:nw {#1}
  }
\cs_new_protected:Npn \@@_wrap_unindent:n #1
  {
    \tl_put_right:Ne \l_@@_line_tl { \l_@@_line_part_tl }
    \bool_set_false:N \l_@@_line_break_bool
    \int_sub:Nn \l_@@_indent_int { \l_@@_one_indent_int }
    \__kernel_tl_set:Ne \l_@@_indent_tl
      { \exp_after:wN \@@_unindent:w \l_@@_indent_tl }
    \@@_wrap_chunk:nw {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_newline:n, \@@_wrap_end:n}
%   在遇到\texttt{newline}/\texttt{end}标记时，这些函数在一块文本被换行后被调用。
%   除非刚刚发生过换行，否则将行部分和当前行存储到整个\cs{l_@@_wrap_tl}中，修剪尾随空格。
%   在\texttt{newline}情况下，在新的块中查找长度为\cs{l_@@_line_target_int}的新行。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_newline:n #1
  {
    \bool_if:NF \l_@@_line_break_bool
      { \@@_wrap_store_do:n { \@@_wrap_trim:N } }
    \bool_set_false:N \l_@@_line_break_bool
    \@@_wrap_chunk:nw { \l_@@_line_target_int }
  }
\cs_new_protected:Npn \@@_wrap_end:n #1
  {
    \bool_if:NF \l_@@_line_break_bool
      { \@@_wrap_store_do:n { \@@_wrap_trim:N } }
    \bool_set_false:N \l_@@_line_break_bool
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_wrap_store_do:n}
%   首先将最后一行部分添加到行中，然后将其附加到\cs{l_@@_wrap_tl}中，带有适当的新行
%   （带有“run-on”文本），可能会去掉其最后的空格（|#1|为空或\cs{@@_wrap_trim:N}）。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_wrap_store_do:n #1
  {
    \__kernel_tl_set:Ne \l_@@_line_tl
      { \l_@@_line_tl \l_@@_line_part_tl }
    \__kernel_tl_set:Ne \l_@@_wrap_tl
      {
        \l_@@_wrap_tl
        \l_@@_newline_tl
        #1 \l_@@_line_tl
      }
    \tl_clear:N \l_@@_line_tl
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_wrap_trim:N, \@@_wrap_trim:w, \@@_wrap_trim_aux:w}
%   如果存在，从参数中删除一个尾随的“other”空格。
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1
  {
    \cs_new:Npn \@@_wrap_trim:N ##1
      { \exp_after:wN \@@_wrap_trim:w ##1 \s_@@_mark #1 \s_@@_mark \s_@@_stop }
    \cs_new:Npn \@@_wrap_trim:w ##1 #1 \s_@@_mark
      { \@@_wrap_trim_aux:w ##1 \s_@@_mark }
    \cs_new:Npn \@@_wrap_trim_aux:w ##1 \s_@@_mark ##2 \s_@@_stop {##1}
  }
\exp_args:NV \@@_tmp:w \c_catcode_other_space_tl
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<@@=file>
%    \end{macrocode}
%
% \subsection{文件操作}
%
% \begin{variable}{\l_@@_internal_tl}
%   用作短期临时变量。
%    \begin{macrocode}
\tl_new:N \l_@@_internal_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \g_file_curr_dir_str ,
%     \g_file_curr_ext_str ,
%     \g_file_curr_name_str
%   }
%   当前文件的名称应始终可用：名称本身是动态设置的。
%    \begin{macrocode}
\str_new:N \g_file_curr_dir_str
\str_new:N \g_file_curr_ext_str
\str_new:N \g_file_curr_name_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_stack_seq}
%   输入文件列表被存储为序列栈。在包模式下，我们可以从\LaTeXe{}保存的详细信息中恢复信息
%   （我们必须在导言中以\tn{usepackage}或\tn{RequirePackage}加载）。
%   由于\LaTeXe{}不分别存储目录和名称，我们在这里坚持相同的约定。在预加载中，\tn{@currnamestack}为空，因此被跳过。
%    \begin{macrocode}
\seq_new:N \g_@@_stack_seq
\group_begin:
  \cs_set_protected:Npn \@@_tmp:w #1#2#3
    {
      \tl_if_blank:nTF {#1}
        {
          \cs_set:Npn \@@_tmp:w ##1 " ##2 " ##3 \s_@@_stop
            { { } {##2} {  } }
          \seq_gput_right:Ne \g_@@_stack_seq
            {
              \exp_after:wN \@@_tmp:w \tex_jobname:D
                " \tex_jobname:D " \s_@@_stop
            }
        }
        {
          \seq_gput_right:Nn \g_@@_stack_seq { { } {#1} {#2} }
          \@@_tmp:w
        }
    }
  \cs_if_exist:NT \@currnamestack
    {
      \tl_if_empty:NF \@currnamestack
        { \exp_after:wN \@@_tmp:w \@currnamestack }
    }
\group_end:
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_record_seq}
%   用于记录单独存储的文件使用列表，因为从此列表中永远不会弹出任何内容。
%   当前文件名应包含在文件列表中！我们最终将复制\cs{@filelist}的内容。
%    \begin{macrocode}
\seq_new:N \g_@@_record_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_base_name_tl, \l_@@_full_name_tl}
%   用于在内部传递数据时存储基本名称和完整路径。
%    \begin{macrocode}
\tl_new:N \l_@@_base_name_tl
\tl_new:N \l_@@_full_name_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_dir_str, \l_@@_ext_str, \l_@@_name_str}
%   用于解析路径的变量：与上述变量相比，这些变量从未在当前模块之外使用。
%    \begin{macrocode}
\str_new:N \l_@@_dir_str
\str_new:N \l_@@_ext_str
\str_new:N \l_@@_name_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_file_search_path_seq}
%   当前搜索路径。
%    \begin{macrocode}
\seq_new:N \l_file_search_path_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_tmp_seq}
%   用于逗号列表转换的临时空间。
%    \begin{macrocode}
\seq_new:N \l_@@_tmp_seq
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{内部辅助功能}
%
% \begin{variable}{\s_@@_stop}
%   内部扫描标记。
%    \begin{macrocode}
\scan_new:N \s_@@_stop
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\q_@@_nil}
%   内部 quark 。
%    \begin{macrocode}
\quark_new:N \q_@@_nil
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[pTF]{\@@_quark_if_nil:n}
%   分支quark条件。
%    \begin{macrocode}
\__kernel_quark_new_conditional:Nn \@@_quark_if_nil:n { TF }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\q_@@_recursion_tail,\q_@@_recursion_stop}
%   内部递归quarks。
%    \begin{macrocode}
\quark_new:N \q_@@_recursion_tail
\quark_new:N \q_@@_recursion_stop
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP]{
%     \@@_if_recursion_tail_break:NN,
%     \@@_if_recursion_tail_stop_do:Nn
%   }
%   查询递归quarks的函数。
%    \begin{macrocode}
\__kernel_quark_new_test:N \@@_if_recursion_tail_stop:N
\__kernel_quark_new_test:N \@@_if_recursion_tail_stop_do:nn
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\__kernel_file_name_sanitize:n}
% \begin{macro}[EXP]{
%     \@@_name_expand:n,
%     \@@_name_expand_cleanup:Nw,
%     \@@_name_expand_cleanup:w,
%     \@@_name_expand_end:,
%     \@@_name_expand_error:Nw,
%     \@@_name_expand_error_aux:Nw,
%   }
% \begin{macro}[EXP]{
%     \@@_name_strip_quotes:n,
%     \@@_name_strip_quotes:nnnw,
%     \@@_name_strip_quotes:nnn,
%   }
% \begin{macro}[EXP]{
%     \@@_name_trim_spaces:n,
%     \@@_name_trim_spaces:nw,
%     \@@_name_trim_spaces_aux:n,
%     \@@_name_trim_spaces_aux:w,
%   }
%   扩展文件名使用\tn{csname}为基础的方法，依赖于活动字符（例如UTF-8字符）的正确设置，
%   以扩展为使用\cs{ifcsname}的扩展安全版本。
%   这比以前使用的逐个标记的方法更不保守，但速度更快。
%    \begin{macrocode}
\cs_new:Npn \__kernel_file_name_sanitize:n #1
  {
    \exp_args:Ne \@@_name_trim_spaces:n
      {
        \exp_args:Ne \@@_name_strip_quotes:n
          { \@@_name_expand:n {#1} }
      }
  }
%    \end{macrocode}
%
%   我们将使用\cs{cs:w}开始扩展文件名，为了避免创建与\tn{relax}相等的csnames并具有“common”名称，
%   csname前缀为|__file_name=|。结尾处还有一个守卫标记，以便我们可以检查在此过程中是否有错误，并（尽力）进行优雅清理。
%    \begin{macrocode}
\cs_new:Npn \@@_name_expand:n #1
  {
    \exp_after:wN \@@_name_expand_cleanup:Nw
      \cs:w @@_name = #1 \cs_end:
        \@@_name_expand_end:
  }
%    \end{macrocode}
%   构建csname后，我们获取它，并获取由\cs{@@_name_expand_end:}定界的剩余标记。如果还有剩余标记，那么出现了问题，
%   因此我们将调用错误程序\cs{@@_name_expand_error:Nw}。如果一切按计划进行，那么在csname上使用\cs{token_to_str:N}，
%   并调用\cs{@@_name_expand_cleanup:w}以删除我们之前添加的前缀。
%   \cs{@@_name_expand_cleanup:w}带有前导参数，因此我们不必担心\cs{tex_escapechar:D}的值。
%    \begin{macrocode}
\cs_new:Npn \@@_name_expand_cleanup:Nw #1 #2 \@@_name_expand_end:
  {
    \tl_if_empty:nF {#2}
      { \@@_name_expand_error:Nw #2 \@@_name_expand_end: }
    \exp_after:wN \@@_name_expand_cleanup:w \token_to_str:N #1
  }
\exp_last_unbraced:NNNNo
\cs_new:Npn \@@_name_expand_cleanup:w #1 \tl_to_str:n { @@_name = } { }
%    \end{macrocode}
%   在非错误情况下，\cs{@@_name_expand_end:}不应该扩展。只有在文件名中存在\cs{csname}太多的情况下，它才会这样做，
%   因此它将引发错误（在扩展时），然后插入缺少的\cs{cs_end:}和另一个\cs{@@_name_expand_end:}，它将由\cs{@@_name_expand_cleanup:Nw}用作定界符
%   （或者如果还缺少\cs{endcsname}，它将再次扩展）。
%    \begin{macrocode}
\cs_new:Npn \@@_name_expand_end:
  {
    \msg_expandable_error:nn
      { kernel } { filename-missing-endcsname }
    \cs_end: \@@_name_expand_end:
  }
%    \end{macrocode}
%   现在到错误情况。 \cs{@@_name_expand_error:Nw}添加额外的\cs{cs_end:}，
%   以便在文件名中有额外的\tn{csname}时，\cs{@@_name_expand_error_aux:Nw}抛出错误。
%    \begin{macrocode}
\cs_new:Npn \@@_name_expand_error:Nw #1 #2 \@@_name_expand_end:
  { \@@_name_expand_error_aux:Nw #1 #2 \cs_end: \@@_name_expand_end: }
\cs_new:Npn \@@_name_expand_error_aux:Nw #1 #2 \cs_end: #3
    \@@_name_expand_end:
  {
    \msg_expandable_error:nnff
      { kernel } { filename-chars-lost }
        { \token_to_str:N #1 } { \exp_stop_f: #2 }
  }
%    \end{macrocode}
%   引用文件名基本上使用与\texttt{luaquotejobname}相同的方法：计算|"|标记并删除它们。
%    \begin{macrocode}
\cs_new:Npn \@@_name_strip_quotes:n #1
  {
    \@@_name_strip_quotes:nw { 0 }
      #1 " \q_@@_recursion_tail " \q_@@_recursion_stop {#1}
  }
\cs_new:Npn \@@_name_strip_quotes:nw #1#2 "
  {
    \if_meaning:w \q_@@_recursion_tail #2
      \@@_name_strip_quotes_end:wnwn
    \fi:
    #2
    \@@_name_strip_quotes:nw { #1 + 1 }
  }
\cs_new:Npn \@@_name_strip_quotes_end:wnwn \fi: #1
    \@@_name_strip_quotes:nw #2 \q_@@_recursion_stop #3
  {
    \fi:
    \int_if_odd:nT {#2}
      {
        \msg_expandable_error:nnn
          { kernel } { unbalanced-quote-in-filename } {#3}
      }
  }
%    \end{macrocode}
%   从名称的开始和任何扩展的结尾修剪空格。但是，我们传递的名称可能没有扩展：这意味着我们必须查找扩展名。
%   如果没有扩展名，我们仍然使用标准修剪函数，但有意阻止删除结尾的任何空格。
%    \begin{macrocode}
\cs_new:Npn \@@_name_trim_spaces:n #1
  { \@@_name_trim_spaces:nw {#1} #1 . \q_@@_nil . \s_@@_stop }
\cs_new:Npn \@@_name_trim_spaces:nw #1#2 . #3 . #4 \s_@@_stop
  {
    \@@_quark_if_nil:nTF {#3}
      {
        \tl_trim_spaces_apply:nN { #1 \s_@@_stop }
          \@@_name_trim_spaces_aux:n
      }
      { \tl_trim_spaces:n {#1} }
  }
\cs_new:Npn \@@_name_trim_spaces_aux:n #1
  { \@@_name_trim_spaces_aux:w #1 }
\cs_new:Npn \@@_name_trim_spaces_aux:w #1 \s_@@_stop {#1}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\__kernel_file_name_quote:n}
% \begin{macro}[EXP]{\@@_name_quote:nw}
%    \begin{macrocode}
\cs_new:Npn \__kernel_file_name_quote:n #1
  { \@@_name_quote:nw {#1} #1 ~ \q_@@_nil \s_@@_stop }
\cs_new:Npn \@@_name_quote:nw #1 #2 ~ #3 \s_@@_stop
  {
    \@@_quark_if_nil:nTF {#3}
      { #1 }
      { "#1" }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\c_@@_marker_tl}
%   与重新扫描标记token列表的标记相同：这一对token不能出现在被输入的文件中。
%    \begin{macrocode}
\tl_const:Ne \c_@@_marker_tl { : \token_to_str:N : }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[TF]{\file_get:nnN, \file_get:VnN}
% \begin{macro}{\file_get:nnN,\@@_get_aux:nnN,\@@_get_do:Nw}
%   这里的方法与\cs{tl_set_rescan:Nnn}类似。文件内容被抓取为由\cs{c_@@_marker_tl}定界的参数。
%   一些微妙之处：在\cs{if_false:} \ldots{} \cs{fi:}中使用花括号以处理可能的对齐制表符，
%   使用\tn{tracingnesting}避免有关在\tn{scantokens}内关闭组的警告，并且\cs{prg_return_true:}放置在文件末尾标记之后。
%    \begin{macrocode}
\cs_new_protected:Npn \file_get:nnN #1#2#3
  {
    \file_get:nnNF {#1} {#2} #3
      { \tl_set:Nn #3 { \q_no_value } }
  }
\cs_generate_variant:Nn \file_get:nnN { V }
\prg_new_protected_conditional:Npnn \file_get:nnN #1#2#3 { T , F , TF }
  {
    \file_get_full_name:nNTF {#1} \l_@@_full_name_tl
      {
        \exp_args:NV \@@_get_aux:nnN
          \l_@@_full_name_tl
          {#2} #3
        \prg_return_true:
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \file_get:nnN { V } { T , F , TF }
\cs_new_protected:Npe \@@_get_aux:nnN #1#2#3
  {
    \exp_not:N \if_false: { \exp_not:N \fi:
    \group_begin:
      \int_set_eq:NN \tex_tracingnesting:D \c_zero_int
      \exp_not:N \exp_args:No \tex_everyeof:D
        { \exp_not:N \c_@@_marker_tl }
      #2 \scan_stop:
      \exp_not:N \exp_after:wN \exp_not:N \@@_get_do:Nw
      \exp_not:N \exp_after:wN #3
      \exp_not:N \exp_after:wN \exp_not:N \prg_do_nothing:
      \exp_not:N \tex_input:D
      \sys_if_engine_luatex:TF
        { {#1} }
        { \exp_not:N \__kernel_file_name_quote:n {#1} \scan_stop: }
    \exp_not:N \if_false: } \exp_not:N \fi:
  }
\exp_args:Nno \use:nn
  { \cs_new_protected:Npn \@@_get_do:Nw #1#2 }
  { \c_@@_marker_tl }
  {
    \group_end:
    \tl_set:No #1 {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_size:n}
%   在原语可用的地方复制了原语。
%    \begin{macrocode}
\cs_new_eq:NN \@@_size:n \tex_filesize:D
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\file_full_name:n, \@@_full_name:n, \@@_full_name_aux:n}
% \begin{macro}[EXP]{\@@_full_name_auxi:nn, \@@_full_name_auxii:nn}
% \begin{macro}[EXP]{\@@_full_name_aux:Nnn}
% \begin{macro}[EXP]{\@@_full_name_slash:n}
% \begin{macro}[EXP]{\@@_full_name_slash:w}
% \begin{macro}[EXP]{\@@_full_name_aux:nN}
% \begin{macro}[EXP]{\@@_full_name_aux:nnN}
% \begin{macro}[EXP]{\@@_name_cleanup:w}
% \begin{macro}[EXP]{\@@_name_end:}
% \begin{macro}[EXP]{\@@_name_ext_check:nn}
% \begin{macro}[EXP]{\@@_name_ext_check:nnw}
% \begin{macro}[EXP]{\@@_name_ext_check:nnnw}
% \begin{macro}[EXP]{\@@_name_ext_check:nnn}
% \begin{macro}[EXP]{\@@_name_ext_check:nnnn}
%   如果\tn{pdffilesize}原语或等效物可用，可以执行文件搜索。
%   当然，这意味着我们需要安排这里的一切都通过扩展来完成。
%   我们首先通过清理名称并在需要时引用来准备一切：我们可能需要删除这些引号，因此原始名称也被传递。
%    \begin{macrocode}
\cs_new:Npn \file_full_name:n #1
  {
    \exp_args:Ne \@@_full_name:n
      { \__kernel_file_name_sanitize:n {#1} }
  }
\cs_generate_variant:Nn \file_full_name:n { V }
%    \end{macrocode}
%   首先，我们检查文件是否就在这里：没有映射，因此我们不需要较广泛的辅助部分的中断。
%   我们使用原语在文件完全不存在时返回空。为了避免不必要的文件系统查找，
%   \tn{pdffilesize}的结果作为参数保持可用。
%   对于包模式，\tn{input@path}是一个token list而不是一个sequence。
%    \begin{macrocode}
\cs_new:Npn \@@_full_name:n #1
  {
    \tl_if_blank:nF {#1}
      { \exp_args:Nne \@@_full_name_auxii:nn {#1} { \@@_full_name_aux:n {#1} } }
  }
%    \end{macrocode}
%   为了避免重复读取文件，我们需要缓存加载：这很重要，因为这里的代码被\emph{所有}文件检查使用。
%   在\LaTeXe{}内核中使用相同的标记，这意味着我们在\cs{IfFileExists}等地方获得了双重节省。
%   由于这一切都是关于性能的，我们对条件使用底层方法。
%   对于已经看到的文件，如果标记已被设置，将大小报告为$-1$，以便与任何非缓存的文件区分开。
%    \begin{macrocode}
\cs_new:Npn \@@_full_name_aux:n #1
  {
    \if_cs_exist:w @@_seen_ \tl_to_str:n {#1} : \cs_end:
      -1
    \else:
      \exp_args:Ne \@@_full_name_auxi:nn { \@@_size:n {#1} } {#1}
    \fi:
  }
%    \end{macrocode}
%   我们以后需要文件的大小，而且我们必须避免\cs{scan_stop:}在我们提高标志时引起问题。因此，这里有一点奇怪的吞噬。
%    \begin{macrocode}
\cs_new:Npn \@@_full_name_auxi:nn #1#2
  {
    \if:w \scan_stop: #1 \scan_stop:
    \else:
      \exp_after:wN \use_none:n
        \cs:w @@_seen_ \tl_to_str:n {#2} : \cs_end:
      #1
    \fi:
  }
\cs_new:Npn \@@_full_name_auxii:nn #1 #2
  {
    \tl_if_blank:nTF {#2}
      {
        \seq_map_tokens:Nn \l_file_search_path_seq
          { \@@_full_name_aux:Nnn \seq_map_break:n {#1} }
        \cs_if_exist:NT \input@path
          {
            \tl_map_tokens:Nn \input@path
              { \@@_full_name_aux:Nnn \tl_map_break:n {#1} }
          }
        \@@_name_end:
      }
      { \@@_ext_check:nn {#1} {#2} }
  }
%    \end{macrocode}
%   此处的辅助有两个部分，因此在我们找到正确的文件时可以避免两次引用。
%    \begin{macrocode}
\cs_new:Npn \@@_full_name_aux:Nnn #1#2#3
  {
    \exp_args:Ne \@@_full_name_aux:nN
      { \@@_full_name_slash:n {#3} #2 }
      #1
  }
\cs_new:Npn \@@_full_name_slash:n #1
  {
    \@@_full_name_slash:nw {#1} #1 \q_nil / \q_nil / \q_nil \q_stop
  }
\cs_new:Npn \@@_full_name_slash:nw #1#2 / \q_nil / #3 \q_stop
  {
    \quark_if_nil:nTF {#3}
      { #1 / }
      { #2 / }
  }
\cs_new:Npn \@@_full_name_aux:nN #1
  { \exp_args:Nne \@@_full_name_aux:nnN {#1} { \@@_full_name_aux:n {#1} } }
\cs_new:Npn \@@_full_name_aux:nnN #1 #2 #3
  {
    \tl_if_blank:nF {#2}
      {
        #3
          {
            \@@_ext_check:nn {#1} {#2}
            \@@_name_cleanup:w
          }
      }
  }
\cs_new:Npn \@@_name_cleanup:w #1 \@@_name_end: { }
\cs_new:Npn \@@_name_end: { }
%    \end{macrocode}
%   由于\TeX{}在没有扩展时会自动添加|.tex|，这里有一些清理工作要做。
%   首先，确保我们不在目录部分，保存该部分。然后检查是否有扩展。
%    \begin{macrocode}
\cs_new:Npn \@@_ext_check:nn #1 #2
{ \@@_ext_check:nnw {#2} { / } #1 / \q_@@_nil / \s_@@_stop }
\cs_new:Npn \@@_ext_check:nnw #1 #2 #3 / #4 / #5 \s_@@_stop
  {
    \@@_quark_if_nil:nTF {#4}
      {
        \exp_args:No \@@_ext_check:nnnw
          { \use_none:n #2 } {#1} {#3} #3 . \q_@@_nil . \s_@@_stop
      }
      { \@@_ext_check:nnw {#1} { #2 #3 / } #4 / #5 \s_@@_stop }
  }
\cs_new:Npe \@@_ext_check:nnnw #1#2#3#4 . #5 . #6 \s_@@_stop
  {
    \exp_not:N \@@_quark_if_nil:nTF {#5}
      {
        \exp_not:N \@@_ext_check:nnn
          { #1 #3 \tl_to_str:n { .tex } } { #1 #3 } {#2}
      }
      { #1 #3 }
  }
\cs_new:Npn \@@_ext_check:nnn #1
  { \exp_args:Nne \@@_ext_check:nnnn {#1} { \@@_full_name_aux:n {#1} } }
\cs_new:Npn \@@_ext_check:nnnn #1#2#3#4
  {
    \tl_if_blank:nTF {#2}
      {#3}
      {
        \bool_lazy_or:nnTF
          { \int_compare_p:nNn {#4} = {#2} }
          { \int_compare_p:nNn {#2} = { -1 } }
          {#1}
          {#3}
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\file_get_full_name:nN, \file_get_full_name:VN}
% \begin{macro}[TF]{\file_get_full_name:nN, \file_get_full_name:VN}
% \begin{macro}{\@@_get_full_name_search:nN}
%   这些函数在使用\cs{tex_filesize:D}进行文件搜索之前就已存在，
%   因此是带有保护的|get|函数。为了避免不同的搜索设置，
%   它们只是上面代码的简单封装。
%    \begin{macrocode}
\cs_new_protected:Npn \file_get_full_name:nN #1#2
  {
    \file_get_full_name:nNF {#1} #2
      { \tl_set:Nn #2 { \q_no_value } }
  }
\cs_generate_variant:Nn \file_get_full_name:nN { V }
\prg_new_protected_conditional:Npnn \file_get_full_name:nN #1#2 { T , F , TF }
  {
    \__kernel_tl_set:Ne #2
      { \file_full_name:n {#1} }
    \tl_if_empty:NTF #2
      { \prg_return_false: }
      { \prg_return_true: }
  }
\prg_generate_conditional_variant:Nnn \file_get_full_name:nN
  { V } { T , F ,  TF }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{variable}{\g_@@_internal_ior}
%   用于测试是否打开shell的保留流。
%    \begin{macrocode}
\ior_new:N \g_@@_internal_ior
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[rEXP]
%   {
%     \file_mdfive_hash:n, \file_mdfive_hash:V,
%     \file_size:n, \file_size:V,
%     \file_timestamp:n, \file_timestamp:V
%   }
% \begin{macro}[rEXP]{\@@_details:nn, \@@_details_aux:nn}
% \begin{macro}[rEXP]{\@@_mdfive_hash:n}
%   通过扩展获取文件详情相对容易，尽管有点重复。
%   由于MD5函数的语法与其他命令略有不同，需要进行一些清理。
%    \begin{macrocode}
\cs_new:Npn \file_size:n #1
  { \@@_details:nn {#1} { size } }
\cs_generate_variant:Nn \file_size:n { V }
\cs_new:Npn \file_timestamp:n #1
  { \@@_details:nn {#1} { moddate } }
\cs_generate_variant:Nn \file_timestamp:n { V }
\cs_new:Npn \@@_details:nn #1#2
  {
    \exp_args:Ne \@@_details_aux:nn
      { \file_full_name:n {#1} } {#2}
  }
\cs_new:Npn \@@_details_aux:nn #1#2
  {
    \tl_if_blank:nF {#1}
      { \use:c { tex_file #2 :D } {#1} }
  }
\cs_new:Npn \file_mdfive_hash:n #1
  { \exp_args:Ne \@@_mdfive_hash:n { \file_full_name:n {#1} } }
\cs_generate_variant:Nn \file_mdfive_hash:n { V }
\cs_new:Npn \@@_mdfive_hash:n #1
  { \tex_mdfivesum:D file {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[rEXP]{\file_hex_dump:nnn, \file_hex_dump:Vnn, \@@_hex_dump_auxi:nnn}
% \begin{macro}[rEXP]{\@@_hex_dump_auxii:nnnn, \@@_hex_dump_auxiii:nnnn}
% \begin{macro}[rEXP]{\@@_hex_dump_auxiiv:nnn}
% \begin{macro}[rEXP]{\file_hex_dump:n, \file_hex_dump:V, \@@_hex_dump:n}
%   这些函数需要多个参数\emph{或}文件大小，因此单独处理。
%   对于\LuaTeX{}，模拟不需要文件大小，因此我们在扩展上稍微节省了一些。
%    \begin{macrocode}
\cs_new:Npn \file_hex_dump:nnn #1#2#3
  {
    \exp_args:Neee \@@_hex_dump_auxi:nnn
      { \file_full_name:n {#1} }
      { \int_eval:n {#2} }
      { \int_eval:n {#3} }
  }
\cs_generate_variant:Nn \file_hex_dump:nnn { V }
\cs_new:Npn \@@_hex_dump_auxi:nnn #1#2#3
  {
    \bool_lazy_any:nF
      {
        { \tl_if_blank_p:n {#1} }
        { \int_compare_p:nNn {#2} = 0 }
        { \int_compare_p:nNn {#3} = 0 }
      }
      {
        \exp_args:Ne \@@_hex_dump_auxii:nnnn
          { \@@_details_aux:nn {#1} { size } }
          {#1} {#2} {#3}
      }
  }
\cs_new:Npn \@@_hex_dump_auxii:nnnn #1#2#3#4
  {
    \int_compare:nNnTF {#3} > 0
      { \@@_hex_dump_auxiii:nnnn {#3} }
      {
        \exp_args:Ne \@@_hex_dump_auxiii:nnnn
          { \int_eval:n { #1 + #3 } }
      }
        {#1} {#2} {#4}
  }
\cs_new:Npn \@@_hex_dump_auxiii:nnnn #1#2#3#4
  {
    \int_compare:nNnTF {#4} > 0
      { \@@_hex_dump_auxiv:nnn {#4} }
      {
        \exp_args:Ne \@@_hex_dump_auxiv:nnn
          { \int_eval:n { #2 + #4 } }
      }
        {#1} {#3}
  }
\cs_new:Npn \@@_hex_dump_auxiv:nnn #1#2#3
  {
    \tex_filedump:D
      offset ~ \int_eval:n { #2 - 1 } ~
      length ~ \int_eval:n { #1 - #2 + 1 }
      {#3}
  }
\cs_new:Npn \file_hex_dump:n #1
  { \exp_args:Ne \@@_hex_dump:n { \file_full_name:n {#1} } }
\cs_generate_variant:Nn \file_hex_dump:n { V }
\sys_if_engine_luatex:TF
  {
    \cs_new:Npn \@@_hex_dump:n #1
      {
        \tl_if_blank:nF {#1}
          { \tex_filedump:D whole {#1} {#1} }
      }
  }
  {
    \cs_new:Npn \@@_hex_dump:n #1
      {
        \tl_if_blank:nF {#1}
          { \tex_filedump:D length \tex_filesize:D {#1} {#1} }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[noTF]
%   {
%     \file_get_hex_dump:nN, \file_get_hex_dump:VN,
%     \file_get_mdfive_hash:nN, \file_get_mdfive_hash:VN,
%     \file_get_size:nN, \file_get_size:VN,
%     \file_get_timestamp:nN, \file_get_timestamp:VN
%   }
% \begin{macro}{\@@_get_details:nnN}
%   在适当的原始支持存在的情况下，对上述功能进行非可扩展封装。
%    \begin{macrocode}
\cs_new_protected:Npn \file_get_hex_dump:nN #1#2
  { \file_get_hex_dump:nNF {#1} #2 { \tl_set:Nn #2 { \q_no_value } } }
\cs_generate_variant:Nn \file_get_hex_dump:nN { V }
\cs_new_protected:Npn \file_get_mdfive_hash:nN #1#2
  { \file_get_mdfive_hash:nNF {#1} #2 { \tl_set:Nn #2 { \q_no_value } } }
\cs_generate_variant:Nn \file_get_mdfive_hash:nN { V }
\cs_new_protected:Npn \file_get_size:nN #1#2
  { \file_get_size:nNF {#1} #2 { \tl_set:Nn #2 { \q_no_value } } }
\cs_generate_variant:Nn \file_get_size:nN { V }
\cs_new_protected:Npn \file_get_timestamp:nN #1#2
  { \file_get_timestamp:nNF {#1} #2 { \tl_set:Nn #2 { \q_no_value } } }
\cs_generate_variant:Nn \file_get_timestamp:nN { V }
\prg_new_protected_conditional:Npnn \file_get_hex_dump:nN #1#2 { T , F , TF }
  { \@@_get_details:nnN {#1} { hex_dump } #2 }
\prg_generate_conditional_variant:Nnn \file_get_hex_dump:nN
  { V } { T , F , TF }
\prg_new_protected_conditional:Npnn \file_get_mdfive_hash:nN #1#2 { T , F , TF }
  { \@@_get_details:nnN {#1} { mdfive_hash } #2 }
\prg_generate_conditional_variant:Nnn \file_get_mdfive_hash:nN
  { V } { T , F , TF }
\prg_new_protected_conditional:Npnn \file_get_size:nN #1#2 { T , F , TF }
  { \@@_get_details:nnN {#1} { size } #2 }
\prg_generate_conditional_variant:Nnn \file_get_size:nN
  { V } { T , F , TF }
\prg_new_protected_conditional:Npnn \file_get_timestamp:nN #1#2 { T , F , TF }
  { \@@_get_details:nnN {#1} { timestamp } #2 }
\prg_generate_conditional_variant:Nnn \file_get_timestamp:nN
  { V } { T , F , TF }
\cs_new_protected:Npn \@@_get_details:nnN #1#2#3
  {
    \__kernel_tl_set:Ne #3
      { \use:c { file_ #2 :n } {#1} }
    \tl_if_empty:NTF #3
      { \prg_return_false: }
      { \prg_return_true: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[noTF]{\file_get_hex_dump:nnnN, \file_get_hex_dump:VnnN}
%   由于有额外的参数，所以是自定义代码。
%    \begin{macrocode}
\cs_new_protected:Npn \file_get_hex_dump:nnnN #1#2#3#4
  {
    \file_get_hex_dump:nnnNF {#1} {#2} {#3} #4
      { \tl_set:Nn #4 { \q_no_value } }
  }
\cs_generate_variant:Nn \file_get_hex_dump:nnnN { V }
\prg_new_protected_conditional:Npnn \file_get_hex_dump:nnnN #1#2#3#4
  { T , F , TF }
  {
    \__kernel_tl_set:Ne #4
      { \file_hex_dump:nnn {#1} {#2} {#3} }
    \tl_if_empty:NTF #4
      { \prg_return_false: }
      { \prg_return_true: }
  }
\prg_generate_conditional_variant:Nnn \file_get_hex_dump:nnnN
  { V } { T , F , TF }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_str_cmp:nn}
%   由于我们正在进行固定长度的“大”整数比较，最容易使用字符串比较的低级行为。
%    \begin{macrocode}
\cs_new_eq:NN \@@_str_cmp:nn \tex_strcmp:D
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP, pTF]
%   {
%     \file_compare_timestamp:nNn,
%     \file_compare_timestamp:nNV,
%     \file_compare_timestamp:VNn,
%     \file_compare_timestamp:VNV
%   }
% \begin{macro}[EXP]{\@@_compare_timestamp:nnN}
% \begin{macro}[EXP]{\@@_timestamp:n}
%   通过使用字符串比较函数的低级性质，可以进行文件日期的比较。
%    \begin{macrocode}
\prg_new_conditional:Npnn \file_compare_timestamp:nNn #1#2#3
  { p , T , F , TF }
  {
    \exp_args:Nee \@@_compare_timestamp:nnN
      { \file_full_name:n {#1} }
      { \file_full_name:n {#3} }
      #2
  }
\prg_generate_conditional_variant:Nnn \file_compare_timestamp:nNn
  { nNV , V , VNV } { p , T , F , TF }
\cs_new:Npn \@@_compare_timestamp:nnN #1#2#3
  {
    \tl_if_blank:nTF {#1}
      {
        \if_charcode:w #3 <
          \prg_return_true:
        \else:
          \prg_return_false:
        \fi:
      }
      {
        \tl_if_blank:nTF {#2}
          {
            \if_charcode:w #3 >
              \prg_return_true:
            \else:
              \prg_return_false:
            \fi:
          }
          {
            \if_int_compare:w
              \@@_str_cmp:nn
                { \@@_timestamp:n {#1} }
                { \@@_timestamp:n {#2} }
                #3 \c_zero_int
              \prg_return_true:
            \else:
              \prg_return_false:
            \fi:
          }
      }
  }
\cs_new_eq:NN \@@_timestamp:n \tex_filemoddate:D
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\file_if_exist:n, \file_if_exist:V}
%   这个文件存在性检测是对添加路径到文件函数的封装。如果找到文件，路径就包含了一些内容；而如果未找到文件，返回值就是空的。
%    \begin{macrocode}
\prg_new_conditional:Npnn \file_if_exist:n #1 { p , T , F , TF }
  {
    \tl_if_blank:eTF { \file_full_name:n {#1} }
      { \prg_return_false: }
      { \prg_return_true: }
  }
\prg_generate_conditional_variant:Nnn \file_if_exist:n { V } { p , T , F , TF }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \file_if_exist_input:n,
%     \file_if_exist_input:V,
%     \file_if_exist_input:nF,
%     \file_if_exist_input:VF
%   }
%   文件存在性测试的文件输入。我们没有定义|T|或|TF|变体，
%   因为放置\meta{true code}的最有用的地方在与其他条件不一致。
%    \begin{macrocode}
\cs_new_protected:Npn \file_if_exist_input:n #1
  {
    \file_get_full_name:nNT {#1} \l_@@_full_name_tl
      { \@@_input:V \l_@@_full_name_tl }
  }
\cs_generate_variant:Nn \file_if_exist_input:n { V }
\cs_new_protected:Npn \file_if_exist_input:nF #1#2
  {
    \file_get_full_name:nNTF {#1} \l_@@_full_name_tl
      { \@@_input:V \l_@@_full_name_tl }
      {#2}
  }
\cs_generate_variant:Nn \file_if_exist_input:nF { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\file_input_stop:}
%   简单的重命名。
%    \begin{macrocode}
\cs_new_protected:Npn \file_input_stop: { \tex_endinput:D }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\__kernel_file_missing:n}
%   丢失文件的错误消息，也用于\cs{ior_open:Nn}。
%    \begin{macrocode}
\cs_new_protected:Npn \__kernel_file_missing:n #1
  {
    \msg_error:nne { kernel } { file-not-found }
      { \__kernel_file_name_sanitize:n {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\file_input:n, \file_input:V}
% \begin{macro}{\@@_input:n, \@@_input:V}
% \begin{macro}{\@@_input_push:n, \__kernel_file_input_push:n}
% \begin{macro}{\@@_input_pop:, \__kernel_file_input_pop:}
% \begin{macro}{\@@_input_pop:nnn}
%   以安全的方式加载文件，首先检查文件是否存在，
%   只有在存在时才加载。将文件名推送到\cs{g_@@_stack_seq}，
%   并将其添加到文件列表，可以是\cs{g_@@_record_seq}，
%   也可以是在包模式下的\cs{@filelist}。
%    \begin{macrocode}
\cs_new_protected:Npn \file_input:n #1
  {
    \file_get_full_name:nNTF {#1} \l_@@_full_name_tl
      { \@@_input:V \l_@@_full_name_tl }
      { \__kernel_file_missing:n {#1} }
  }
\cs_generate_variant:Nn \file_input:n { V }
\cs_new_protected:Npe \@@_input:n #1
  {
    \exp_not:N \clist_if_exist:NTF \exp_not:N \@filelist
      { \exp_not:N \@addtofilelist {#1} }
      { \seq_gput_right:Nn \exp_not:N \g_@@_record_seq {#1} }
    \exp_not:N \@@_input_push:n {#1}
    \exp_not:N \tex_input:D
    \sys_if_engine_luatex:TF
      { {#1} }
      { \exp_not:N \__kernel_file_name_quote:n {#1} \scan_stop: }
    \exp_not:N \@@_input_pop:
  }
\cs_generate_variant:Nn \@@_input:n { V }
%    \end{macrocode}
%   跟踪文件数据很容易：我们存储了分离的部分，
%   这样就不需要两次解析它们。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_input_push:n #1
  {
    \seq_gpush:Ne \g_@@_stack_seq
      {
        { \g_file_curr_dir_str }
        { \g_file_curr_name_str }
        { \g_file_curr_ext_str }
      }
    \file_parse_full_name:nNNN {#1}
      \l_@@_dir_str \l_@@_name_str \l_@@_ext_str
    \str_gset_eq:NN \g_file_curr_dir_str  \l_@@_dir_str
    \str_gset_eq:NN \g_file_curr_name_str \l_@@_name_str
    \str_gset_eq:NN \g_file_curr_ext_str  \l_@@_ext_str
  }
\cs_new_eq:NN \__kernel_file_input_push:n \@@_input_push:n
\cs_new_protected:Npn \@@_input_pop:
  {
    \seq_gpop:NN \g_@@_stack_seq \l_@@_internal_tl
    \exp_after:wN \@@_input_pop:nnn \l_@@_internal_tl
  }
\cs_new_eq:NN \__kernel_file_input_pop: \@@_input_pop:
\cs_new_protected:Npn \@@_input_pop:nnn #1#2#3
  {
    \str_gset:Nn \g_file_curr_dir_str  {#1}
    \str_gset:Nn \g_file_curr_name_str {#2}
    \str_gset:Nn \g_file_curr_ext_str  {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\file_input_raw:n, \file_input_raw:V, \@@_input_raw:nn}
%   无错误检查，无跟踪。
%    \begin{macrocode}
\cs_new:Npn \file_input_raw:n #1
  { \exp_args:Ne \@@_input_raw:nn { \file_full_name:n {#1} } {#1} }
\cs_generate_variant:Nn \file_input_raw:n { V }
\cs_new:Npe \@@_input_raw:nn #1#2
  {
    \exp_not:N \tl_if_blank:nTF {#1}
      {
        \exp_not:N \exp_args:Nnne \exp_not:N \msg_expandable_error:nnn
          { kernel } { file-not-found }
          { \exp_not:N \__kernel_file_name_sanitize:n {#2} }
      }
      {
        \exp_not:N \tex_input:D
          \sys_if_engine_luatex:TF
            { {#1} }
            { \exp_not:N \__kernel_file_name_quote:n {#1} \scan_stop: }
        }
  }
\exp_args_generate:n { nne }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\file_parse_full_name:n, \file_parse_full_name:V}
% \begin{macro}{\file_parse_full_name_apply:nN, \file_parse_full_name_apply:VN}
%   主要解析宏 \cs{file_parse_full_name_apply:nN} 将文件名 |#1| 通过
%   \cs{__kernel_file_name_sanitize:n} 处理，使我们在内部以单一规范化
%   方式处理文件。
%   \cs{file_parse_full_name:n} 使用前者，并使用
%   \cs{prg_do_nothing:} 使每个名字部分保留在一对大括号中。
%    \begin{macrocode}
\cs_new:Npn \file_parse_full_name:n #1
  {
    \file_parse_full_name_apply:nN {#1}
      \prg_do_nothing:
  }
\cs_generate_variant:Nn \file_parse_full_name:n { V }
\cs_new:Npn \file_parse_full_name_apply:nN #1
  {
    \exp_args:Ne \@@_parse_full_name_auxi:nN
      { \__kernel_file_name_sanitize:n {#1} }
  }
\cs_generate_variant:Nn \file_parse_full_name_apply:nN { V }
%    \end{macrocode}
%
% \begin{macro}{\@@_parse_full_name_auxi:nN}
% \begin{macro}{\@@_parse_full_name_area:nw}
%   \cs{@@_parse_full_name_area:nw} 将文件名分成由 |/| 分隔的块，直到
%   达到最后一个块。最后一个块是文件名加上扩展名，而在那之前的所有内容
%   都是路径。当 \cs{@@_parse_full_name_area:nw} 完成时，它在扫描标记
%   \cs{s_@@_stop} 之后将路径保留在大括号中，并继续解析实际的文件名。
%    \begin{macrocode}
\cs_new:Npn \@@_parse_full_name_auxi:nN #1
  {
    \@@_parse_full_name_area:nw { } #1
      / \s_@@_stop
  }
\cs_new:Npn \@@_parse_full_name_area:nw #1 #2 / #3 \s_@@_stop
  {
    \tl_if_empty:nTF {#3}
      { \@@_parse_full_name_base:nw { } #2 . \s_@@_stop {#1} }
      { \@@_parse_full_name_area:nw { #1 / #2 } #3 \s_@@_stop }
  }
%    \end{macrocode}
%
% \begin{macro}{\@@_parse_full_name_base:nw}
%   \cs{@@_parse_full_name_base:nw} 做的事情与上面大致相同，但它
%   在每个句点处分隔块。然而，这里有一些额外的复杂性：如果 |#1| 为空，
%   则假定扩展名实际上为空，并且文件名为 |#2|。此外，必须在 |#2| 中
%   添加一个额外的 |.|，因为它稍后将在 \cs{@@_parse_full_name_tidy:nnnN}
%   中删除。无论如何，如果有扩展名，它将以前导 |.| 返回。
%    \begin{macrocode}
\cs_new:Npn \@@_parse_full_name_base:nw #1 #2 . #3 \s_@@_stop
  {
    \tl_if_empty:nTF {#3}
      {
        \tl_if_empty:nTF {#1}
          {
            \tl_if_empty:nTF {#2}
              { \@@_parse_full_name_tidy:nnnN { } { } }
              { \@@_parse_full_name_tidy:nnnN { .#2 } { } }
          }
          { \@@_parse_full_name_tidy:nnnN {#1} { .#2 } }
      }
      { \@@_parse_full_name_base:nw { #1 . #2 } #3 \s_@@_stop }
  }
%    \end{macrocode}
%
% \begin{macro}{\@@_parse_full_name_tidy:nnnN}
%   现在我们只需要清理一些在前面放开的位。上述两个宏中使用的循环在文件
%   路径和名称的开头都有一个前导 |/| 和 |.|，因此这里我们需要去除它们，
%   除非它是单独的 |/|，在这种情况下它保留原样。全部完成后，传递给 |#4|。
%    \begin{macrocode}
\cs_new:Npn \@@_parse_full_name_tidy:nnnN #1 #2 #3 #4
  {
    \exp_args:Nee #4
      {
        \str_if_eq:nnF {#3} { / } { \use_none:n }
        #3 \prg_do_nothing:
      }
      { \use_none:n #1 \prg_do_nothing: }
      {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\file_parse_full_name:nNNN, \file_parse_full_name:VNNN}
%    \begin{macrocode}
\cs_new_protected:Npn \file_parse_full_name:nNNN #1 #2 #3 #4
  {
    \file_parse_full_name_apply:nN {#1}
      \@@_full_name_assign:nnnNNN #2 #3 #4
  }
\cs_new_protected:Npn \@@_full_name_assign:nnnNNN #1 #2 #3 #4 #5 #6
  {
    \str_set:Nn #4 {#1}
    \str_set:Nn #5 {#2}
    \str_set:Nn #6 {#3}
  }
\cs_generate_variant:Nn \file_parse_full_name:nNNN { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\file_show_list:, \file_log_list:, \@@_list:N}
% \begin{macro}[EXP]{\@@_list_aux:n}
%   列出所有使用的文件到日志，去除重复。
%   在包模式下，如果\cs{@filelist}仍然定义，需要将文件名列表\cs{@filelist}
%   考虑在内（我们在\cs{AtBeginDocument}中捕获它到\cs{g_@@_record_seq}），
%   转换为字符串（这不影响逗号列表的逗号）。
%    \begin{macrocode}
\cs_new_protected:Npn \file_show_list: { \@@_list:N \msg_show:nneeee }
\cs_new_protected:Npn \file_log_list: { \@@_list:N \msg_log:nneeee }
\cs_new_protected:Npn \@@_list:N #1
  {
    \seq_clear:N \l_@@_tmp_seq
    \clist_if_exist:NT \@filelist
      {
        \exp_args:NNe \seq_set_from_clist:Nn \l_@@_tmp_seq
          { \tl_to_str:N \@filelist }
      }
    \seq_concat:NNN \l_@@_tmp_seq \l_@@_tmp_seq \g_@@_record_seq
    \seq_remove_duplicates:N \l_@@_tmp_seq
    #1 { kernel } { file-list }
      { \seq_map_function:NN \l_@@_tmp_seq \@@_list_aux:n }
        { } { } { }
  }
\cs_new:Npn \@@_list_aux:n #1 { \iow_newline: #1 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% 在作为包时，需要在这里保存标准文件列表和新列表。记录在
% \cs{@filelist}中的文件名在添加到\cs{g_@@_record_seq}之前必须转换为字符串。
%    \begin{macrocode}
\cs_if_exist:NT \@filelist
  {
    \AtBeginDocument
      {
        \exp_args:NNe \seq_set_from_clist:Nn \l_@@_tmp_seq
          { \tl_to_str:N \@filelist }
        \seq_gconcat:NNN
          \g_@@_record_seq
          \g_@@_record_seq
          \l_@@_tmp_seq
      }
  }
%    \end{macrocode}
%
% \subsection{GetIdInfo}
%
% \begin{macro}{\GetIdInfo}
% \begin{macro}{\@@_id_info_auxi:w, \@@_id_info_auxii:w, \@@_id_info_auxiii:w}
%   此函数从\textsc{svn} \texttt{Id}行中提取文件名等信息，如
%   \pkg{expl3.dtx}中所述。这曾经是我们在所有模块中获取版本号等信息的方式，
%   因此它必须在\pkg{l3bootstrap}中定义。现在在我们设置了很多工具之后，
%   定义它更方便，\pkg{l3file}似乎是最合理的地方。
%
%   这里的想法是从标准的\textsc{svn} \texttt{Id}行中提取出所需的信息，
%   但要避免在检入文件时会更改的行。因此，这些行中没有包含同时包含
%   美元符号和\texttt{Id}关键字的行的原因！
%    \begin{macrocode}
\cs_new_protected:Npn \GetIdInfo
  {
    \tl_clear_new:N \ExplFileDescription
    \tl_clear_new:N \ExplFileDate
    \tl_clear_new:N \ExplFileName
    \tl_clear_new:N \ExplFileExtension
    \tl_clear_new:N \ExplFileVersion
    \group_begin:
    \char_set_catcode_space:n { 32 }
    \exp_after:wN
    \group_end:
    \@@_id_info_auxi:w
  }
%    \end{macrocode}
%   首先检查\textsc{svn}字段是否完全为空。如果不是这种情况，
%   还有一种情况，即使用\texttt{svn cp}创建但尚未检入的文件。这会留下
%   一个特殊的标记\texttt{-1}版本，它没有进一步的数据。正确处理这一点是使用
%   \cs{@@_id_info_auxii:w}的原因，在行中使用空格。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_id_info_auxi:w $ #1 $ #2
  {
    \tl_set:Nn \ExplFileDescription {#2}
    \str_if_eq:nnTF {#1} { Id }
      {
        \tl_set:Nn \ExplFileDate { 0000/00/00 }
        \tl_set:Nn \ExplFileName { [unknown] }
        \tl_set:Nn \ExplFileExtension { [unknown~extension] }
        \tl_set:Nn \ExplFileVersion {-1}
      }
      { \@@_id_info_auxii:w #1 ~ \s_@@_stop }
  }
%    \end{macrocode}
%   在这里，|#1|是|Id|，|#2|是文件名，|#3|是扩展名，|#4|是版本，
%   |#5|是检入日期，|#6|是检入时间和用户，加上一些尾随空格。如果|#4|是标记
%   |-1|值，那么|#5|和|#6|都是空的。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_id_info_auxii:w
    #1 ~ #2.#3 ~ #4 ~ #5 ~ #6 \s_@@_stop
  {
    \tl_set:Nn \ExplFileName {#2}
    \tl_set:Nn \ExplFileExtension {#3}
    \tl_set:Nn \ExplFileVersion {#4}
    \str_if_eq:nnTF {#4} {-1}
      { \tl_set:Nn \ExplFileDate { 0000/00/00 } }
      { \@@_id_info_auxiii:w #5 - 0 - 0 - \s_@@_stop }
  }
%    \end{macrocode}
%   将\textsc{svn}风格的日期转换为\LaTeX{}风格的日期。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_id_info_auxiii:w #1 - #2 - #3 - #4 \s_@@_stop
  { \tl_set:Nn \ExplFileDate { #1/#2/#3 } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{检查内核依赖版本}
%
% \begin{macro}{\__kernel_dependency_version_check:Nn}
% \begin{macro}{\__kernel_dependency_version_check:nn}
% \begin{macro}{\@@_kernel_dependency_compare:nnn,\@@_parse_version:w}
%   此函数负责检查 \LaTeX3 内核的依赖关系是否与 \LaTeXe 内核中预加载的版本匹配。
%   如果版本不匹配，该函数尝试通过搜索可能的格式文件来解释原因。
%
%   该函数首先检查内核日期是否定义，如果未定义，则使用零强制错误路线。
%   然后将内核日期与请求的日期进行比较（通常是依赖项的打包日期）。
%   如果内核日期小于所需日期，则是一个错误，加载应该中止。
%    \begin{macrocode}
\cs_new_protected:Npn \__kernel_dependency_version_check:Nn #1
  { \exp_args:NV \__kernel_dependency_version_check:nn #1 }
\cs_new_protected:Npn \__kernel_dependency_version_check:nn #1
  {
    \cs_if_exist:NTF \c__kernel_expl_date_tl
      {
        \exp_args:NV \@@_kernel_dependency_compare:nnn
          \c__kernel_expl_date_tl {#1}
      }
      { \@@_kernel_dependency_compare:nnn { 0000-00-00 } {#1} }
  }
\cs_new_protected:Npn \@@_kernel_dependency_compare:nnn #1 #2 #3
  {
    \int_compare:nNnT
        { \@@_parse_version:w #1 \s_@@_stop } <
        { \@@_parse_version:w #2 \s_@@_stop }
      { \@@_mismatched_dependency_error:nn {#2} {#3} }
  }
\cs_new:Npn \@@_parse_version:w #1 - #2 - #3 \s_@@_stop {#1#2#3}
%    \end{macrocode}
%
% \begin{macro}{\@@_mismatched_dependency_error:nn}
%   如果版本不同，则尝试为用户提供一些指导。此函数首先取得引擎名称\cs{c_sys_engine_str}，
%   并将|tex|替换为|latex|，然后构建如下形式的命令：
%   \begin{texttt}
%   kpsewhich --all --engine=\meta{engine} \meta{format}[-dev].fmt
%   \end{texttt}
%   以查询可用的格式文件。打开一个shell，并将每行读入一个序列。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_mismatched_dependency_error:nn #1 #2
  {
    \exp_args:NNe \ior_shell_open:Nn \g_@@_internal_ior
      {
        kpsewhich ~ --all ~
          --engine = \c_sys_engine_exec_str
          \c_space_tl \c_sys_engine_format_str
            \bool_lazy_and:nnT
                { \tl_if_exist_p:N \development@branch@name }
                { ! \tl_if_empty_p:N \development@branch@name }
              { -dev } .fmt
      }
    \seq_clear:N \l_@@_tmp_seq
    \ior_map_inline:Nn \g_@@_internal_ior
      { \seq_put_right:Nn \l_@@_tmp_seq {##1} }
    \ior_close:N \g_@@_internal_ior
    \msg_error:nnnn { kernel } { mismatched-support-file }
      {#1} {#2}
%    \end{macrocode}
%   最后，结束当前文件。
%    \begin{macrocode}
    \tex_endinput:D
  }
%    \end{macrocode}
%
%   现在定义实际的错误消息：
%    \begin{macrocode}
\msg_new:nnnn { kernel } { mismatched-support-file }
  {
    Mismatched~LaTeX~support~files~detected. \\
    Loading~'#2'~aborted!
%    \end{macrocode}
%   \cs{c__kernel_expl_date_tl}可能不存在，因为是较旧的格式，
%   所以只有在存在标记的令牌列表时才打印日期：
%    \begin{macrocode}
    \tl_if_exist:NT \c__kernel_expl_date_tl
      {
        \\ \\
        The~L3~programming~layer~in~the~LaTeX~format \\
        is~dated~\c__kernel_expl_date_tl,~but~in~your~TeX~
        tree~the~files~require \\ at~least~#1.
      }
  }
  {
%    \end{macrocode}
%   包含格式文件的序列应该恰好有一项：当前运行的格式文件。如果是这种情况，
%   则错误的原因不是这个，因此打印一些可能原因的通用帮助。
%   如果找到多个格式文件，则将列表打印给用户，指示系统中有什么，
%   用户树中有什么。
%    \begin{macrocode}
    \int_compare:nNnTF { \seq_count:N \l_@@_tmp_seq } > 1
      {
        The~cause~seems~to~be~an~old~format~file~in~the~user~tree. \\
        LaTeX~found~these~files:
        \seq_map_tokens:Nn \l_@@_tmp_seq { \\~-~\use:n } \\
        Try~deleting~the~file~in~the~user~tree~then~run~LaTeX~again.
      }
      {
        The~most~likely~causes~are:
        \\~-~A~recent~format~generation~failed;
        \\~-~A~stray~format~file~in~the~user~tree~which~needs~
             to~be~removed~or~rebuilt;
        \\~-~You~are~running~a~manually~installed~version~of~#2 \\
        \ \ \ which~is~incompatible~with~the~version~in~LaTeX. \\
      }
    \\
    LaTeX~will~abort~loading~the~incompatible~support~files~
    but~this~may~lead~to \\ later~errors.~Please~ensure~that~
    your~LaTeX~format~is~correctly~regenerated.
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{消息}
%
%    \begin{macrocode}
\msg_new:nnnn { kernel } { file-not-found }
  { File~'#1'~not~found. }
  {
    The~requested~file~could~not~be~found~in~the~current~directory,~
    in~the~TeX~search~path~or~in~the~LaTeX~search~path.
  }
\msg_new:nnn { kernel } { file-list }
  {
    >~File~List~<
    #1 \\
    .............
  }
\msg_new:nnnn { kernel } { filename-chars-lost }
  { #1~invalid~in~file~name.~Lost:~#2. }
  {
    There~was~an~invalid~token~in~the~file~name~that~caused~
    the~characters~following~it~to~be~lost.
  }
\msg_new:nnnn { kernel } { filename-missing-endcsname }
  { Missing~\iow_char:N\\endcsname~inserted~in~filename. }
  {
    The~file~name~had~more~\iow_char:N\\csname~commands~than~
    \iow_char:N\\endcsname~ones.~LaTeX~will~add~the~missing~
    \iow_char:N\\endcsname~and~try~to~continue~as~best~as~it~can.
  }
\msg_new:nnnn { kernel } { unbalanced-quote-in-filename }
  { Unbalanced~quotes~in~file~name~'#1'. }
  {
    File~names~must~contain~balanced~numbers~of~quotes~(").
  }
\msg_new:nnnn { kernel } { iow-indent }
  { Only~#1 allows~#2 }
  {
    The~command~#2 can~only~be~used~in~messages~
    which~will~be~wrapped~using~#1.
    \tl_if_empty:nF {#3} { ~ It~was~called~with~argument~'#3'. }
  }
%    \end{macrocode}
%
% \subsection{从先前模块延迟的函数}
%
%<@@=sys>
%
% \begin{variable}{\c_sys_platform_str}
%   在\LuaTeX{}上检测平台很容易：对于其他引擎，我们使用两种常见情况
%   的特殊空文件。虽然可以进一步探测（参见\pkg{platform}宏包），
%   但这需要shell escape，并且似乎不太可能有用。在这里设置，
%   因为它需要文件搜索。
%    \begin{macrocode}
\sys_if_engine_luatex:TF
  {
    \str_const:Ne \c_sys_platform_str
      { \tex_directlua:D { tex.print(os.type) } }
  }
  {
    \file_if_exist:nTF { nul: }
      {
        \file_if_exist:nF { /dev/null }
          { \str_const:Nn \c_sys_platform_str { windows } }
      }
      {
        \file_if_exist:nT { /dev/null }
          { \str_const:Nn \c_sys_platform_str { unix } }
      }
  }
\cs_if_exist:NF \c_sys_platform_str
  { \str_const:Nn \c_sys_platform_str { unknown }  }
%    \end{macrocode}
% \end{variable}
% \begin{macro}[pTF]{\sys_if_platform_unix:}
% \begin{macro}[pTF]{\sys_if_platform_windows:}
%   现在我们可以设置测试。
%    \begin{macrocode}
\clist_map_inline:nn { unix , windows }
  {
    \@@_const:nn { sys_if_platform_ #1 }
      { \str_if_eq_p:Vn \c_sys_platform_str { #1 } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
