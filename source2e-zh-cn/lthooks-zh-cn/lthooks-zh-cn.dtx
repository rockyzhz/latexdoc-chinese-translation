% \iffalse meta-comment
%
% Copyright (C) 2020-2023
%       Frank Mittelbach, Phelype Oleinik, The LaTeX Project
%
% This file is part of the LaTeX base system.
% -------------------------------------------
%
% It may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3c
% of this license or (at your option) any later version.
% The latest version of this license is in
%    https://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX
% version 2008 or later.
%
% This file has the LPPL maintenance status "maintained".
%
% The list of all files belonging to the LaTeX base distribution is
% given in the file `manifest.txt'. See also `legal.txt' for additional
% information.
%
% The list of derived (unpacked) files belonging to the distribution
% and covered by LPPL is defined by the unpacking scripts (with
% extension .ins) which are part of the distribution.
%
% \fi
%
% \iffalse
%
%%% From File: lthooks.dtx
%
%    \begin{macrocode}
\def\lthooksversion{v1.1f}
\def\lthooksdate{2023/10/02}
%    \end{macrocode}
%
%<*driver>
\documentclass{l3doc}

% ^^A =================== 中文版特别设置 =========================
\usepackage[fontset=source]{ctex}
\ctexset{contentsname={\hfil 目\quad 录\hfil}}
\usepackage{multicol}
\usepackage{xcolor}
\definecolor{spot}{HTML}{003399}
\definecolor{code}{HTML}{a25e26}
\definecolor{verb}{HTML}{007f00}
\let\OriginalMF\MacroFont
\def\MacroFont{\color{spot}\OriginalMF}
\makeatletter
\pretocmd{\macrocode}{\def\macro@font{\color{code}\OriginalMF}\def\MacroFont{\color{code}\OriginalMF}}{}{}
\makeatother
\AtBeginEnvironment{quote}{\color{verb}}
\AtBeginEnvironment{flushleft}{\color{verb}}
\AtBeginEnvironment{verbatim}{\color{verb}}
\ExplSyntaxOn
\pretocmd{\__codedoc_typeset_functions:}{\color{spot}\arrayrulecolor{spot}}{}{}
% ^^A \apptocmd{\__codedoc_function_typeset_start:}{ \allowbreak}{}{}
^^A \pretocmd{\__codedoc_function_descr_start:w}{\allowbreak}{}{}
\ExplSyntaxOff
\hypersetup{%
  colorlinks=true,
  linkcolor=spot,
  urlcolor=spot,
  citecolor=spot,
  bookmarksopen=false,
  bookmarksnumbered=false,
  plainpages=false}
\IndexPrologue
  {
    \section*{索引}
    \markboth{索引}{索引}
    \addcontentsline{toc}{section}{索引}
    斜体数字指向相应条目描述的页面，
    下划线数字指向定义的代码行，
    其它的都指向使用条目的页面。
  }
\makeatletter
\def\glossary@prologue{\section*{{修订记录}}%
                 \markboth{{修订记录}}{{修订记录}}%
                 \addcontentsline{toc}{section}{修订记录}}
\ExplSyntaxOn
\pretocmd{\__codedoc_typeset_functions:}{\color{spot}\arrayrulecolor{spot}}{}{}
\patchcmd{\__codedoc_typeset_aux:n}{\color[gray]{0.5}}{\color{spot}}{}{}
\cs_set_protected:Npn \__codedoc_print_end_definition:
  {
    \seq_set_map:NNn \l__codedoc_tmpa_seq
      \g__codedoc_nested_names_seq
      { \__codedoc_macro_end_wrap_item:n {##1} }
      %%
    \int_compare:nTF { \seq_count:N \l__codedoc_tmpa_seq <= 3 }
      {
        \seq_use:Nnnn \l__codedoc_tmpa_seq
          { \,~和~ } { \,,~ } { \,,~和~ }
      }
      { \seq_item:Nn \l__codedoc_tmpa_seq {1}\,~以及其它的 }
    \@ 定义结束。
    \__codedoc_print_documented:
  }
\cs_set_protected:Npn \__codedoc_print_documented:
  {
    \seq_gset_filter:NNn \g__codedoc_nested_names_seq
      \g__codedoc_nested_names_seq
      {
        ! \bool_lazy_any_p:n
          {
            { \__codedoc_if_macro_internal_p:n {##1} }
            { \l__codedoc_macro_deprecated_bool }
            { \l__codedoc_macro_nodoc_bool }
          }
      }
    \seq_if_empty:NF \g__codedoc_nested_names_seq
      {
        \int_set:Nn \l__codedoc_tmpa_int
          { \seq_count:N \g__codedoc_nested_names_seq }
        \int_compare:nNnTF \l__codedoc_tmpa_int = 1 {这个} {这些}
        \bool_if:NTF \l__codedoc_macro_var_bool {变量} {函数}
        \int_compare:nNnTF \l__codedoc_tmpa_int = 1 {} {}
        被记录在第
        \__codedoc_get_hyper_target:eN
          { \seq_item:Nn \g__codedoc_nested_names_seq { 1 } }
          \l__codedoc_tmpa_tl
        \exp_args:Ne \pageref { \l__codedoc_tmpa_tl } 页。
      }
    \seq_gclear:N \g__codedoc_nested_names_seq
  }
\cs_set_protected:Npn \__codedoc_special_index_module:nnnnN #1#2#3#4#5
  {
    \use:e
      {
        \exp_not:n { \__codedoc_special_index_aux:nnnnnn {#1} {#2} }
          \tl_if_empty:nTF {#3}
            { { } { } { } }
            {
              \str_if_eq:nnTF {#3} { TeX }
                {
                  { TeX~和~LaTeX2e }
                  { \string\TeX{}~和~\string\LaTeXe{} }
                }
                {
                  {#3}
                  { \string\pkg{#3} }
                }
              { \bool_if:NT #5 { ~内部 } ~命令： }
            }
      }
          {#4}
  }
\ExplSyntaxOff
\makeatother
% ^^A =================== 中文版设置结束 =========================

\providecommand\InternalDetectionOff{}
\providecommand\InternalDetectionOn{}

\EnableCrossrefs
\CodelineIndex
\begin{document}
  \DocInput{lthooks-zh-cn.dtx}
\end{document}
%</driver>
%
% \fi
%
%
% \providecommand\hook[1]{\texttt{#1}}
%
% \providecommand\fmi[1]{\marginpar{\footnotesize FMi: #1}}
% \providecommand\fmiinline[1]{\begin{quote}\itshape\footnotesize FMi: #1\end{quote}}
% \providecommand\pho[1]{\marginpar{\footnotesize PhO: #1}}
% \providecommand\phoinline[1]{\begin{quote}\itshape\footnotesize PhO: #1\end{quote}}
%
%
%
% \title{\huge\bfseries\color{spot}\LaTeX{} 的钩子管理\thanks{该模块版本号
%    \lthooksversion\ 日期为 \lthooksdate, \copyright\ \LaTeX\
%    项目版权所有。}}
%
% \author{
%  \begin{tabular}{c@{\hspace{1em}}l}
%    Frank Mittelbach\thanks{Phelype Oleinik做了代码改进以使速度更快以及其它好处。}
%    & 【著】\\
%    张泓知 & 【译】
%  \end{tabular}}
%
% \maketitle
%
%
% \tableofcontents
%
%
% \begin{documentation}
%
% \section{介绍}
%
% 钩子（Hooks）是命令或环境代码中的处理点，在这些点上可以添加处理代码到
% 现有命令中。不同的包可以对同一命令进行处理，为了确保安全处理，
% 需要将不同包添加的代码块按合适的顺序进行排序。
%
% 包通过 \cs{AddToHook} 添加代码块，并使用默认的包名作为标签对其进行标记。
%
% 在 \verb=\begin{document}= 处，所有钩子的代码根据一些规则
% （由 \cs{DeclareHookRule} 给出）进行排序，以实现快速执行，
% 避免额外的处理开销。如果后续修改了钩子代码（或更改了规则），
% 将生成新的用于快速处理的版本。
%
% 一些钩子已在文档的导言部分使用。如果在此时已经使用了钩子，
% 钩子将被准备（并排序）以便执行。
%
%
% \section{包作者接口}
%
% 钩子管理系统提供了一组 CamelCase 命令，用于传统的 \LaTeXe{} 包
% （以及必要时在文档导言部分使用），同时也提供了用于现代包的 \texttt{expl3}
% 命令，这些现代包使用了 \LaTeX{} 的 L3 编程层。在幕后，访问的是一组
% 单一的数据结构，使得来自两个世界的包可以共存并访问其他包中的钩子。
%
% \subsection{\LaTeXe\ 接口}
%
% \subsubsection{声明钩子}
%
% 除了少数例外，钩子必须在使用前声明。这些例外包括命令和环境的通用
% 钩子（在 \cs{begin} 和 \cs{end} 执行）以及加载文件时运行的钩子
% （参见第~\ref{sec:generic}节）。
%
% \begin{function}{\NewHook}
%   \begin{syntax}
%     \cs{NewHook} \Arg{hook}
%   \end{syntax}
%   创建一个新的 \meta{hook}。
%    如果这个钩子在一个包内声明，建议其名称总是结构化的，形式为：
%    \meta{package-name}\texttt{/}\meta{hook-name}。如果需要，
%    您可以通过添加更多的 \texttt{/} 部分来进一步细分名称。
%    如果钩子名称已经存在，将引发错误并且不会创建该钩子。
%
%    \meta{hook} 可以使用点语法指定为当前包的名称。
%    请参见第~\ref{sec:default-label}节。
% \end{function}
%
% \begin{function}{\NewReversedHook}
%   \begin{syntax}
%     \cs{NewReversedHook} \Arg{hook}
%   \end{syntax}
%   类似于 \cs{NewHook} 声明一个新的 \meta{hook}。
%   不同之处在于，该钩子的代码块默认按相反顺序排列（最后添加的先执行）。
%   钩子的任何规则都将在默认排序之后应用。
%   详细内容请参见第~\ref{sec:order} 和 \ref{sec:reversed-order} 节。
%
%   \meta{hook} 可以使用点语法指定为当前包的名称。
%   请参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\NewMirroredHookPair}
%   \begin{syntax}
%     \cs{NewMirroredHookPair} \Arg{hook-1} \Arg{hook-2}
%   \end{syntax}
%   是 \cs{NewHook}\Arg{hook-1}\cs{NewReversedHook}\Arg{hook-2} 的简写。
%
%   \meta{hook} 可以使用点语法指定为当前包的名称。
%   请参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\NewHookWithArguments}
%   \begin{syntax}
%     \cs{NewHookWithArguments} \Arg{hook} \Arg{number}
%   \end{syntax}
%   创建一个具有 \meta{number} 个参数的新 \meta{hook}，在其他方面与 \cs{NewHook} 完全相同。
%   第~\ref{sec:hook-args} 节详细解释了带参数的钩子。
%
%   \meta{hook} 可以使用点语法指定为当前包的名称。
%   请参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\NewReversedHookWithArguments}
%   \begin{syntax}
%     \cs{NewReversedHookWithArguments} \Arg{hook} \Arg{number}
%   \end{syntax}
%   类似于 \cs{NewReversedHook}，但创建的钩子的代码带有 \meta{number} 个参数。
%   第~\ref{sec:hook-args} 节详细解释了带参数的钩子。
%
%   \meta{hook} 可以使用点语法指定为当前包的名称。
%   请参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\NewMirroredHookPairWithArguments}
%   \begin{syntax}
%     \cs{NewMirroredHookPairWithArguments} \Arg{hook-1} \Arg{hook-2} \Arg{number}
%   \end{syntax}
%   是 \cs{NewHookWithArguments}\Arg{hook-1}\Arg{number}\\
%   \cs{NewReversedHookWithArguments}\Arg{hook-2}\Arg{number} 的简写。
%   第~\ref{sec:hook-args} 节详细解释了带参数的钩子。
%
%   \meta{hook} 可以使用点语法指定为当前包的名称。
%   请参见第~\ref{sec:default-label} 节。
% \end{function}
%
%
% \subsubsection{通用钩子的特殊声明}
%
% 此处的声明通常不应该被使用。它们提供了对主要涉及通用命令钩子的特殊用例的支持。
%
% \changes{v1.0p}{2021/08/20}{针对通用钩子命令的文档更新（gh/638）}
%
% \begin{function}{\DisableGenericHook}
%   \begin{syntax}
%     \cs{DisableGenericHook} \Arg{hook}
%   \end{syntax}
%    在此声明之后\footnotemark{}，\meta{hook} 将不再可用：
%    进一步尝试向其添加代码将导致错误，任何使用，例如 \cs{UseHook}，
%    都将什么也不做。
%
%    这主要用于通用命令钩子（参见 \texttt{ltcmdhooks-doc}），
%    因为根据命令的定义，这些通用钩子可能不可用。
%    如果已知此情况，包开发人员可以提前禁用这些钩子。
%
%    \meta{hook} 可以使用点语法指定为当前包的名称。
%    请参见第~\ref{sec:default-label} 节。
% \end{function}\footnotetext{在 2020/06 版本中，此命令称为 \cs{DisableHook}，
%    但该名称是误导性的，因为它不应用于禁用非通用钩子。}
%
%
% \begin{function}{\ActivateGenericHook}
%   \begin{syntax}
%     \cs{ActivateGenericHook} \Arg{hook}
%   \end{syntax}
% 此声明激活了包/类提供的通用钩子
% （例如，在使用 \cs{UseHook} 或 \cs{UseOneTimeHook} 代码中使用的钩子），
% 而无需显式使用 \cs{NewHook} 进行声明）。
% 此命令撤销了 \cs{DisableGenericHook} 的效果。
% 如果钩子已经被激活，此命令将不做任何操作。
%
% 请参见第~\ref{sec:generic-hooks} 节，了解何时使用此声明。
% \end{function}
%
%
%
%
%
% \subsubsection{在代码中使用钩子}
%
% \begin{function}{\UseHook}
%   \begin{syntax}
%     \cs{UseHook} \Arg{hook}
%   \end{syntax}
%    执行存储在 \meta{hook} 中的代码。
%
%    在 \verb=\begin{document}= 之前，并未设置钩子的快速执行代码，
%    因此在那里使用钩子时，需要显式地首先进行初始化。
%    由于这涉及到赋值，在这些时刻使用钩子并非与在 \verb=\begin{document}= 后完全相同。
%
%    无法使用点语法指定 \meta{hook}。
%    其前面的 |.| 将被视为文字字符。
% \end{function}
%
% \begin{function}{\UseHookWithArguments}
%   \begin{syntax}
%     \cs{UseHookWithArguments} \Arg{hook} \Arg{number} \Arg{arg_1} \ldots \Arg{arg_n}
%   \end{syntax}
%    执行存储在 \meta{hook} 中的代码，并将 \Arg{arg_1} 至 \Arg{arg_n} 参数传递给 \meta{hook}。
%    否则，其行为与 \cs{UseHook} 完全相同。
%    \meta{number} 应该是钩子声明的参数数量。
%    如果钩子未声明，此命令将不执行任何操作，并将从输入中删除 \meta{number} 个项目。
%    第~\ref{sec:hook-args} 节解释了带参数的钩子。
%
%    无法使用点语法指定 \meta{hook}。
%    其前面的 |.| 将被视为文字字符。
% \end{function}
%
% \begin{function}{\UseOneTimeHook}
%   \begin{syntax}
%     \cs{UseOneTimeHook} \Arg{hook}
%   \end{syntax}
%    一些钩子仅在一个地方使用（并且只能在一个地方使用），
%    例如，在 \verb=\begin{document}= 或 \verb=\end{document}= 中的钩子。
%    从那时起，通过已定义的 \cs[no-index]{\meta{addto-cmd}} 命令
%    （例如，\cs{AddToHook} 或 \cs{AtBeginDocument} 等）向钩子添加内容
%    将不起作用（就像在钩子代码内部使用这样的命令一样）。
%    因此，习惯上重新定义 \cs{\meta{addto-cmd}} 以简单地处理其参数，
%    即本质上使其行为类似于 \cs{@firstofone}。
%
%    \cs{UseOneTimeHook} 就是这样做的：它记录钩子已被消耗，
%    任何进一步尝试向其添加内容都将导致立即执行要添加的代码。
%
%    多次使用 \cs{UseOneTimeHook} 对同一个 \Arg{hook} 意味着
%    它只在第一次使用时执行。例如，如果它在可以被多次调用的命令中使用，
%    则该钩子仅在该命令的 \emph{第一次} 调用时执行；
%    这允许其用作“初始化钩子”。
%
%    应避免混合使用 \cs{UseHook} 和 \cs{UseOneTimeHook} 用于同一个 \Arg{hook}，
%    但如果这样做了，那么在第一次 \cs{UseOneTimeHook} 后，两者都不会再执行。
%
%    无法使用点语法指定 \meta{hook}。
%    其前面的 |.| 将被视为文字字符。详见
%    第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\UseOneTimeHookWithArguments}
%   \begin{syntax}
%     \cs{UseOneTimeHookWithArguments} \Arg{hook} \Arg{number} \Arg{arg_1} \ldots \Arg{arg_n}
%   \end{syntax}
%    与 \cs{UseOneTimeHook} 完全相同，但将参数 \Arg{arg_1} 至 \Arg{arg_n} 传递给 \meta{hook}。
%    \meta{number} 应该是钩子声明的参数数量。
%    如果钩子未声明，此命令将不执行任何操作，并将从输入中删除 \meta{number} 个项目。
%
%    应注意，一次性钩子使用后，将不再可能使用 \cs{AddToHookWithArguments} 或类似方法
%    添加内容到该钩子。 \cs{AddToHook} 仍然正常工作。
%    第~\ref{sec:hook-args} 节解释了带参数的钩子。
%
%    无法使用点语法指定 \meta{hook}。
%    其前面的 |.| 将被视为文字字符。详见
%    第~\ref{sec:default-label} 节。
% \end{function}
%
%
% \begin{function}{\AddToHook}
%   \begin{syntax}
%     \cs{AddToHook} \Arg{hook}\oarg{label}\Arg{code}
%   \end{syntax}
%    向标记为 \meta{label} 的 \meta{hook} 添加 \meta{code}。
%    当不提供可选参数 \meta{label} 时，将使用 \meta{默认标签}
%    （参见第~\ref{sec:default-label} 节）。
%    如果 \cs{AddToHook} 在包/类中使用，则 \meta{默认标签} 为包/类名，
%    否则为 \hook{top-level}（\hook{top-level} 标签处理方式不同：
%    详见第~\ref{sec:top-level} 节）。
%
%    如果 \meta{label} 下已存在代码，则新的 \meta{code} 将附加到现有代码中
%    （即使这是一个反向钩子）。如果要替换 \meta{label} 下的现有代码，
%    请先应用 \cs{RemoveFromHook}。
%
%    钩子不必存在即可向其添加代码。但是，如果未声明，
%    则显然添加的 \meta{code} 将永远不会执行。
%    这使得钩子能够在不考虑包装载顺序的情况下工作，
%    并使得包装可以从其他包装中向钩子添加内容，而无需担心它们实际上是否在当前文档中使用。
%    详见第~\ref{sec:querying} 节。
%
%    可以使用点语法指定 \meta{hook} 和 \meta{label}。
%    详见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\AddToHookWithArguments}
%   \begin{syntax}
%     \cs{AddToHookWithArguments} \Arg{hook}\oarg{label}\Arg{code}
%   \end{syntax}
%    与 \cs{AddToHook} 完全相同，但 \meta{code} 可以访问通过
%    \verb|#1|、\verb|#2|、\ldots、\verb|#n|（与钩子声明的参数数量相符）
%    传递给钩子的参数。如果 \meta{code} 中包含不希望被理解为钩子参数的
%    \emph{参数符号}（\verb|#|），则应将这些符号加倍。例如，使用 \cs{AddToHook}
%    可以写成：
%\begin{verbatim}
%   \AddToHook{myhook}{\def\foo#1{Hello, #1!}}
%\end{verbatim}
%    但是要使用 \cs{AddToHookWithArguments} 实现相同效果，应写成：
%\begin{verbatim}
%   \AddToHookWithArguments{myhook}{\def\foo##1{Hello, ##1!}}
%\end{verbatim}
%    因为在后一种情况中，\verb|#1| 指的是钩子 \hook{myhook} 的第一个参数。
%    第~\ref{sec:hook-args} 节解释了带参数的钩子。
%
%    可以使用点语法指定 \meta{hook} 和 \meta{label}。
%    详见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\RemoveFromHook}
%   \begin{syntax}
%     \cs{RemoveFromHook} \Arg{hook}\oarg{label}
%   \end{syntax}
% 从 \meta{hook} 中删除由 \meta{label} 标记的任何代码。
% 当不提供可选参数 \meta{label} 时，将使用 \meta{default label}
%（参见第~\ref{sec:default-label} 节）。
%
% 如果在 \meta{hook} 中不存在 \meta{label} 下的代码，
% 或者 \meta{hook} 不存在，则在尝试 \cs{RemoveFromHook} 时发出警告，
% 并忽略该命令。仅当您确切地了解钩子中有哪些标签时，
% 才应使用 \cs{RemoveFromHook}。通常情况下，
% 这将是当某个包将某些代码添加到钩子中时，
% 然后同一个包稍后删除此代码时。
% 如果您想阻止来自另一个包的代码执行，
% 则应使用 |voids| 规则（参见第~\ref{sec:rules} 节）。
%
% 如果可选的 \meta{label} 参数是 \texttt{*}，
% 则会删除所有代码块。这相当危险，因为它可能会删除其他包的代码
%（可能不为人所知）；因此，它不应在包中使用，而只应在文档导言中使用！
%
% 可以使用点符号语法指定 \meta{hook} 和 \meta{label}，
% 以表示当前包名称。参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \medskip
%
% 与 \cs{DeclareHookRule} 中两个标签之间的 |voids| 关系相比，
% 这是一种破坏性的操作，因为标记的代码已从钩子数据结构中删除，
% 而关系设置可以通过稍后提供不同的关系来撤消。
%
% 此声明在文档主体内的一个有用应用是当您想临时添加代码到钩子中，
% 然后稍后再次删除它时，例如，
%\begin{verbatim}
%   \AddToHook{env/quote/before}{\small}
%   \begin{quote}
%     A quote set in a smaller typeface
%   \end{quote}
%   ...
%   \RemoveFromHook{env/quote/before}
%   ... now back to normal for further quotes
%\end{verbatim}
% 请注意，您无法通过以下方式取消设置：
%\begin{verbatim}
%   \AddToHook{env/quote/before}{}
%\end{verbatim}
% 因为这只是“添加”了一个空的代码块到钩子中。添加 \cs{normalsize} 
% 是可行的，但这意味着钩子中包含了 \cs{small}\cs{normalsize}，
% 这意味着没有充分理由进行两次字体大小更改。
%
% 上述操作仅在想要以较小字体排版多个引用时才需要。如果钩子仅需要一次使用，
% 那么 \cs{AddToHookNext} 更简单，因为它在使用一次后会重置自身。
%
%
% \begin{function}{\AddToHookNext}
%   \begin{syntax}
%     \cs{AddToHookNext} \Arg{hook}\Arg{code}
%   \end{syntax}
%    向下一次 \meta{hook} 调用中添加 \meta{code}。
%    该代码在常规钩子代码执行完毕后执行，并且仅执行一次，即在使用后删除。
%
%    使用此声明是全局操作，即使声明在组内使用，
%    并且钩子的下一次调用发生在该组结束之后，代码也不会丢失。
%    如果在执行钩子之前多次使用声明，则所有代码将按照声明的顺序执行。\footnotemark
%
%    如果此声明与一次性钩子一起使用，
%    则仅当声明在钩子调用之前时才会使用代码。
%    这是因为与 \cs{AddToHook} 相比，
%    在钩子调用已经发生时，此声明中的代码不会立即执行——
%    换句话说，此代码仅在下一次钩子调用时真正执行
%    （对于一次性钩子，没有这样的“下一次调用”）。
%    这给您一个选择：我的代码应该始终执行，
%    还是仅在一次性钩子使用时执行（如果不可能则不执行）？
%    对于这两种可能性，都存在使用情况。
%
%    可以使用相同钩子（或不同钩子）嵌套此声明，例如，
%   \begin{quote}
%     \cs{AddToHookNext}\Arg{hook}\verb={=\meta{code-1}^^A
%     \cs{AddToHookNext}\Arg{hook}\Arg{code-2}\verb=}=
%   \end{quote}
%    将在下一次使用 \meta{hook} 时执行 \meta{code-1}，
%    并在那时将 \meta{code-2} 放入 \meta{hook} 中，
%    以便在下次运行钩子时执行它。
%
%    钩子不一定存在才能向其添加代码。
%    这使得钩子可以独立于包加载顺序工作。
%    参见第~\ref{sec:querying} 节。
%
%    可以使用点符号语法指定 \meta{hook}，
%    以表示当前包名称。参见第~\ref{sec:default-label} 节。
% \end{function}\footnotetext{没有重新排序此类代码块的机制（或删除它们）。}
%
% \begin{function}{\AddToHookNextWithArguments}
%   \begin{syntax}
%     \cs{AddToHookNextWithArguments} \Arg{hook}\Arg{code}
%   \end{syntax}
%    功能与 \cs{AddToHookNext} 完全相同，但 \meta{code} 可包含
%    对 \meta{hook} 参数的引用，正如上面对 \cs{AddToHookWithArguments} 的描述。
%    第~\ref{sec:hook-args} 节解释了带参数的钩子。
%
%    可以使用点符号语法指定 \meta{hook}，
%    以表示当前包名称。参见第~\ref{sec:default-label} 节。
% \end{function}
%
%
%
% \begin{function}{\ClearHookNext}
%   \begin{syntax}
%     \cs{ClearHookNext}\Arg{hook}
%   \end{syntax}
%    通常，仅当您准确知道它将应用在何处以及为何需要一些额外代码时，
%    才会使用 \cs{AddToHookNext}。然而，在某些情况下，
%    需要取消这种声明，例如，使用\hfil\break \cs{DiscardShipoutBox} 丢弃页面时
%    （但甚至在这种情况下也不总是如此），
%    在这种情况下可以使用 \cs{ClearHookNext}。
% \end{function}
%
%
%
%
%
% \subsubsection{钩子名称和默认标签}
% \label{sec:default-label}
%
% 在包或类中最好使用 \cs{AddToHook}，\emph{不指定 \meta{label}}，
% 因为这样可以自动使用包或类名称，如果需要规则，则会很有帮助，
% 并避免了输入错误的 \meta{label}。
%
% 仅在非常特定的情况下才需要使用显式的 \meta{label}，例如，
% 如果要将多个代码块添加到单个钩子中，并希望将它们放置在钩子的不同部分
% （通过提供一些规则）。
%
% 另一个情况是当您开发具有多个子包的大型包时。
% 在这种情况下，您可能希望在整个子包中使用相同的 \meta{label}，
% 以避免在内部重新组织代码时标签发生变化。
%
% 除了 \cs{UseHook}、\cs{UseOneTimeHook} 和 \cs{IfHookEmptyTF}
%（及其 \pkg{expl3} 接口 \cs{hook_use:n}、\cs{hook_use_once:n}
% 和 \cs{hook_if_empty:nTF}）之外，所有 \meta{hook} 和 \meta{label}
% 参数的处理方式相同：首先，对参数周围的空格进行修剪，
% 然后完全展开，直到只剩下字符记号。
% 如果 \meta{hook} 或 \meta{label} 的完全展开包含一个不可展开的非字符记号，
% 将引发低级 \TeX{} 错误（即，使用 \TeX{} 的 \cs{csname}\ldots\cs{endcsname}
% 展开 \meta{hook}，因此 \meta{hook} 和 \meta{label} 参数中允许使用 Unicode 字符）。
% \cs{UseHook}、\cs{UseOneTimeHook} 和 \cs{IfHookEmptyTF} 的参数处理方式基本相同，
% 只是不会修剪参数周围的空格，以获得更好的性能。
%
% 虽然不是强制要求，但强烈建议由包定义的钩子和用于向其他钩子添加代码的 \meta{label}，
% 包含包名称，以便轻松识别代码块的来源并防止冲突。
% 这应该是标准做法，因此此钩子管理代码提供了一个快捷方式，
% 用于在 \meta{hook} 名称和 \meta{label} 中引用当前包。
% 如果 \meta{hook} 名称或 \meta{label} 仅由一个单独的点（|.|）或以点开头，
% 后跟斜杠（|./|），则该点表示 \meta{default label}
%（通常是当前包或类名称——参见~\cs{SetDefaultHookLabel}）。
% \enquote{|.|} 或 \enquote{|./|} 在 \meta{hook} 或 \meta{label} 的任何其他位置都会被按原样处理，不会被替换。
%
% 例如，在名为 \texttt{mypackage.sty} 的包中，默认标签是 \texttt{mypackage}，
% 因此以下说明：
% \begin{verbatim}
%   \NewHook   {./hook}
%   \AddToHook {./hook}[.]{code}     % Same as \AddToHook{./hook}{code}
%   \AddToHook {./hook}[./sub]{code}
%   \DeclareHookRule{begindocument}{.}{before}{babel}
%   \AddToHook {file/foo.tex/after}{code}
% \end{verbatim}
%    等价于：
% \begin{verbatim}
%   \NewHook   {mypackage/hook}
%   \AddToHook {mypackage/hook}[mypackage]{code}
%   \AddToHook {mypackage/hook}[mypackage/sub]{code}
%   \DeclareHookRule{begindocument}{mypackage}{before}{babel}
%   \AddToHook {file/foo.tex/after}{code}                  % unchanged
% \end{verbatim}
%
% \meta{default label} 在包加载时自动设置为当前包或类的名称。
% 如果挂钩命令在包外使用，或者当前文件没有使用 \cs{usepackage} 或 \cs{documentclass} 加载，
% 那么将使用 \texttt{top-level} 作为 \meta{default label}。
% 这可能会有例外情况——参见 \cs{PushDefaultHookLabel}。
%
% 此语法适用于所有 \meta{label} 参数和大多数 \meta{hook} 参数，
% 无论是在 \LaTeXe{} 接口中，还是在第~\ref{sec:l3hook-interface} 节描述的
% \LaTeX3 接口中。
%
% 注意，\marginpar{\color{spot}\raggedleft\rightskip5pt\itshape \textbf{重要：}\break
% 点语法在 \cs{UseHook} 和一些通常在代码中使用的其他命令中\textbf{不可用}！}
% 但要注意，当执行挂钩命令时，|.| 被 \meta{default label} 替换，
% 因此在包结束后某种程度上执行的操作，如果使用了点语法，将会有错误的 \meta{default label}。
% 出于这个原因，这种语法在 \cs{UseHook}（和 \cs{hook_use:n}）中不可用，
% 因为大多数情况下，挂钩在定义它的包文件之外使用。
% 这种语法也不适用于挂钩条件语句 \cs{IfHookEmptyTF}（和 \cs{hook_if_empty:nTF}），
% 因为这些条件语句在挂钩管理代码的一些性能关键部分中使用，
% 并且通常用于引用其他包的挂钩，因此点语法并不太合适。
%
% 在某些情况下，例如在大型包中，可能希望将代码分离为逻辑部分，但仍然使用主包名称作为
% \meta{label}，那么可以使用 \cs{PushDefaultHookLabel}\verb={...}=\,\ldots\hfil\break \cs{PopDefaultHookLabel}
% 或 \cs{SetDefaultHookLabel}\verb={...}= 设置 \meta{default label}。
%
% \begin{function}{\PushDefaultHookLabel,\PopDefaultHookLabel}
%   \begin{syntax}
%     \cs{PushDefaultHookLabel} \Arg{default label}
%     \quad \meta{code}
%     \cs{PopDefaultHookLabel}
%   \end{syntax}
% \cs{PushDefaultHookLabel} 设置当前 \meta{default label} 以在 \meta{label} 参数或替换前导的“|.|”时使用。
% \cs{PopDefaultHookLabel} 将 \meta{default label} 恢复为其先前的值。
%
% 在包或类中，\meta{default label} 等于包或类名称，除非显式更改。
% 在其他任何地方，\meta{default label} 是 |top-level|（参见第~\ref{sec:top-level} 节），
% 除非显式更改。
%
% \cs{PushDefaultHookLabel} 的效果持续到下一个 \cs{PopDefaultHookLabel}。\hfil\break
% \cs{usepackage}（以及 \cs{RequirePackage} 和 \cs{documentclass}）内部使用
% \begin{quote}
%   \cs{PushDefaultHookLabel}\Arg{package name} \\
%   \null \quad  \meta{package code} \\
%   \cs{PopDefaultHookLabel}
% \end{quote}
% 来设置包或类文件的 \meta{default label}。
% 在 \meta{package code} 中，也可以使用\hfil\break \cs{SetDefaultHookLabel} 更改 \meta{default label}。
% \cs{input} 和其他从 \LaTeX{} 核心中输入文件的命令不使用 \cs{PushDefaultHookLabel}，
% 因此由这些命令加载的文件中的代码\emph{不}会获得专用的 \meta{label}！
% （也就是说，\meta{default label} 是加载文件时的当前活动标签。）
%
% 提供自己类似包的接口的包（例如 Ti\textit{k}Z 的 \cs{usetikzlibrary}）可以使用
% \cs{PushDefaultHookLabel} 和 \cs{PopDefaultHookLabel} 设置专用标签，并在这些上下文中模拟
% 类似 \cs{usepackage} 的挂钩行为。
%
% |top-level| 标签处理方式不同，并保留给用户文档，因此不允许将 \meta{default label} 更改为 |top-level|。
% \end{function}
%
% \begin{function}{\SetDefaultHookLabel}
%   \begin{syntax}
%     \cs{SetDefaultHookLabel} \Arg{default label}
%   \end{syntax}
% \cs{SetDefaultHookLabel} 与 \cs{PushDefaultHookLabel} 类似，
% 将当前 \meta{default label} 设置为在 \meta{label} 参数中使用，或替换前导的“|.|”时使用。
% 其效果持续到标签再次更改或到下一个 \cs{PopDefaultHookLabel}。
% \cs{PushDefaultHookLabel} 和 \cs{SetDefaultHookLabel} 的区别在于后者不保存当前 \meta{default label}。
%
% 当一个大型包由几个较小的包组成，但所有这些包都应具有相同的 \meta{label} 时，
% \cs{SetDefaultHookLabel} 可以在每个包文件的开头使用以设置正确的标签。
%
% 在主文档中不允许使用 \cs{SetDefaultHookLabel}，其中 \meta{default label} 是 |top-level|，
% 且没有 \cs{PopDefaultHookLabel} 来结束其效果。
% 同样不允许将 \meta{default label} 更改为 |top-level|。
% \end{function}
%
% \subsubsection{\texttt{top-level} 标签}
% \label{sec:top-level}
%
% 为从主文档中添加的代码分配的 |top-level| 标签与其他标签不同。
% 添加到导言区挂钩（通常是 \cs{AtBeginDocument}）的代码几乎总是用于更改包定义的内容，
% 因此应该放在挂钩的最末端。
%
% 因此，添加在 |top-level| 的代码始终在挂钩的末尾执行，无论它在何处声明。
% 如果挂钩被反转（参见 \cs{NewReversedHook}），则 |top-level| 代码块将在最开始执行。
%
% 关于 |top-level| 的规则不起作用：如果用户想为代码块设置特定规则，
% 应该为该代码块使用不同的标签，并为该标签提供规则。
%
% |top-level| 标签专属于用户，因此试图从包中使用该标签添加代码将导致错误。
%
% \subsubsection{定义挂钩代码之间的关系}
% \label{sec:rules}
%
% 默认假设是由不同包添加到挂钩的代码是独立的，并且它们执行的顺序是不相关的。
% 虽然在许多情况下这是正确的，但在其他情况下显然是错误的。
%
% 在引入挂钩管理系统之前，包必须采取复杂的预防措施来确定其他包是否也被加载（在前面或后面），
% 并找到一些方法相应地更改其行为。
% 此外，通常用户需要负责以正确的顺序加载包，以使添加到挂钩的代码以正确的顺序添加，
% 有些情况即使更改加载顺序也无法解决冲突。
%
% 使用新的挂钩管理系统，现在可以定义（即关系）不同包添加的代码块之间的规则，
% 并明确描述它们应该被处理的顺序。
%
% \begin{function}{\DeclareHookRule}
%   \begin{syntax}
%     \cs{DeclareHookRule} \Arg{hook}\Arg{label1}\Arg{relation}\Arg{label2}
%   \end{syntax}
% 为给定的 \meta{hook} 定义 \meta{label1} 和 \meta{label2} 之间的关系。
% 如果 \meta{hook} 是 \texttt{??}，则为使用这两个标签的所有挂钩定义了默认关系，
% 即具有标记为 \meta{label1} 和 \meta{label2} 的代码块的挂钩。
% 对于特定挂钩的规则优先于使用 \texttt{??} 作为 \meta{hook} 的默认规则。
%
% 目前，支持的关系有以下几种：
%
% \begin{itemize}
%
% \item[\texttt{before} 或 \texttt{\string<}]
%
%   \meta{label1} 的代码出现在 \meta{label2} 的代码之前。
%
% \item[\texttt{after} 或 \texttt{\string>}]
%
%   \meta{label1} 的代码出现在 \meta{label2} 的代码之后。
%
% \item[\texttt{incompatible-warning}]
%
%   只能出现 \meta{label1} 或 \meta{label2} 的代码（表示两个包或其部分不兼容）。
%   如果两个标签同时出现在同一个挂钩中，会发出警告。
%
% \item[\texttt{incompatible-error}]
%
%   类似于 \texttt{incompatible-warning}，但是不会发出警告，而是引发 \LaTeX{} 错误，
%   并在冲突解决前从该挂钩中删除两个标签的代码。
%
% \item[\texttt{voids}]
%
%   \meta{label1} 的代码覆盖了 \meta{label2} 的代码。
%   更确切地说，在该挂钩中会删除 \meta{label2} 的代码。
%   例如，如果一个包在功能上是另一个包的超集，因此希望撤消某个挂钩中的代码并用自己的版本替换，
%   则可以使用此选项。
%
% \item[\texttt{unrelated}]
%
%   \meta{label1} 和 \meta{label2} 的代码顺序无关紧要。
%   此规则用于撤销之前指定的不正确规则。
%
% \end{itemize}
%
% 对于给定挂钩的两个标签之间只能存在一个关系，即后续的 \cs{DeclareHookRule} 会覆盖任何先前的声明。
%
% 可以使用点语法指定 \meta{hook} 和 \meta{label}，以表示当前包名称。
% 请参阅第~\ref{sec:default-label} 节。
%
% \end{function}
%
%
% \begin{function}{\ClearHookRule}
%   \begin{syntax}
%     \cs{ClearHookRule}\Arg{hook}\Arg{label1}\Arg{label2}
%   \end{syntax}
%    这是一种简化的写法，表示给定的 \meta{hook} 中 \meta{label1} 和 \meta{label2} 之间无关联。
% \end{function}
%
% \begin{function}{\DeclareDefaultHookRule}
%   \begin{syntax}
%     \cs{DeclareDefaultHookRule}\Arg{label1}\Arg{relation}\Arg{label2}
%   \end{syntax}
%    这为所有挂钩设置了 \meta{label1} 和 \meta{label2} 之间的关系，
%    除非特定挂钩被另一个规则覆盖。
%    适用于一个包与另一个包有特定关系的情况，例如，是 \texttt{incompatible} 或总是需要特殊顺序 \texttt{before} 或 \texttt{after}。
%    （技术上，这只是使用 \cs{DeclareHookRule} 并将 \texttt{??} 作为挂钩名称的简写。）
%
%    声明默认规则仅在文档导言部分支持。\footnotemark{}
%
%    可以使用点语法指定 \meta{label}，以表示当前包名称。请参阅第~\ref{sec:default-label} 节。
% \end{function}\footnotetext{尝试这样做，例如通过使用 \texttt{??} 的 \cs{DeclareHookRule}，
%    会产生不良的副作用，并且不受支持（尽管出于性能原因未显式捕获）。}
%
%
%
% \subsubsection{查询挂钩}
% \label{sec:querying}
%
% 简单的数据类型，比如记号列表，有三种可能的状态：
% \begin{itemize}
%   \item 存在但为空；
%   \item 存在且非空；以及
%   \item 不存在（此时不存在空的概念）。
% \end{itemize}
% 挂钩稍微复杂一些：
% 一个挂钩可以存在也可以不存在，独立于此，它可以是空的也可以是非空的。
% 这意味着即使一个挂钩不存在，它也可能是非空的，而且它也可以被禁用。
%
% 这种看似奇怪的状态可能发生在这样的情况下，例如，包 $A$ 定义了挂钩 \hook{A/foo}，
% 而包 $B$ 向该挂钩添加了一些代码。然而，文档可能在加载包 $A$ 之前加载了包 $B$，或者根本没有加载包 $A$。
% 在这两种情况下，一些代码被添加到了挂钩 \hook{A/foo} 中，但该挂钩尚未定义，因此该挂钩被认为是非空的，但实际上它并不存在。
% 因此，查询挂钩的存在性并不意味着它的空值，反之亦然。
%
% 由于代码或规则可以添加到一个挂钩，即使它还不存在，所以查询其存在性没有实际用途
% （与其他变量不同，其他变量只有在已经声明的情况下才能更新）。因此，只有对空值的测试具有公共接口。
%
% 当没有代码添加到挂钩的永久代码池或其“next”记号列表时，挂钩被认为空。挂钩不需要被声明为具有代码池。
% 当使用 \cs{NewHook} 或其变体声明挂钩时，该挂钩被认为存在。当向其添加代码时，通用挂钩如 \hook{file} 和 \hook{env} 会自动声明。
%
% \begin{function}[EXP]{\IfHookEmptyTF}
%   \begin{syntax}
%     \cs{IfHookEmptyTF} \Arg{hook} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   检测 \meta{hook} 是否为空（即没有使用 \cs{AddToHook} 或 \cs{AddToHookNext} 添加代码，或者通过 \cs{RemoveFromHook} 将代码移除），
%   根据结果分别执行 \meta{true code} 或 \meta{false code}。
%
%    无法使用点语法指定 \meta{hook}。
%    前导的 |.| 会被视为字面量。
% \end{function}
%
%
%
% \subsubsection{显示挂钩代码}
%
% 如果需要使用挂钩规则调整挂钩中的代码执行顺序，了解挂钩相关信息、当前顺序和现有规则将会很有帮助。
%
% \begin{function}{\ShowHook,\LogHook}
%   \begin{syntax}
%     \cs{ShowHook} \Arg{hook}
%     \cs{LogHook}  \Arg{hook}
%   \end{syntax}
%   显示关于 \meta{hook} 的信息，例如：
%   \begin{itemize}
%   \item 挂钩中添加的代码块（及其标签），
%   \item 任何用于排序的设置规则，
%   \item 计算出的代码块执行顺序，
%   \item 仅在下一次调用时执行的任何代码。
%   \end{itemize}
% \end{function}
%
% \cs{LogHook} 将信息打印到 |.log| 文件中，而 \cs{ShowHook} 将其打印到终端/命令窗口，并在 
% \cs{errorstopmode} 下启动 \TeX 的提示，等待用户操作。
%
% 可以使用点语法指定 \meta{hook}，以表示当前包名称。请参阅第~\ref{sec:default-label} 节。
%
%^^A   % Code for the listing below:
%^^A   \NewHook{example-hook}
%^^A   \AddToHook{example-hook}{[code from 'top-level']}
%^^A   \AddToHook{example-hook}[foo]{[code from package 'foo']}
%^^A   \AddToHook{example-hook}[bar]{[from package 'bar']}
%^^A   \AddToHook{example-hook}[baz]{[package 'baz' is here]}
%^^A   \AddToHookNext{example-hook}{[one-time code]}
%^^A   \DeclareHookRule{example-hook}{baz}{before}{foo}
%^^A   \DeclareDefaultHookRule{bar}{after}{baz}
%^^A   \ShowHook{example-hook}
%
%   \def\theFancyVerbLine{\textcolor[gray]{0.5}{%^^A
%     \sffamily\tiny\arabic{FancyVerbLine}}}
%
%   \bigskip
% 假设有一个名为 \texttt{example-hook} 的钩子，其 \cs{ShowHook}|{example-hook}| 的输出如下：
%   \begin{verbatim}[numbers=left]
%   -> The hook 'example-hook':
%   > Code chunks:
%   >     foo -> [code from package 'foo']
%   >     bar -> [from package 'bar']
%   >     baz -> [package 'baz' is here]
%   > Document-level (top-level) code (executed last):
%   >     -> [code from 'top-level']
%   > Extra code for next invocation:
%   >     -> [one-time code]
%   > Rules:
%   >     foo|baz with relation >
%   >     baz|bar with default relation <
%   > Execution order (after applying rules):
%   >     baz, foo, bar.
%   \end{verbatim}
%
% 在上面的列表中，第3到第5行展示了添加到钩子的三个代码片段及其相应的标签，格式如下：
%   \begin{quote}
%   \quad \meta{label}\verb| -> |\meta{code}
%   \end{quote}
%
% 第7行展示了用户在主文档中添加的代码片段（标记为 |top-level|），格式如下：
%   (labeled |top-level|) in the format
%   \begin{quote}
%   \quad\verb|Document-level (top-level) code (executed |%^^A
%              \meta{first\texttt{\string|}last}\verb|):|\\
%   \quad\verb|    -> |\meta{\texttt{top-level} code}
%   \end{quote}
% 这段代码将是钩子执行的第一个或最后一个代码（如果钩子是正常的，则为 |last|，如果是反向的，则为 |first|）。
% 这个代码块不受规则影响，也不参与排序。
%
% 第9行展示了下一次钩子执行时的代码片段格式，如下：
%   \begin{quote}
%   \quad \verb|-> |\meta{next-code}
%   \end{quote}
% 这段代码将在下一次 \verb|\UseHook{example-hook}| 时使用并消失，与之前提到的代码片段相反，
% 这些代码片段只能通过 \verb|\RemoveFromHook{|\meta{label}|}[example-hook]| 从钩子中移除。
%
% 第11和第12行展示了影响该钩子的声明规则的格式，如下：
%   \begin{quote}
%   \quad \meta{label-1}\verb+|+\meta{label-2}| with |%^^A
%         \meta{\texttt{default}?}| relation |\meta{relation}
%   \end{quote}
% 这意味着 \meta{relation} 应用于 \meta{label-1} 和 \meta{label-2}，按照 \cs{DeclareHookRule} 中的详细说明顺序执行。
% 如果关系是 \texttt{default}，则意味着此规则适用于所有钩子中的 \meta{label-1} 和 \meta{label-2}（除非被非默认关系覆盖）。
%
% 最后，第14行按顺序列出了排序后钩子中的标签；即，在使用钩子时它们将被执行的顺序。
%
%
% \subsubsection{调试钩子代码}
%
% \begin{function}{\DebugHooksOn,\DebugHooksOff}
%   \begin{syntax}
%     \cs{DebugHooksOn}
%   \end{syntax}
%    打开或关闭钩子代码的调试。这会显示对钩子数据结构的大部分更改。
%    输出相当粗糙，不适合正常使用。
% \end{function}
%
%
% \subsection{L3 层的编程 (\texttt{expl3}) 接口}
% \label{sec:l3hook-interface}
%
%
% 这是关于与 \texttt{expl3} 写的包一起使用的 \LaTeX3 编程接口的快速摘要。
% 与 \LaTeXe{} 接口不同，它们始终仅使用必需的参数，例如，您总是必须为代码片段指定 \meta{label}。
% 因此，我们建议即使在 \texttt{expl3} 包中也使用前面讨论过的声明，但选择权在您手中。
%
%
% \begin{function}{
%     \hook_new:n,
%     \hook_new_reversed:n,
%     \hook_new_pair:nn
%   }
%   \begin{syntax}
%     \cs{hook_new:n} \Arg{hook}
%     \cs{hook_new_reversed:n} \Arg{hook}
%     \cs{hook_new_pair:nn} \Arg{hook-1} \Arg{hook-2}
%   \end{syntax}
%   创建一个具有正常或反向代码顺序的新 \meta{hook}。
%   \cs{hook_new_pair:nn} 创建了一对此类钩子，其中 \Arg{hook-2} 是一个反向钩子。
%   如果钩子名称已经被使用，将引发错误并且不会创建该钩子。
%
%   可以使用点号语法来指定 \meta{hook}，表示当前包的名称。
%   参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{
%     \hook_new_with_args:nn,
%     \hook_new_reversed_with_args:nn,
%     \hook_new_pair_with_args:nnn
%   }
%   \begin{syntax}
%     \cs{hook_new_with_args:nn} \Arg{hook} \Arg{number}
%     \cs{hook_new_reversed_with_args:nn} \Arg{hook} \Arg{number}
%     \cs{hook_new_pair_with_args:nnn} \Arg{hook-1} \Arg{hook-2} \Arg{number}
%   \end{syntax}
%   创建一个具有正常或反向代码顺序的新 \meta{hook}，在使用时从输入流中获取 \meta{number} 个参数。
%   \cs{hook_new_pair_with_args:nn} 创建了一对此类钩子，其中 \Arg{hook-2} 是一个反向钩子。
%   如果钩子名称已经被使用，将引发错误并且不会创建该钩子。
%
%   可以使用点号语法来指定 \meta{hook}，表示当前包的名称。
%   参见第~\ref{sec:default-label} 节。
% \end{function}
%
%
%
% \begin{function}{\hook_disable_generic:n}
%   \begin{syntax}
%     \cs{hook_disable_generic:n} \Arg{hook}
%   \end{syntax}
%    将 \Arg{hook} 标记为已禁用。任何进一步尝试向其添加代码或声明都将导致错误，
%    并且任何对 \cs{hook_use:n} 的调用都将不起作用。
%
%    此声明旨在用于通用钩子，如果它们接收到代码，则已知它们无法正常工作（参见 \texttt{ltcmdhooks-doc}）。
%
%    可以使用点号语法来指定 \meta{hook}，表示当前包的名称。
%    参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\hook_activate_generic:n}
%   \begin{syntax}
%     \cs{hook_activate_generic:n} \Arg{hook}
%   \end{syntax}
%    这类似于 \cs{hook_new:n}，但如果钩子之前使用 \cs{hook_new:n} 声明过，
%    则不会执行任何操作。此声明应仅在特殊情况下使用，
%    例如，当来自另一个包的命令需要更改，而不清楚是否已经先前显式声明了通用的 \hook{cmd} 钩子（用于该命令）时。
%
%    通常情况下，应该使用 \cs{hook_new:n} 而不是这个声明。
% \end{function}
%
%
%
%
% \begin{function}{\hook_use:n,\hook_use:nnw}
%   \begin{syntax}
%     \cs{hook_use:n} \Arg{hook}
%     \cs{hook_use:nnw} \Arg{hook} \Arg{number} \Arg{arg_1} \ldots \Arg{arg_n}
%   \end{syntax}
%    执行 \Arg{hook} 代码，然后执行（如果设置了）下一次调用的代码，
%    随后清空该下一次调用的代码。
%    对于使用参数声明的钩子，应使用 \cs{hook_use:nnw}，并且后面应跟着与声明的参数数量相同的大括号组。
%    \meta{number} 应该是钩子声明的参数数量。
%    如果钩子未声明，则此命令不起作用，并且将从输入中移除 \meta{number} 个项目。
%
%    \meta{hook} \emph{不能} 使用点号语法指定。
%    开头的 |.| 将被视为字面量处理。
% \end{function}
%
% \begin{function}{\hook_use_once:n,\hook_use_once:nnw}
%   \begin{syntax}
%     \cs{hook_use_once:n} \Arg{hook}
%     \cs{hook_use_once:nnw} \Arg{hook} \Arg{number} \Arg{arg_1} \ldots \Arg{arg_n}
%   \end{syntax}
%     改变 \Arg{hook} 的状态，从现在开始，任何添加到钩子代码的操作都会立即执行。
%     然后执行已设置的任何 \Arg{hook} 代码。
%    对于使用参数声明的钩子，应使用 \cs{hook_use_once:nnw}，并且后面应跟着与声明的参数数量相同的大括号组。
%    \meta{number} 应该是钩子声明的参数数量。
%    如果钩子未声明，则此命令不起作用，并且将从输入中移除 \meta{number} 个项目。
%
%    \meta{hook} \emph{不能} 使用点号语法指定。
%    开头的 |.| 将被视为字面量处理。
% \end{function}
%
% \begin{function}{
%     \hook_gput_code:nnn,
%     \hook_gput_code_with_args:nnn
%   }
%   \begin{syntax}
%     \cs{hook_gput_code:nnn} \Arg{hook} \Arg{label} \Arg{code}
%     \cs{hook_gput_code_with_args:nnn} \Arg{hook} \Arg{label} \Arg{code}
%   \end{syntax}
%    将一段 \meta{code} 添加到标记为 \meta{label} 的 \meta{hook} 中。
%    如果标签已经存在，则将 \meta{code} 追加到已有的代码后面。
%
%    如果使用了 \cs{hook_gput_code_with_args:nnn}，那么 \meta{code} 可以访问传递给 \cs{hook_use:nnw}
%    （或 \cs{hook_use_once:nnw}）的参数，使用 \verb|#1|、\verb|#2|、\ldots、\verb|#n|（最多为钩子声明的参数数量）。
%    在这种情况下，如果要将实际参数标记添加到代码中，应该使用两个相同的参数标记。
%
%    如果要向外部的 \meta{hook}（例如内核或其他包）添加代码，那么约定是使用包名称作为 \meta{label}，
%    而不是某个内部模块名称或其他任意字符串。
%
%    可以使用点号语法来指定 \meta{hook} 和 \meta{label}，表示当前包的名称。
%    参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{
%     \hook_gput_next_code:nn,
%     \hook_gput_next_code_with_args:nn,
%   }
%   \begin{syntax}
%     \cs{hook_gput_next_code:nn} \Arg{hook} \Arg{code}
%   \end{syntax}
%    添加一段 \meta{code}，仅在下一次 \meta{hook} 调用中使用。使用后即消失。
%
%    如果使用了 \cs{hook_gput_next_code_with_args:nn}，那么 \meta{code} 可以访问传递给 \cs{hook_use:nnw}
%    （或 \cs{hook_use_once:nnw}）的参数，使用 \verb|#1|、\verb|#2|、\ldots、\verb|#n|（最多为钩子声明的参数数量）。
%    在这种情况下，如果要将实际参数标记添加到代码中，应该使用两个相同的参数标记。
%
%    这比 \cs{hook_gput_code:nnn} 更简单，代码将按照声明的顺序简单地附加到钩子末尾，
%    即，在所有标准代码执行完毕后。因此，如果需要撤销标准操作，必须将其作为 \meta{code} 的一部分处理。
%
%    可以使用点号语法来指定 \meta{hook}，表示当前包的名称。
%    参见第~\ref{sec:default-label} 节。
% \end{function}
%
%
% \begin{function}{\hook_gclear_next_code:n}
%   \begin{syntax}
%     \cs{hook_gclear_next_code:n} \Arg{hook}
%   \end{syntax}
%   撤销任何之前的 \cs{hook_gput_next_code:nn}。
% \end{function}
%
%
%
%  \begin{function}{\hook_gremove_code:nn}
%   \begin{syntax}
%     \cs{hook_gremove_code:nn} \Arg{hook} \Arg{label}
%   \end{syntax}
%    移除标记为 \meta{label} 的 \meta{hook} 中的任何代码。
%
%    如果在 \meta{hook} 中没有 \meta{label} 下的代码，
%    或者 \meta{hook} 不存在，尝试使用 \cs{hook_gremove_code:nn} 时将发出警告，并且命令将被忽略。
%
%    如果第二个参数是 \texttt{*}，则会移除所有代码块。
%    这相当危险，因为会删除其他包中的代码，可能会影响到你不清楚的代码，请在使用之前三思！
%
%    可以使用点号语法来指定 \meta{hook} 和 \meta{label}，表示当前包的名称。
%    参见第~\ref{sec:default-label} 节。
% \end{function}
%
%
%  \begin{function}{\hook_gset_rule:nnnn}
%   \begin{syntax}
%     \cs{hook_gset_rule:nnnn} \Arg{hook} \Arg{label1} \Arg{relation} \Arg{label2}
%   \end{syntax}
%    在 \meta{hook} 中使用 \meta{label1} 和 \meta{label2} 进行关联。
%    查看 \cs{DeclareHookRule} 获取允许的 \meta{relation}。
%    如果 \meta{hook} 是 \texttt{??}，则指定默认规则。
%
%    可以使用点号语法来指定 \meta{hook} 和 \meta{label}，表示当前包的名称。
%    参见第~\ref{sec:default-label} 节。
%    点号语法在两个 \meta{label} 参数中都进行解析，但通常只在其中一个参数中使用才有意义。
% \end{function}
%
% \begin{function}[pTF]{\hook_if_empty:n}
%   \begin{syntax}
%     \cs{hook_if_empty:nTF} \Arg{hook} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   检测 \meta{hook} 是否为空（即，未使用 \cs{AddToHook} 或 \cs{AddToHookNext} 添加代码），
%   并根据结果分别执行 \meta{true code} 或 \meta{false code}。
%
%    \meta{hook} \emph{不能} 使用点号语法指定。
%    开头的 |.| 将被视为字面量处理。
% \end{function}
%
%
% \begin{function}{\hook_show:n,\hook_log:n}
%   \begin{syntax}
%     \cs{hook_show:n} \Arg{hook}
%     \cs{hook_log:n}  \Arg{hook}
%   \end{syntax}
%   显示关于 \meta{hook} 的信息，例如
%   \begin{itemize}
%   \item
%      添加到其中的代码块（及其标签），
%   \item
%      设定的任何用于排序的规则，
%   \item
%      计算出的代码块执行顺序，
%   \item
%      仅在下一次调用时执行的任何代码。
%   \end{itemize}
%
%   \cs{hook_log:n} 将信息打印到 |.log| 文件，
%   而 \cs{hook_show:n} 将其打印到终端/命令窗口，并启动 \TeX 的提示符
%   （仅在 \cs{errorstopmode}）等待用户操作。
%
%    可以使用点号语法来指定 \meta{hook}，表示当前包的名称。
%    参见第~\ref{sec:default-label} 节。
% \end{function}
%
% \begin{function}{\hook_debug_on:,\hook_debug_off:}
%   \begin{syntax}
%     \cs{hook_debug_on:}
%   \end{syntax}
%    打开或关闭钩子代码的调试。这会显示钩子数据的变化。
% \end{function}
%
%
%
% \subsection{关于钩子代码执行顺序} \label{sec:order}
%
%    如果在不设置特殊规则的情况下，\meta{hook} 下不同标签的代码块被视为独立的，
%    这意味着你不能对执行顺序做出假设！
%
%    假设你有以下声明：
%\begin{verbatim}
%    \NewHook{myhook}
%    \AddToHook{myhook}[packageA]{\typeout{A}}
%    \AddToHook{myhook}[packageB]{\typeout{B}}
%    \AddToHook{myhook}[packageC]{\typeout{C}}
%\end{verbatim}
%    使用 \cs{UseHook} 执行钩子将按顺序产生类型输出 \texttt{A} \texttt{B} \texttt{C}。
%    换句话说，执行顺序计算为 \texttt{packageA}、\texttt{packageB}、\texttt{packageC}，
%    可以使用 \cs{ShowHook}\texttt{\{myhook\}} 进行验证：
%\begin{verbatim}
%    -> The hook 'myhook':
%    > Code chunks:
%    >     packageA -> \typeout {A}
%    >     packageB -> \typeout {B}
%    >     packageC -> \typeout {C}
%    > Document-level (top-level) code (executed last):
%    >     ---
%    > Extra code for next invocation:
%    >     ---
%    > Rules:
%    >     ---
%    > Execution order:
%    >     packageA, packageB, packageC.
%\end{verbatim}
%    原因在于代码块被内部保存在属性列表中，属性列表的初始顺序是添加键-值对的顺序。
%    但是，这仅在除添加之外没有其他操作时才成立！
%
%    举个例子，假设你想替换 \texttt{packageA} 的代码块，比如说，
%\begin{verbatim}
%    \RemoveFromHook{myhook}[packageA]
%    \AddToHook{myhook}[packageA]{\typeout{A alt}}
%\end{verbatim}
%    那么你的顺序变成了 \texttt{packageB}、\texttt{packageC}、\texttt{packageA}，
%    因为标签从属性列表中移除，然后重新添加（放在末尾）。
%
%    虽然这可能不太令人惊讶，但如果添加了多余的规则，例如，如果指定了
%\begin{verbatim}
%    \DeclareHookRule{myhook}{packageA}{before}{packageB}
%\end{verbatim}
%    而不是之前我们得到的那些行
%\begin{verbatim}
%    -> The hook 'myhook':
%    > Code chunks:
%    >     packageA -> \typeout {A}
%    >     packageB -> \typeout {B}
%    >     packageC -> \typeout {C}
%    > Document-level (top-level) code (executed last):
%    >     ---
%    > Extra code for next invocation:
%    >     ---
%    > Rules:
%    >     packageB|packageA with relation >
%    > Execution order (after applying rules):
%    >     packageA, packageC, packageB.
%\end{verbatim}
% 当你看到代码块时，仍然是相同的顺序，但是在标签 \texttt{packageB} 和 \texttt{packageC} 的执行顺序已经交换了。
% 原因是，根据规则，有两种满足条件的顺序，而排序算法恰好选择了与没有规则的情况不同的顺序（在没有规则的情况下，算法根本不会运行，因为没有需要解决的内容）。
% 顺便说一下，如果我们改为指定多余的规则
%\begin{verbatim}
%    \DeclareHookRule{myhook}{packageB}{before}{packageC}
%\end{verbatim}
% 执行顺序就不会改变了。
%
% 总结：除非存在部分或完全定义顺序的规则（你可以依赖它们被满足），否则无法依赖执行顺序。
%
%
% \subsection{使用“反转”钩子} \label{sec:reversed-order}
%
% 也许您想知道为什么可以用 \cs{NewReversedHook} 声明一个“反转”钩子以及它到底是做什么的。
%
% 简而言之：一个没有任何规则的反转钩子的执行顺序与使用 \cs{NewHook} 声明的钩子顺序完全相反。
%
% 如果您有一对期望添加涉及分组的代码的钩子，比如在第一个钩子中开始一个环境，在第二个钩子中关闭该环境，这将非常有帮助。举个有些牵强的例子\footnote{有更简单的方法实现相同的效果。}，假设有一个包添加了以下内容：
%\begin{verbatim}
%    \AddToHook{env/quote/before}[package-1]{\begin{itshape}}
%    \AddToHook{env/quote/after} [package-1]{\end{itshape}}
%\end{verbatim}
% 结果是，所有引用将呈现为斜体。
% 现在再假设另一个 |package-too| 也使引用变为蓝色，因此添加了以下内容：
%\begin{verbatim}
%    \usepackage{color}
%    \AddToHook{env/quote/before}[package-too]{\begin{color}{blue}}
%    \AddToHook{env/quote/after} [package-too]{\end{color}}
%\end{verbatim}
% 现在，如果 \hook{env/quote/after} 钩子是一个普通的钩子，那么在两个钩子中我们将得到相同的执行顺序，即：
%\begin{verbatim}
%    package-1, package-too
%\end{verbatim}
% （或相反）结果将是：
%\begin{verbatim}
%    \begin{itshape}\begin{color}{blue} ...
%    \end{itshape}\end{color}
%\end{verbatim}
% 并且会出现一个错误消息，指出 \verb=\begin{color}= 被 \verb=\end{itshape}= 结束了。
% 如果将 \hook{env/quote/after} 声明为反转钩子，执行顺序就会反转，因此所有环境都以正确的顺序关闭，\cs{ShowHook} 将给出以下输出：
%\begin{verbatim}
%    -> The hook 'env/quote/after':
%    > Code chunks:
%    >     package-1 -> \end {itshape}
%    >     package-too -> \end {color}
%    > Document-level (top-level) code (executed first):
%    >     ---
%    > Extra code for next invocation:
%    >     ---
%    > Rules:
%    >     ---
%    > Execution order (after reversal):
%    >     package-too, package-1.
%\end{verbatim}
%
% 执行顺序的反转发生在应用任何规则之前，因此如果您更改顺序，则可能必须在两个钩子中都进行更改，而不仅仅是一个，但这取决于用例。
%
%
%
%
% \subsection{“普通”钩子与“一次性”钩子的区别}
% \label{sec:onetime-hooks}
%
% 在执行钩子时，开发人员可以选择使用 \cs{UseHook} 或 \cs{UseOneTimeHook}（或它们的 \pkg{expl3} 等效命令 \cs{hook_use:n} 和 \cs{hook_use_once:n}）。
% 这个选择影响了在钩子第一次执行后如何处理 \cs{AddToHook}。
%
% 对于普通钩子，通过 \cs{AddToHook} 添加代码意味着代码块被添加到钩子数据结构中，然后每次调用 \cs{UseHook} 时都会使用它。
%
% 对于一次性钩子，处理方式略有不同：
% 在调用 \cs{UseOneTimeHook} 后，任何进一步尝试通过 \cs{AddToHook} 向钩子添加代码的操作都将立即执行 \meta{code}。
%
% 这有一些需要注意的后果：
% \begin{itemize}
% \item
%
%   如果在钩子执行后向普通钩子添加 \meta{code}，并且由于某种原因它再也不会执行，则新的 \meta{code} 将永远不会被执行。
%
% \item
%
%   相比之下，如果这种情况发生在一次性钩子上，则 \meta{code} 会立即执行。
%
% \end{itemize}
% 具体来说，这意味着类似以下结构的构建：
%\begin{quote}
%    \cs{AddToHook}\verb={myhook}=\\
%    \phantom{\cs{AddToHook}}\verb={= \meta{code-1}
%                                     \cs{AddToHook}\verb={myhook}=\Arg{code-2}
%                                     \meta{code-3} \verb=}=
%\end{quote}
% 对于一次性钩子来说是有效的\footnote{这有时会用于 \cs{AtBeginDocument}，这就是为什么它被支持的原因。}（三个代码块依次执行），但对于普通钩子来说则意义不大，因为对于普通钩子，第一次执行 \verb=\UseHook{myhook}= 时将会：
% \begin{itemize}
% \item
%    执行 \meta{code-1}，
% \item
%    然后执行 \verb=\AddToHook{myhook}{code-2}=，将代码块 \meta{code-2} 添加到下一次调用时使用的钩子中，
% \item
%    最后执行 \meta{code-3}。
% \end{itemize}
% 第二次调用 \cs{UseHook} 时，它将执行上述操作，并且额外执行 \meta{code-2}，因为此时它已被作为代码块添加到钩子中。因此，每次使用钩子时都会添加另一个副本的 \meta{code-2}，所以该代码块将被执行 $\meta{\# of invocations} -1$ 次。
%
%
%
% \subsection{包提供的通用钩子}
% \label{sec:generic-hooks}
%
% \changes{v1.0p}{2021/08/20}{添加了通用钩子的章节（gh/638）}
%
% 钩子管理系统还实现了一类称为“通用钩子”的钩子。通常，钩子在可以在代码中使用之前必须显式声明。这确保了不同的包不会为不相关的目的使用相同的钩子名称——这会导致绝对混乱。然而，有一些“标准”钩子，对于它们事先声明是不合理的，例如，每个命令（理论上）都有一个关联的 \texttt{before} 和 \texttt{after} 钩子。在这种情况下，即对于命令、环境或文件钩子，可以通过 \cs{AddToHook} 简单地向其中添加代码来使用它们。对于更专门的通用钩子，例如 \pkg{babel} 提供的那些，您需要使用下面解释的 \cs{ActivateGenericHook} 进行额外的启用。
%
% \LaTeX{} 提供的通用钩子包括
% \hook{cmd}、
% \hook{env}、
% \hook{file}、
% \hook{include}、
% \hook{package} 和
% \hook{class}，
% 所有这些都可以直接使用：您只需使用 \cs{AddToHook} 来添加代码，但不必在您的代码中添加 \cs{UseHook} 或 \cs{UseOneTimeHook}，因为这已经为您完成了（或者在 \hook{cmd} 钩子的情况下，在必要时会在 \verb=\begin{document}= 处对命令代码进行修补）。
%
% 但是，如果您想在自己的代码中提供进一步的通用钩子，情况稍有不同。为此，您应该使用 \cs{UseHook} 或 \cs{UseOneTimeHook}，但是\emph{不要使用 \cs{NewHook} 声明钩子}。如前所述，对未声明的钩子名称调用 \cs{UseHook} 不起任何作用。因此，作为额外的设置步骤，您需要显式激活您的通用钩子。请注意，以这种方式生成的通用钩子始终是普通钩子。
%
% 对于真正的通用钩子，在钩子名称中包含可变部分的提前激活将是困难或不可能的，因为您通常不知道真实文档中可能出现的可变部分的类型。
%
% 例如，\pkg{babel} 提供了诸如 \hook{babel/\meta{language}/afterextras} 的钩子。然而，\pkg{babel} 中的语言支持通常是通过外部语言包完成的。因此，在核心 \pkg{babel} 代码中为所有语言执行激活并不可行。相反，需要由每个语言包执行（或者由希望使用特定钩子的用户执行）。
%
% 由于这些钩子没有使用 \cs{NewHook} 声明，因此它们的名称应谨慎选择，以确保它们（可能）是唯一的。最佳做法是包括包或命令名称，就像上面 \pkg{babel} 的示例中所做的那样。
%
% 通过这种方式定义的通用钩子始终是普通钩子（即，您不能以这种方式实现反转钩子）。这是一个故意的限制，因为它大大加快了处理速度。
%
%
% \subsection{带参数的钩子}
% \label{sec:hook-args}
%
% 有时需要向钩子传递上下文信息，并且由于某种原因，无法将此类信息存储在宏中。为了满足这个目的，可以声明带参数的钩子，以便程序员可以传递钩子中代码所需的数据。
%
% 带参数的钩子的工作原理基本上与常规钩子相同，大多数适用于常规钩子的命令也适用于带参数的钩子。不同之处在于钩子的声明（使用 \cs{NewHookWithArguments} 而不是 \cs{NewHook}），然后可以使用 \cs{AddToHook} 和 \cs{AddToHookWithArguments} 添加代码，以及钩子的使用（使用 \cs{UseHookWithArguments} 而不是 \cs{UseHook}）。
%
% \medskip
%
% 带参数的钩子必须像常规钩子一样在首次使用前（所有常规钩子一样）声明，使用 \cs{NewHookWithArguments}\Arg{hook}\Arg{number}。然后添加到该钩子的所有代码都可以使用 \verb|#1| 访问第一个参数，\verb|#2| 访问第二个参数，依此类推，直到声明的参数数量。但是，仍然可以添加带有对尚未声明的钩子参数的引用的代码（稍后我们将讨论这一点）。钩子本质上是宏，所以 \TeX{} 的 9 个参数限制适用，并且如果尝试引用不存在的参数号码，则会引发低级 \TeX{} 错误。
%
% \medskip
%
% 要使用带参数的钩子，只需写 \cs{UseHookWithArguments}\Arg{hook}\Arg{number}，然后接着是参数的大括号列表。例如，如果钩子 \hook{test} 需要三个参数，写法如下：
%\begin{verbatim}
%    \UseHookWithArguments{test}{3}{arg-1}{arg-2}{arg-3}
%\end{verbatim}
% 然后，在钩子的 \meta{code} 中，所有的 \verb|#1| 将被替换为 \verb|arg-1|，\verb|#2| 将被替换为 \verb|arg-2|，以此类推。如果在使用时，程序员提供的参数多于钩子声明的参数，则超出的参数将被钩子简单地忽略。如果提供的参数过少，则行为是不可预测的\footnote{钩子 \emph{将}采用声明的参数数量，发生了什么取决于被抓取的内容以及钩子代码对其参数的处理。}。如果钩子未被声明，\meta{number} 个参数将从输入流中移除。
%
% \medskip
%
% 使用 \cs{AddToHookWithArguments} 可以像常规 \cs{AddToHook} 一样向带参数的钩子添加代码，以实现不同的结果。在这种情况下，向钩子添加代码的主要区别在于首先可以访问钩子的参数，当然还有参数标记（\verb|#|$_6$）的处理方式。
%
% 在带参数的钩子中使用 \cs{AddToHook} 将像对所有其他钩子一样工作。这允许包开发人员向本来没有参数的钩子添加参数，而无需担心兼容性问题。这意味着，例如：
%\begin{verbatim}
%    \AddToHook{test}{\def\foo#1{Hello, #1!}}
%\end{verbatim}
% 无论钩子 \hook{test} 是否带参数，都会定义相同的宏 \cs[no-index]{foo}。
%
% 使用 \cs{AddToHookWithArguments} 允许向添加的 \meta{code} 访问钩子的参数，如 \verb|#1|、\verb|#2| 等，直到钩子声明的参数数量。这意味着，如果想要在 \meta{code} 中添加一个 \verb|#|$_6$，那个标记必须在输入中重复。上面的相同定义，使用 \cs{AddToHookWithArguments}，需要重写为：
%\begin{verbatim}
%    \AddToHookWithArguments{test}{\def\foo##1{Hello, ##1!}}
%\end{verbatim}
%
% 将上述示例扩展为使用钩子参数，我们可以重写类似以下内容的代码（现在从声明到使用，以获得完整的画面）：
%\begin{verbatim}
%    \NewHookWithArguments{test}{1}
%    \AddToHookWithArguments{test}{%
%      \typeout{Defining foo with "#1"}
%      \def\foo##1{Hello, ##1! Some text after: #1}%
%    }
%    \UseHook{test}{Howdy!}
%    \ShowCommand\foo
%\end{verbatim}
% 上述代码运行后会在终端打印：
%\begin{verbatim}
%    Defining foo with "Howdy!"
%    > \foo=macro:
%    #1->Hello, #1! Some text after: Howdy!.
%\end{verbatim}
% 请注意，在对 \cs{AddToHookWithArguments} 的调用中，\verb|##1| 变为了 \verb|#1|，而 \verb|#1| 被传递给钩子的参数。如果再次使用钩子并提供不同的参数，定义自然会发生变化。
%
% \bigskip
%
% 在声明钩子和确定钩子数量固定之前，可以添加引用钩子参数的代码。但是，如果钩子中添加的某些代码引用的参数多于将为该钩子声明的参数数量，则在钩子声明时会出现低级 \TeX{} 错误，指示“非法参数编号”，这将很难追踪，因为在这一点上 \TeX{} 无法知道引起问题的代码来自何处。因此，包编写者明确记录每个钩子可以接受多少个参数（如果有的话）是非常重要的，以便使用这些包的用户知道可以引用多少个参数，同样重要的是，了解每个参数的含义。
%
% \subsection{私有的 \LaTeX{} 核心钩子}
%
%    有几个地方对于 \LaTeX{} 正确运行而言绝对至关重要，需要按照精确定义的顺序执行代码。即使可以通过钩子管理实现这一点（通过添加各种规则来确保与包添加的其他代码的适当排序），但这会使每个文档变得不必要地缓慢，因为即使结果是预先确定的，也必须进行排序。此外，这会强迫包作者不必要地为钩子添加进一步的规则（或者破坏 \LaTeX{}）。
%
%    出于这个原因，此类代码不使用钩子管理，而是直接在公共钩子之前或之后使用私有内核命令，命名约定如下：\cs{@kernel@before@\meta{hook}} 或 \cs{@kernel@after@\meta{hook}}。例如，在 \cs{enddocument} 中你会找到：
%\begin{verbatim}
%   \UseHook{enddocument}%
%   \@kernel@after@enddocument
%\end{verbatim}
%    这意味着首先执行用户/包可访问的 \hook{enddocument} 钩子，然后执行内部核心钩子。正如它们的名称所示，这些内核命令不应由第三方包更改，请不要这样做，这样有利于稳定性，而是使用其旁边的公共钩子。\footnote{与 \TeX{} 中的所有内容一样，没有强制执行此规则，通过查看代码很容易发现内核如何向其添加内容。因此，这个部分的主要目的是说：“请不要这样做，这是不可配置的代码！”}
%
%
%
% \subsection{遗留的 \LaTeXe{} 接口}
%
% \newcommand\onetimetext{这是一个一次性钩子，因此在执行后，所有进一步尝试添加代码的操作都将立即执行该代码（参见第~\ref{sec:onetime-hooks} 节）。}
%
% \LaTeXe{} 提供了一小部分钩子以及用于向其添加代码的命令。它们在这里列出，并保留了向后兼容性。
%
% 使用新的钩子管理机制，\LaTeX{} 添加了几个额外的钩子，未来还将添加更多。请参见下一节以了解已经可用的内容。
%
%
% \begin{function}{\AtBeginDocument}
%   \begin{syntax}
%     \cs{AtBeginDocument} \oarg{label} \Arg{code}
%   \end{syntax}
%   如果不使用可选参数 \meta{label}，它基本上与以前一样，即将 \meta{code} 添加到 \hook{begindocument} 钩子（在 \verb=\begin{document}= 内执行）。
%    但是，通过这种方式添加的所有代码都使用标签 \hook{top-level} 进行标记（参见第~\ref{sec:top-level} 节），如果在包或类之外进行，或者使用包/类名称，如果在这样的文件内部调用（参见第~\ref{sec:default-label} 节）。
%
%    这样，使用 \cs{AddToHook} 或 \cs{AtBeginDocument} 使用不同的标签显式地按照需要排序代码块，例如，在另一个包的代码之前或之后运行某些代码。当使用可选参数时，该调用等效于运行 \cs{AddToHook} \texttt{\{begindocument\}} \oarg{label} \Arg{code}。
%
%    \cs{AtBeginDocument} 是 \hook{begindocument} 钩子（参见第~\ref{sec:begindocument-hooks} 节）的包装器，它是一个一次性钩子。因此，在 \hook{begindocument} 钩子在 \verb=\begin{document}= 处执行后，任何尝试使用 \cs{AtBeginDocument} 或 \cs{AddToHook} 向该钩子添加 \meta{code} 的操作都将导致该 \meta{code} 立即执行。有关一次性钩子的更多信息，请参见第~\ref{sec:onetime-hooks} 节。
%
%    对于具有已知顺序要求的重要包，我们可能会随着时间的推移向内核（或这些包）添加规则，以便它们不受文档加载顺序的影响而工作。
% \end{function}
%
% \begin{function}{\AtEndDocument}
%   \begin{syntax}
%     \cs{AtEndDocument} \oarg{label} \Arg{code}
%   \end{syntax}
%   Like \cs{AtBeginDocument} but for the \hook{enddocument} hook.
% \end{function}
%
%    \bigskip
%
%    在 \LaTeXe{} 中之前存在的少量钩子在内部使用诸如 \cs{@begindocumenthook} 之类的命令，有时包直接增强它们而不是通过 \cs{AtBeginDocument} 进行操作。出于这个原因，目前支持这样做，也就是说，如果系统检测到这样一个内部传统钩子命令包含代码，则将其添加到新的钩子系统中，并使用标签 \texttt{legacy} 进行标记，以防止丢失。
%
%    然而，随着时间的推移，剩余的直接使用情况需要更新，因为在未来的某个 \LaTeX{} 发布中，我们将关闭此传统支持，因为它会不必要地减慢处理速度。
%
%
% \section{\LaTeXe{} 命令和由钩子增强的环境}
%
%    在本节中，我们描述了现在由 \LaTeX{} 提供的标准钩子，或者提供了指向其他文档的指针，其中对它们进行了描述。本节将随时间而增长（并且可能最终会转移到 usrguide3）。
%
% \subsection{通用钩子}
% \label{sec:generic}
%
% 正如前面所述，除了通用钩子之外，所有钩子在使用之前都必须使用 \cs{NewHook} 声明。
% 所有通用钩子的名称都采用以下形式：\enquote{\meta{type}/\meta{name}/\meta{position}}，其中 \meta{type} 取自下面预定义的列表，\meta{name} 是其含义将取决于 \meta{type} 的变量部分。
% 最后一个组成部分 \meta{position} 具有更复杂的可能性：
% 它始终可以是 |before| 或 |after|；对于 |env| 钩子，还可以是 |begin| 或 |end|；对于 |include| 钩子，还可以是 |end|。每个特定的钩子在下面或 \texttt{ltcmdhooks-doc.pdf} 或 \texttt{ltfilehook-doc.pdf} 中有文档记录。
%
% \LaTeX{} 提供的通用钩子属于以下六种类型：
% \begin{description}
%   \item[env] 在环境之前和之后执行的钩子——\meta{name} 是环境的名称，\meta{position} 的可用值为 |before|、|begin|、|end| 和 |after|；
%   \item[cmd] 添加到命令之前和之后执行的钩子——\meta{name} 是命令的名称，\meta{position} 的可用值为 |before| 和 |after|；
%   \item[file] 在读取文件之前和之后执行的钩子——\meta{name} 是文件的名称（带有扩展名），\meta{position} 的可用值为 |before| 和 |after|；
%   \item[package] 在加载包之前和之后执行的钩子——\meta{name} 是包的名称，\meta{position} 的可用值为 |before| 和 |after|；
%   \item[class] 在加载类之前和之后执行的钩子——\meta{name} 是类的名称，\meta{position} 的可用值为 |before| 和 |after|；
%   \item[include] 在 \cs{include} 包含的文件之前和之后执行的钩子——\meta{name} 是包含的文件的名称（不包含 |.tex| 扩展名），\meta{position} 的可用值为 |before|、|end| 和 |after|。
% \end{description}
%
% 下面详细介绍了上述每个钩子，并提供了链接的文档。
% ^^A^^A^^A \pho{Wouldn't it be better to document all hooks here?}
%
% \subsubsection{所有环境的通用钩子}
%
%    每个环境 \meta{env} 现在都有四个与之关联的钩子：
%    \begin{description}
%    \item[\hook{env/\meta{env}/before}]
%
%       这个钩子作为 \cs{begin} 的一部分执行，特别是在开始环境组之前。因此，它的范围不受环境的限制。
%
%    \item[\hook{env/\meta{env}/begin}]
%
%       这个钩子作为 \cs{begin} 的一部分直接位于特定于环境开始的代码之前（例如，\cs{newenvironment} 的第二个参数）。它的范围是环境主体。
%
%    \item[\hook{env/\meta{env}/end}]
%
%       这个钩子作为 \cs{end} 的一部分直接位于特定于环境结束的代码之前（例如，\cs{newenvironment} 的第三个参数）。
%
%    \item[\hook{env/\meta{env}/after}]
%
%       这个钩子作为 \cs{end} 的一部分，在环境结束的代码和环境组结束之后执行。因此，它的范围不受环境的限制。
%
%       该钩子实现为一个反向钩子，因此，如果两个包向 \hook{env/\meta{env}/before} 和 \hook{env/\meta{env}/after} 添加代码，它们可以添加周围的环境，且关闭它们的顺序是正确的。
%
%    \end{description}
%    通用环境钩子即使对于只能在文档中出现一次的环境也不是一次性钩子。\footnote{因此，如果在处理环境之后添加代码，只有在环境再次出现且不会发生代码执行时，该代码才会被执行。} 与其他钩子不同，也不需要使用 \cs{NewHook} 声明它们。
%
%    这些钩子只有在使用 \cs{begin}\Arg{env} 和 \cs{end}\Arg{env} 时才会执行。如果环境代码是通过对 \cs[no-index]{\meta{env}} 和 \cs[no-index]{end\meta{env}} 进行低级调用（例如，为了避免环境组），则它们不可用。如果要在使用此方法的代码中使用它们，您需要自己添加它们，即编写类似以下内容的代码：
%\begin{verbatim}
%  \UseHook{env/quote/before}\quote
%      ...
%  \endquote\UseHook{env/quote/after}
%\end{verbatim}
%    以添加外部钩子等。
%
%    为了与现有包的兼容性，还提供了以下四个命令来设置环境钩子；但对于新的包，我们建议直接使用钩子名称和 \cs{AddToHook}。
%
% \begin{function}{\BeforeBeginEnvironment}
%   \begin{syntax}
%     \cs{BeforeBeginEnvironment} \oarg{label} \Arg{env} \Arg{code}
%   \end{syntax}
%   此声明使用 \meta{label} 将代码添加到 \hook{env/\meta{env}/before} 钩子中。如果未给出 \meta{label}，则使用 \meta{default label}（参见第~\ref{sec:default-label} 节）。
% \end{function}
%
% \begin{function}{\AtBeginEnvironment}
%   \begin{syntax}
%     \cs{AtBeginEnvironment} \oarg{label} \Arg{env} \Arg{code}
%   \end{syntax}
%   这类似于 \cs{BeforeBeginEnvironment}，但它将代码添加到 \hook{env/\meta{env}/begin} 钩子中。
% \end{function}
%
% \begin{function}{\AtEndEnvironment}
%   \begin{syntax}
%     \cs{AtEndEnvironment} \oarg{label} \Arg{env} \Arg{code}
%   \end{syntax}
%   这类似于 \cs{BeforeBeginEnvironment}，但它将代码添加到 \hook{env/\meta{env}/end} 钩子中。
% \end{function}
%
% \begin{function}{\AfterEndEnvironment}
%   \begin{syntax}
%     \cs{AfterEndEnvironment} \oarg{label} \Arg{env} \Arg{code}
%   \end{syntax}
%   这类似于 \cs{BeforeBeginEnvironment}，但它将代码添加到 \hook{env/\meta{env}/after} 钩子中。
% \end{function}
%
%
% \subsubsection{命令的通用钩子}
%
%    与环境类似，现在（至少在理论上）对于任何 \LaTeX{} 命令都有两个通用钩子可用。它们是：
%    \begin{description}
%    \item[\hook{cmd/\meta{name}/before}]
%
%       此钩子在命令执行的开头执行。
%
%    \item[\hook{cmd/\meta{name}/after}]
%       此钩子在命令体的最后执行。它实现为一个反向钩子。
%    \end{description}
%    实际上有一些限制，尤其是 \hook{after} 钩子仅适用于一部分命令。有关这些限制的详细信息可以在 \texttt{ltcmdhooks-doc.pdf} 中找到，或者在 \texttt{ltcmdhooks-code.pdf} 中查看代码。
%
%
%
%
% \subsubsection{文件加载操作提供的通用钩子}
%
%    在通过其高级接口加载文件（例如 \cs{input}、\cs{include}、\cs{usepackage}、\cs{RequirePackage} 等）时，\LaTeX{} 添加了几个钩子。这些钩子在 \texttt{ltfilehook-doc.pdf} 中有文档说明，或者可以在 \texttt{ltfilehook-code.pdf} 中查看代码。
%
%
%
% \subsection{\cs{begin}\texttt{\{document\}} 提供的钩子}
% \label{sec:begindocument-hooks}
%
%    直到 2020 年，\cs{begin}\texttt{\{document\}} 仅提供了一个可通过 \cs{AtBeginDocument} 添加的钩子。多年的经验表明，在一个地方使用这个单一的钩子是不够的，因此，在添加通用钩子管理系统的过程中，在此处添加了许多其他的钩子。这些钩子的位置被选择为提供与外部包（例如 \pkg{etoolbox} 和其他增强 \cs{document} 以获得更好控制的包）所提供的支持相同。
%
%    现在支持以下钩子（它们都是一次性钩子）：
%    \begin{description}
%
%
%    \item[\hook{begindocument/before}]
%
%      此钩子在 \cs{document} 开始时执行，可以将其视为位于导言区末尾的代码的钩子，这就是 \pkg{etoolbox} 的 \cs{AtEndPreamble} 使用它的方式。
%
%      \onetimetext
%
%    \item[\hook{begindocument}]
%
%      这个钩子是通过使用 \cs{AddToHook}\texttt{\{begindocument\}} 或使用 \cs{AtBeginDocument} 添加的，它在读取 \texttt{.aux} 文件和大多数初始化完成后执行，因此可以被钩子代码修改和检查。它后面紧跟一些不应该被更改的进一步初始化，因此稍后会出现。
%
%      该钩子不应该用于添加排版素材，因为我们仍然处于 \LaTeX{} 的初始化阶段，而不是文档主体。如果需要将此类素材添加到文档主体中，请改用下一个钩子。
%
%      \onetimetext
%
%    \item[\hook{begindocument/end}]
%
%      此钩子在 \cs{document} 代码结束时执行，换句话说，在文档主体开始时执行。其后唯一的命令是 \cs{ignorespaces}。
%
%      \onetimetext
%
%    \end{description}
%    \cs{begin} 执行的通用钩子也存在，即 \hook{env/document/before} 和 \hook{env/document/begin}，但对于此特殊环境，最好使用上述专用的一次性钩子。
%
%
%
%
% \subsection{\cs{end}\texttt{\{document\}} 提供的钩子}
%
%    \LaTeXe{} 一直提供 \cs{AtEndDocument} 来添加代码到 \verb=\end{document}=，就在通常执行的代码前面。尽管这对于 \LaTeX\,2.09 的情况是一个很大的改进，但对于许多用例来说并不够灵活，因此，诸如 \pkg{etoolbox}、\pkg{atveryend} 等包对 \cs{enddocument} 进行了补丁，以添加额外的代码挂载点。
%
%    使用包进行补丁总是有问题的，因为会导致冲突（代码可用性、补丁的顺序、不兼容的补丁等）。因此，在 \cs{enddocument} 代码中添加了一些额外的钩子，允许包以受控的方式在各个地方添加代码，而无需覆盖或补丁核心代码。
%
%    现在支持以下钩子（它们都是一次性钩子）：
%    \begin{description}
%
%    \item[\hook{enddocument}]
%
%      与 \cs{AtEndDocument} 相关联的钩子。它在 \cs{enddocument} 开始时立即调用。
%
%      当执行此钩子时，可能仍有未处理的素材（例如推迟列表上的浮动体），而钩子可能会添加进一步要排版的素材。之后，调用 \cs{clearpage} 来确保所有这样的素材都被排版。如果没有等待的素材，则 \cs{clearpage} 没有效果。
%
%      \onetimetext
%
%    \item[\hook{enddocument/afterlastpage}]
%
%      如名称所示，此钩子不应该接收生成更多页面素材的代码。这是做一些最终的收尾工作的正确位置，可能要向 \texttt{.aux} 文件写一些信息（在此时，该文件仍然打开以接收数据，但由于不会再有页面，您需要使用 \cs{immediate}\cs{write} 来写入它）。这也是设置任何在下一步重新读取 \texttt{.aux} 文件时运行的测试代码的正确位置。
%
%      执行此钩子后，\texttt{.aux} 文件将关闭写入，并重新读取以进行一些测试（例如查找缺失引用或重复标签等）。
%
%      \onetimetext
%
%    \item[\hook{enddocument/afteraux}]
%
%      此时，\texttt{.aux} 文件已经被重新处理，因此这是进行最终检查和向用户显示信息的可能位置。但是，对于后者，您可能更喜欢下一个钩子，这样您的信息会显示在（可能较长的）文件列表之后，如果通过 \cs{listfiles} 请求的话。
%
%      \onetimetext
%
%    \item[\hook{enddocument/info}]
%
%      此钩子用于接收向终端写入最终信息消息的代码。它紧随上一个钩子之后执行（因此两者可以合并，但是然后添加更多代码的包始终需要提供显式规则来指定它应该放在何处）。
%
%      此钩子已经包含内核添加的一些代码（标签重复警告、缺失引用、字体替换等），即在使用 \cs{listfiles} 时列出的文件列表和警告信息。
%
%      \onetimetext
%
%    \item[\hook{enddocument/end}]
%
%      最后，此钩子在最终调用 \cs{@{}@end} 前执行。
%
%      \onetimetext % 甚至在此之后添加代码可能吗？
%
%    \end{description}
%
%
%    还有一个名为 \hook{shipout/lastpage} 的钩子。此钩子作为文档中最后一个 \cs{shipout} 的一部分执行，以允许包将最终的 \cs{special} 添加到该页面。此钩子相对于上述列表中的钩子的执行时间可以因文档而异。此外，要正确确定哪个 \cs{shipout} 是最后一个，需要多次运行 \LaTeX{}，因此最初它可能在错误的页面上执行。有关详细信息，请参阅第~\ref{sec:shipout} 节。
%
%
%    还可以使用通用的 \hook{env/document/end} 钩子，它是由 \cs{end} 执行的，即在上述的第一个钩子前执行。但是请注意，另一个通用的 \cs{end} 环境钩子，即 \hook{env/document/after}，永远不会被执行，因为此时 \LaTeX{} 已经完成了文档处理。
%
%
%
%
% \subsection{\cs{shipout} 操作提供的钩子}
% \label{sec:shipout}
%
%    在 \LaTeX{} 生成页面的过程中添加了几个钩子和机制。这些内容在 \texttt{ltshipout-doc.pdf} 中有详细记录，或者在 \texttt{ltshipout-code.pdf} 中有相关代码。
%
%
% \subsection{段落提供的钩子}
% \label{sec:para}
%
%    段落处理已经增加了一些内部和公共钩子。这些内容在 \texttt{ltpara-doc.pdf} 中有详细记录，或者在 \texttt{ltpara-code.pdf} 中有相关代码。
%
%
%
% \subsection{NFSS 命令提供的钩子}
%
%    对于需要同时支持多个脚本（因此有几套字体，例如支持拉丁字体和日文字体）的语言，NFSS 字体命令如 \cs{sffamily} 需要同时切换拉丁字体为 “Sans Serif”，并且额外修改第二套字体。
%
%    为了支持这一点，几个 NFSS 命令都有钩子来添加这种支持。
%    \begin{description}
%
%    \item[\hook{rmfamily}]
%
%      在 \cs{rmfamily} 执行了其初始检查并准备字体系列更新后，此钩子在 \cs{selectfont} 之前执行。
%
%    \item[\hook{sffamily}]
%
%      这类似于 \hook{rmfamily} 钩子，但用于 \cs{sffamily} 命令。
%
%    \item[\hook{ttfamily}]
%
%      这类似于 \hook{rmfamily} 钩子，但用于 \cs{ttfamily} 命令。
%
%    \item[\hook{normalfont}]
%
%      \cs{normalfont} 命令将字体编码、系列和形状重置为文档默认值。然后执行此钩子，最后调用 \cs{selectfont}。
%
%    \item[\hook{expand@font@defaults}]
%
%      内部命令 \cs{expand@font@defaults} 展开并保存当前的元系列（rm/sf/tt）和元系列（bf/md）的默认值。如果为了中文或日文等增加了 NFSS 机制，则可能需要在此时设置进一步的默认值。这可以在此钩子中完成，在此宏的末尾执行。
%
%    \item[\hook{bfseries/defaults}, \hook{bfseries}]
%
%      如果用户显式更改了 \cs{bfdefault} 的值，则在调用 \cs{bfseries} 时将其新值用于设置元系列（rm/sf/tt）的 bf 系列默认值。在这种情况下，\hook{bfseries/defaults} 钩子允许进一步进行调整。如果检测到这样的更改，则仅执行此钩子。相反，\hook{bfseries} 钩子总是在调用 \cs{selectfont} 以更改新系列之前执行。
%
%
%    \item[\hook{mdseries/defaults}, \hook{mdseries}]
%
%       这两个钩子与上面的类似，但是在 \cs{mdseries} 命令中。
%
%    \item[\hook{selectfont}]
%
%      此钩子在 \cs{selectfont} 内执行，用于评估当前的编码、系列、形状和大小，并选择新的字体（如果必要则加载）。在此钩子执行后，NFSS 仍会执行任何必要的更新以适应新的大小（例如更改 \cs{strut} 的大小）和更改编码。
%
%      此钩子用于在主要字体更改的同时，处理其他字体的情况（例如在处理多种不同字母表的 CJK 处理中）。
%
%    \end{description}
%
%
%
% \subsection{标记机制提供的钩子}
%
%    详细内容请参阅 \texttt{ltmarks-doc.pdf}。
%    \begin{description}
%
%    \item[\hook{insertmark}]
%
%      此钩子允许在 \cs{InsertMark} 插入标记时进行特殊设置。它在分组中执行，因此局部更改仅适用于被插入的标记。
%
%    \end{description}
%
% ^^A \MaybeStop{\setlength\IndexMin{200pt}  \PrintIndex  }
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{代码实现}
%
%
%    \begin{macrocode}
%<@@=hook>
%    \end{macrocode}
%
% \changes{v1.0i}{2021/03/18}{使用 \cs{NewModuleRelease}。}
% \changes{v1.0n}{2021/05/24}{使用 \cs{msg_...} 而不是 \cs{__kernel_msg...}}
%
%    \begin{macrocode}
%<*2ekernel|latexrelease>
\ExplSyntaxOn
%<latexrelease>\NewModuleRelease{2020/10/01}{lthooks}
%<latexrelease>                 {The~hook~management~system}
%    \end{macrocode}
%
%  \subsection{调试}
%
%  \begin{macro}{\g_@@_debug_bool}
%    保持当前调试状态。
%    \begin{macrocode}
\bool_new:N \g_@@_debug_bool
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\hook_debug_on:,\hook_debug_off:}
%  \begin{macro}{\@@_debug:n}
%  \begin{macro}{\@@_debug_gset:}
%    利用重定义 \cs{@@_debug:n} 来打开或关闭调试。
%    \begin{macrocode}
\cs_new_eq:NN \@@_debug:n \use_none:n
\cs_new_protected:Npn \hook_debug_on:
  {
    \bool_gset_true:N \g_@@_debug_bool
    \@@_debug_gset:
  }
\cs_new_protected:Npn \hook_debug_off:
  {
    \bool_gset_false:N \g_@@_debug_bool
    \@@_debug_gset:
  }
\cs_new_protected:Npn \@@_debug_gset:
  {
    \cs_gset_protected:Npx \@@_debug:n ##1
      { \bool_if:NT \g_@@_debug_bool {##1} }
  }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%
%  \subsection{从其他内核模块的内部借用}
%
%
% \begin{macro}[EXP]{\@@_str_compare:nn}
%   Private copy of \cs{__str_if_eq:nn}
% \InternalDetectionOff
%    \begin{macrocode}
\cs_new_eq:NN \@@_str_compare:nn \__str_if_eq:nn
%    \end{macrocode}
% \InternalDetectionOn
% \end{macro}
%
%  \subsection{声明}
%
%  \begin{macro}{\l_@@_tmpa_bool}
%    整个包中都使用的临时布尔值。
%    \begin{macrocode}
\bool_new:N \l_@@_tmpa_bool
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\l_@@_return_tl,\l_@@_tmpa_tl,\l_@@_tmpb_tl}
%    整个包中使用的临时变量。
%    \begin{macrocode}
\tl_new:N \l_@@_return_tl
\tl_new:N \l_@@_tmpa_tl
\tl_new:N \l_@@_tmpb_tl
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\g_@@_all_seq}
%    在一些地方，我们需要所有曾经定义的钩子名称列表，
%    因此我们在这个序列中对它们进行跟踪。
%    \begin{macrocode}
\seq_new:N \g_@@_all_seq
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\l_@@_cur_hook_tl}
%   存储当前正在排序的钩子的名称。
%    \begin{macrocode}
\tl_new:N \l_@@_cur_hook_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_@@_work_prop}
%   一个属性列表，保存正在排序的钩子的
%   \cs[no-index]{g_@@_\meta{hook}_code_prop} 的副本，
%   以便对其进行操作，以免对钩子数据结构造成破坏性影响。
%    \begin{macrocode}
\prop_new:N \l_@@_work_prop
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\g_@@_used_prop}
%    所有接收代码的钩子（用于调试显示）。
%    \begin{macrocode}
\prop_new:N \g_@@_used_prop
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\g_@@_hook_curr_name_tl,\g_@@_name_stack_seq}
%   用于钩子命令的默认标签，并且用一个堆栈来跟踪包中的包。
%    \begin{macrocode}
\tl_new:N \g_@@_hook_curr_name_tl
\seq_new:N \g_@@_name_stack_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tmp:w}
%   通用的临时宏。
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmp:w ?
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\c_@@_empty_tl}
% \begin{macro}{\c_@@_nine_parameters_tl}
%   一个空的记号列表和一个包含九个参数的列表。
% \changes{v1.1a}{2023/04/06}
%         {添加辅助记号列表（hook-args）。}
%    \begin{macrocode}
\tl_const:Nn \c_@@_empty_tl { }
\tl_const:Nn \c_@@_nine_parameters_tl { #1#2#3#4#5#6#7#8#9 }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{
%     \tl_gremove_once:Nx,
%     \tl_show:x,
%     \tl_log:x,
%     \tl_set:Ne,
%     \cs_replacement_spec:c,
%     \prop_put:Nne,
%     \str_count:e
%   }
%   \pkg{expl3}函数的一些变体。
%   \fmiinline{可能应该移到expl3}
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_gremove_once:Nn { Nx }
\cs_generate_variant:Nn \tl_show:n { x }
\cs_generate_variant:Nn \tl_log:n { x }
\cs_generate_variant:Nn \tl_set:Nn { Ne }
\cs_generate_variant:Nn \cs_replacement_spec:N { c }
\cs_generate_variant:Nn \prop_put:Nnn { Nne }
\cs_generate_variant:Nn \str_count:n { e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\s_@@_mark}
%   用于定界参数的扫描标记。
%    \begin{macrocode}
\scan_new:N \s_@@_mark
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_use_none_delimit_by_s_mark:w,
%     \@@_use_i_delimit_by_s_mark:nw
%   }
%   移除直到下一个\cs{s_@@_mark}的记号。
% \changes{v1.1a}{2023/04/06}
%         {使用标准命名方案（hook-args）。}
%    \begin{macrocode}
\cs_new:Npn \@@_use_none_delimit_by_s_mark:w #1 \s_@@_mark { }
\cs_new:Npn \@@_use_i_delimit_by_s_mark:nw #1 #2 \s_@@_mark {#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_set:cn}
%   \pkg{expl3}函数的私有副本。\pkg{l3debug}只会给公共名称添加调试，
%   而不会对这些副本进行调试，所以我们不必在每处都使用\cs{debug_suspend:}
%   和\cs{debug_resume:}。
%
%   像\cs{@@_tl_set:Nn}这样的函数必须被重新定义，而不是复制，因为在
%   \pkg{expl3}中，它们使用\cs[no-index]{__kernel_tl_(g)set:Nx}，
%   这也被\pkg{l3debug}所修补。
% \changes{v1.0h}{2021/01/07}{手动定义一些\pkg{l3tl}命令，以解决
%     \pkg{expl3}的更改}
% \changes{v1.1a}{2023/04/06}
%         {清理未使用的变体（hook-args）。}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_set:cn #1#2
  { \cs_set_nopar:cpx {#1} { \__kernel_exp_not:w {#2} } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gset:Nn,\@@_tl_gset:Nx,
%               \@@_tl_gset:cn,\@@_tl_gset:co,\@@_tl_gset:cx}
%   与上述相同。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gset:Nn #1#2
  { \cs_gset_nopar:Npx #1 { \__kernel_exp_not:w {#2} } }
\cs_new_protected:Npn \@@_tl_gset:Nx #1#2
  { \cs_gset_nopar:Npx #1 {#2} }
\cs_generate_variant:Nn \@@_tl_gset:Nn { c, co }
\cs_generate_variant:Nn \@@_tl_gset:Nx { c }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_tl_gput_right:Nn,
%     \@@_tl_gput_right:Ne,
%     \@@_tl_gput_right:cn,
%   }
%   与上述相同。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gput_right:Nn #1#2
  { \@@_tl_gset:Nx #1 { \__kernel_exp_not:w \exp_after:wN { #1 #2 } } }
\cs_generate_variant:Nn \@@_tl_gput_right:Nn { Ne, cn }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gput_left:Nn}
%   与上述相同。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gput_left:Nn #1#2
  {
    \@@_tl_gset:Nx #1
      { \__kernel_exp_not:w {#2} \__kernel_exp_not:w \exp_after:wN {#1} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gset_eq:NN}
%   与上述相同。
%    \begin{macrocode}
\cs_new_eq:NN \@@_tl_gset_eq:NN \tl_gset_eq:NN
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_tl_gclear:N,\@@_tl_gclear:c}
%   与上述相同。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_tl_gclear:N #1
  { \@@_tl_gset_eq:NN #1 \c_empty_tl }
\cs_generate_variant:Nn \@@_tl_gclear:N { c }
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{提供新的钩子}
%
% \subsubsection{钩子的数据结构}
%
% \DescribeMacro{\g_@@_\meta{hook}_code_prop}
% \DescribeMacro{\@@\textvisiblespace\meta{hook}}
% \DescribeMacro{\g_@@_\meta{hook}_reversed_tl}
% \DescribeMacro{\g_@@_\meta{hook}_declared_tl}
% \DescribeMacro{\g_@@_\meta{hook}_parameter_tl}
% \DescribeMacro{\@@_next\textvisiblespace\meta{hook}}
% \DescribeMacro{\@@_toplevel\textvisiblespace\meta{hook}}
%    钩子有一个名称（在下面的描述中称为\meta{hook}），对于每个钩子，我们必须提供一些数据结构。这些包括：
%
%    \begin{description}
%    \item[\cs{g_@@_\meta{hook}_code_prop}] 一个属性列表，保存钩子的代码，分开存储。
%    键默认为添加代码的包名称，但包可以定义其他键。
%
%    \item[{\cs[no-index]{g_@@_\meta{hook}_rule_\meta{label1}\string|\meta{label2}_tl}}]
%    一个记号列表，保存\meta{hook}中\meta{label1}\hfil\break 和\meta{label2}之间的关系。
%    这些\meta{label}按词法（逆序）排序，以确保两个标签始终指向相同的记号列表。
%    对于全局规则，\meta{hook}名称为\texttt{??}。
%
%    \item[\cs{@@\textvisiblespace\meta{hook}}] 当文档中调用钩子时实际执行的代码存储在这个记号列表中。
%    它是由应用信息的代码块构建而成。
%    这个记号列表命名为这样是为了在钩子内部出现错误时，报告的错误记号列表更短，
%    并且使得在\cs{@@_make_name:n}中规范化钩子名称更简单。
%
%    \item[\cs{g_@@_\meta{hook}_reversed_tl}] 一些钩子是“反转”的。这个记号列表存储了这样的钩子的|-|，以便识别。
%    使用|-|字符是因为$\meta{reversed}1$对于普通钩子是$+1$，对于反转的钩子是$-1$。
%
%    \item[{\cs[no-index]{g_@@_\meta{hook}_declared_tl}}] 这个记号列表作为标记用于正式声明钩子。
%    如果尝试进行另一个声明，则会检查其存在性并引发错误。
%
%    \item[{\cs[no-index]{c_@@_\meta{hook}_parameter_tl}}] 这个记号列表保存已声明钩子的参数文本（它的存在几乎完全与上面的记号列表相交），
%    用于管理带参数的钩子。
%
%    \item[\cs{@@_toplevel\textvisiblespace\meta{hook}}] 这个记号列表存储从用户文档中插入到钩子中的代码，位于|top-level|标签中。
%    这个标签是特殊的，不参与排序。相反，所有代码都被附加到它，并在（如果钩子是反转的，则在）正常的钩子代码之后（或之前）执行，但在|next|代码块之前。
%
%    \item[\cs{@@_next\textvisiblespace\meta{hook}}] 最后，有一些额外的代码（通常为空），用于下一次调用钩子时使用（然后删除）。
%    这可用于在文档内部针对单个情况定义一些特殊行为。
%    这个记号列表遵循与主\cs{@@\textvisiblespace\meta{hook}}记号列表相同的命名方案。
%    它被称为\cs{@@_next\textvisiblespace\meta{hook}}，而不是\cs[no-index]{@@\textvisiblespace next_\meta{hook}}，因为否则名为|next_|\meta{hook}的钩子将与称为\meta{hook}的钩子的下一个代码记号列表冲突。
%
%    \end{description}
%
%
% \subsubsection{关于钩子的存在性}
% \label{sec:existence}
%
%    一个钩子可能处于不同的存在状态。在这里，我们给出了设置钩子的内部命令的概述，并解释了如何区分不同的状态。
%    实际的实现随后在后续的章节中进行。
%
%    我们需要解决的一个问题是，即使代码尚未声明，我们也需要能够向钩子（例如，使用\cs{AddToHook}）添加代码。
%    例如，一个包需要写入另一个包的钩子，但是该包可能不会被加载，或者仅在稍后加载。
%    另一个问题是，大多数钩子（但不是通用钩子）需要进行声明。
%
%    因此，我们区分了以下钩子的状态，由四个不同的测试管理：结构存在（\cs{@@_if_structure_exist:nTF}）、创建（\cs{@@_if_usable:nTF}）、声明（\cs{@@_if_declared:nTF}）和禁用或未禁用（\cs{@@_if_disabled:nTF}）。
%    \begin{description}
%    \setlist[itemize]{leftmargin=5cm,format=\cs}
%    \item[不存在]
%
%       目前对于钩子还一无所知。可以使用\cs{@@_if_structure_exist:nTF}（使用假分支）来检测到此状态。
%       在此状态下，可以声明钩子、禁用钩子、定义规则或向其中添加代码，但无法使用\cs{UseHook}。
%
%    \item[基本数据结构设置]
%
%       当钩子的基本数据结构设置完成时（使用\cs{@@_init_structure:n}），钩子处于此状态。数据结构设置发生在自动进行命令（例如\cs{AddToHook}）使用时，此时钩子处于“不存在”状态。
%       在此状态下，四个测试的结果如下：
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      返回 |true|。
%       \item [@@_if_usable:nTF]   返回 |false|。
%       \item [@@_if_declared:nTF]  返回 |false|。
%       \item [@@_if_disabled:nTF]  返回 |false|。
%     \end{itemize}
%
%       允许的操作与“不存在”状态下相同。
%
%    \item[已声明]
%
%       当钩子未被禁用且显式声明（例如，使用\cs{NewHook}）时，钩子处于此状态。在此情况下，四个测试的结果如下：
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      返回 |true|。
%       \item [@@_if_usable:nTF]   返回 |true|。
%       \item [@@_if_declared:nTF]  返回 |true|。
%       \item [@@_if_disabled:nTF]  返回 |false|。
%     \end{itemize}
%
%    \item[可用]
%
%       当钩子未被禁用且未显式声明，但仍允许使用（使用\cs{UseHook}或\cs{hook_use:n}）时，钩子处于此状态。此状态仅适用于通用钩子，因为它们无需声明。因此，这样的钩子直接从“不存在”状态转移到“可用”状态，这是因为诸如\cs{AddToHook}之类的声明要添加到钩子数据结构。在此状态下，测试的结果如下：
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      返回 |true|。
%       \item [@@_if_usable:nTF]   返回 |true|。
%       \item [@@_if_declared:nTF]  返回 |false|。
%       \item [@@_if_disabled:nTF]  返回 |false|。
%     \end{itemize}
%
%    \item[禁用]
%
%       任何状态中的通用钩子在使用\cs{DisableGenericHook}后移动到此状态。这会改变测试的结果如下：
%     \begin{itemize}
%       \item [@@_if_structure_exist:nTF]      \emph{不变}。
%       \item [@@_if_usable:nTF]   返回 |false|。
%       \item [@@_if_declared:nTF]  返回 |true|。
%       \item [@@_if_disabled:nTF]  返回 |true|。
%     \end{itemize}
%       结构测试不变（如果钩子以前未知，则为|false|，否则为|true|）。
%       可用测试返回|false|，因此从现在开始，任何\cs{UseHook}都将跳过该钩子。
%       声明测试返回|true|，因此任何进一步的\cs{NewHook}将生成错误，并且禁用测试返回|true|，以便\cs{AddToHook}可以返回错误。
% \fmiinline{也许它只应该在文档开始后执行？}
%
%    \end{description}
%
%
%
%
% \subsubsection{设置钩子}
%
%  \begin{macro}{
%    \hook_new:n,
%    \hook_new_with_args:nn
%  }
%  \begin{macro}{@@_new:nn}
%    \cs{hook_new:n}声明一个新的钩子，并期望钩子名称\meta{name}作为其参数，例如，
%    \hook{begindocument}.
% \changes{v1.1a}{2023/04/06}
%         {添加\cs{hook_new_with_args:nn}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_new_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_new:n #1
  { \@@_normalize_hook_args:Nn \@@_new:nn {#1} { 0 } }
\cs_new_protected:Npn \hook_new_with_args:nn #1 #2
  { \@@_normalize_hook_args:Nn \@@_new:nn {#1} {#2} }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_new:nn #1 #2
  {
%    \end{macrocode}
%   我们检查钩子是否已经被\emph{显式}使用\cs{hook_new:n}声明过，
%   如果已存在，则发出警告，否则为钩子设置\enquote{created}标志，以便下次使用\cs{hook_new:n}时产生错误。
% \changes{v1.1d}{2023/05/21}
%         {更改以支持cmd钩子中的参数（cmd-args）。}
%    \begin{macrocode}
    \@@_if_declared:nTF {#1}
      { \msg_error:nnn { hooks } { exists } {#1} }
      {
        \tl_new:c { g_@@_#1_declared_tl }
        \cs_undefine:c { @@~#1 }
        \cs_undefine:c { c_@@_#1_parameter_tl }
        \@@_make_usable:nn {#1} {#2}
%    \end{macrocode}
%   如果钩子中已经有代码，但尚未声明，运行\cs{@@_update_hook_code:n}以使其准备好执行（参见测试\texttt{lthooks-034}）。
% \changes{v1.1a}{2023/04/06}
%         {在声明后更新钩子代码。}
%    \begin{macrocode}
        \@@_update_hook_code:n {#1}
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_new_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_new:n #1
%<latexrelease>  { \@@_normalize_hook_args:Nn \@@_new:n {#1} }
%<latexrelease>\cs_undefine:N \@@_new:nn
%<latexrelease>\cs_gset_protected:Npn \@@_new:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_declared:nTF {#1}
%<latexrelease>      { \msg_error:nnn { hooks } { exists } {#1} }
%<latexrelease>      {
%<latexrelease>        \tl_new:c { g_@@_#1_declared_tl }
%<latexrelease>        \@@_make_usable:n {#1}
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \hook_new_with_args:nn #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
%
%  \begin{macro}{\@@_make_usable:nn}
%
%    这为钩子初始化了所有钩子数据结构，但如果单独使用，则不会将钩子标记为已声明（如\cs{hook_new:n}所做的那样，因此后续对该钩子的\cs{hook_new:n}不会导致错误。
%    此命令在向通用钩子添加代码时由\cs{hook_gput_code:nnn}内部使用。
% \changes{v1.1a}{2023/04/06}
%         {更改以添加钩子参数（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_make_usable:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_make_usable:nn #1 #2
  {
%    \end{macrocode}
%   现在我们检查钩子的数据结构是否可以安全地创建，而不会引发\pkg{expl3}的错误，
%   然后将钩子名称添加到所有钩子的列表中，并为新钩子分配必要的数据结构，否则什么也不做。
%    \begin{macrocode}
    \@@_if_usable:nF {#1}
      {
        \seq_gput_right:Nn \g_@@_all_seq {#1}
%    \end{macrocode}
%    在这里，我们将定义\cs[no-index]{c_@@_\meta{hook}_parameter_tl}，
%    以保存参数的一系列直到钩子的参数数量（\verb|#2|）。
%    \begin{macrocode}
        \__kernel_cs_parm_from_arg_count:nnF
          { \tl_const:cn { c_@@_#1_parameter_tl } } {#2}
          {
            \msg_error:nnnn { hooks } { too-many-args } {#1} {#2}
            \tl_const:cx { c_@@_#1_parameter_tl }
              { \exp_not:V \c_@@_nine_parameters_tl }
          }
%    \end{macrocode}
% 在此之后，使用 \cs{@@_normalise_cs_args:nn} 来修正宏的参数数量
% \cs[no-index]{@@_toplevel\textvisiblespace\meta{hook}} 和
% \cs[no-index]{@@_next\textvisiblespace\meta{hook}}。
% 我们需要能够向一个钩子添加带有参数的代码，而不需要提前知道该钩子的参数数量，
% 因此 \pkg{lthooks} 假定为 9，直到该钩子被正确声明并知道参数数量为止。
% \cs{@@_normalise_cs_args:nn} 使用刚刚上面定义的
% \cs[no-index]{c_@@_\meta{hook}_parameter_tl} 进行规范化。
%    \begin{macrocode}
    \@@_normalise_cs_args:nn { _toplevel } {#1}
    \@@_normalise_cs_args:nn { _next } {#1}
%    \end{macrocode}
% 这仅由当前钩子的实际代码使用，因此正常声明它：
%    \begin{macrocode}
    \@@_code_gset:nn {#1} { }
%    \end{macrocode}
% 现在确保钩子的基本数据结构存在：
%    \begin{macrocode}
    \@@_init_structure:n {#1}
%    \end{macrocode}
% 调用 \cs{@@_normalise_code_pool:n} 将纠正对钩子中不存在的参数的引用，
% 引发低级 \TeX{} 错误并使有问题的参数标记翻倍。
% 必须在 \cs{@@_init_structure:n} 之后执行，因为它作用于
% \cs[no-index]{g_@@_\meta{hook}_code_prop}。
%    \begin{macrocode}
    \@@_normalise_code_pool:n {#1}
%    \end{macrocode}
% \cs{g_@@_\meta{hook}_labels_clist} 存储了标签的排序列表（一旦排序）。
% 这仅用于调试。这些是有条件地定义的，以防正在使用 \cs{@@_make_usable:nn}
% 重新定义一个钩子。
% \changes{v1.1d}{2023/05/21}
%         {Changes to allow support arguments in cmd hooks (cmd-args).}
%    \begin{macrocode}
        \clist_if_exist:cF { g_@@_#1_labels_clist }
          {
            \clist_new:c { g_@@_#1_labels_clist }
%    \end{macrocode}
% 一些钩子应该反转代码块的默认顺序。为了表示这一点，我们有一个令牌列表，
% 对于普通钩子为空，对于反转的钩子包含一个 \verb=-=。
%    \begin{macrocode}
    \tl_new:c { g_@@_#1_reversed_tl }
    }
%    \end{macrocode}
% 上述内容都是遵循 L3 规范，但我们还提供了一个接口来处理类似 \LaTeXe{} 旧版钩子的形式，
% 如 \cs{@...hook}，例如 \cs{@begindocumenthook}。
% 有一些这样的钩子，并且它们已经被添加到使用 \cs{g@addto@macro}。
% 如果存在一个与新钩子名称匹配的这样的宏，即 \verb+\@+\meta{hook-name}\texttt{hook}，
% 并且它不为空，则我们将其内容作为代码块添加到标签 \texttt{legacy} 下。
%    \begin{quote}
%       \textbf{警告：这种支持将在未来版本中消失！}
%    \end{quote}
%
%    \begin{macrocode}
        \@@_include_legacy_code_chunk:n {#1}
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_make_usable:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_make_usable:nn
%<latexrelease>\cs_gset_protected:Npn \@@_make_usable:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cF { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \seq_gput_right:Nn \g_@@_all_seq {#1}
%<latexrelease>        \tl_new:c { @@~#1 }
%<latexrelease>        \@@_init_structure:n {#1}
%<latexrelease>        \clist_new:c { g_@@_#1_labels_clist }
%<latexrelease>        \tl_new:c { g_@@_#1_reversed_tl }
%<latexrelease>        \@@_include_legacy_code_chunk:n {#1}
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\@@_init_structure:n}
% 这个函数声明了一个钩子的基本数据结构，而不是显式地声明钩子本身。
% 这是为了允许向未声明的钩子添加内容。在这里，不需要检查所有变量是否存在，
% 因为所有三个变量同时被声明（它们要么都存在，要么都不存在）。
%
% 它创建了钩子代码池（\cs[no-index]{g_@@_\meta{hook}_code_prop}），
% 以及 |top-level| 和 |next| 令牌列表。
% 第一次向钩子添加内容时，使用 \cs{@@_init_structure:n} 对钩子进行初始化。
% 只使用 \cs{@@_init_structure:n} 初始化钩子并不能使其能够被 \cs{hook_use:n} 使用。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_init_structure:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_init_structure:n #1
  {
    \@@_if_structure_exist:nF {#1}
      {
        \prop_new:c { g_@@_#1_code_prop }
        \@@_toplevel_gset:nn {#1} { }
        \@@_next_gset:nn {#1} { }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_init_structure:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_init_structure:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_structure_exist:nF {#1}
%<latexrelease>      {
%<latexrelease>        \prop_new:c { g_@@_#1_code_prop }
%<latexrelease>        \tl_new:c { @@_toplevel~#1 }
%<latexrelease>        \tl_new:c { @@_next~#1 }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{
%    \hook_new_reversed:n,
%    \hook_new_reversed_with_args:nn
%  }
%  \begin{macro}{\@@_new_reversed:nn}
%
% 声明一个新的钩子。代码块的默认顺序是反向的，通过将令牌列表设置为减号来表示。
% \changes{v1.1a}{2023/04/06}
%         {添加 \cs{hook_new_reversed_with_args:nn}（hook-args）}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_new_reversed_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_new_reversed:n #1
  { \@@_normalize_hook_args:Nn \@@_new_reversed:nn {#1} { 0 } }
\cs_new_protected:Npn \hook_new_reversed_with_args:nn #1 #2
  { \@@_normalize_hook_args:Nn \@@_new_reversed:nn {#1} {#2} }
\cs_new_protected:Npn \@@_new_reversed:nn #1 #2
  {
    \@@_if_declared:nTF {#1}
      { \msg_error:nnn { hooks } { exists } {#1} }
      {
        \@@_new:nn {#1} {#2}
        \tl_gset:cn { g_@@_#1_reversed_tl } { - }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_new_reversed_with_args:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_new_reversed:n #1
%<latexrelease>  { \@@_normalize_hook_args:Nn \@@_new_reversed:n {#1} }
%<latexrelease>\cs_undefine:N \@@_new_reversed:nn
%<latexrelease>\cs_gset_protected:Npn \@@_new_reversed:n #1
%<latexrelease>  {
%<latexrelease>    \@@_new:n {#1}
%<latexrelease>    \tl_gset:cn { g_@@_#1_reversed_tl } { - }
%<latexrelease>  }
%<latexrelease>\cs_undefine:N \@@_new_reversed:nn
%<latexrelease>\cs_gset_protected:Npn \hook_new_reversed_with_args:nn #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\hook_new_pair:nn,\hook_new_pair_with_args:nnn}
% 一种一次性声明普通和（匹配的）反向钩子的简写方式。
% \changes{v1.1a}{2023/04/06}
%         {添加 \cs{hook_new_pair_with_args:nnn}（hook-args）}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_new_pair_with_args:nnn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_new_pair:nn #1#2
  { \@@_normalize_hook_args:Nnn \@@_new_pair:nnn {#1} {#2} { 0 } }
\cs_new_protected:Npn \hook_new_pair_with_args:nnn #1#2#3
  { \@@_normalize_hook_args:Nnn \@@_new_pair:nnn {#1} {#2} {#3} }
\cs_new_protected:Npn \@@_new_pair:nnn #1 #2 #3
  {
    \@@_if_declared:nTF {#1}
      { \msg_error:nnn { hooks } { exists } {#1} }
      {
        \@@_if_declared:nTF {#2}
          { \msg_error:nnn { hooks } { exists } {#2} }
          {
            \@@_new:nn {#1} {#3}
            \@@_new_reversed:nn {#2} {#3}
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_new_pair_with_args:nnn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_new_pair:nn #1#2
%<latexrelease>  {
%<latexrelease>    \hook_new:n {#1}
%<latexrelease>    \hook_new_reversed:n {#2}
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \hook_new_pair_with_args:nnn #1#2#3
%<latexrelease>  { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{\@@_include_legacy_code_chunk:n}
% \LaTeX{} 遗留钩子的概念在代码中使用以下命名方案：\cs{@...hook}。
%
% 如果此宏不为空，我们将其添加到当前钩子的标签 \texttt{legacy} 下，
% 然后在全局范围内将其清空。这样，直接操作诸如 \cs{@begindocumenthook} 等命令的包或类
% 仍然可以添加其钩子数据。
% \begin{quote}
%    \textbf{警告：这种支持将在未来版本中消失！}
% \end{quote}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_include_legacy_code_chunk:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_include_legacy_code_chunk:n #1
  {
%    \end{macrocode}
%    如果宏不存在（通常情况下是这样），则不需要进行任何操作。
%    \begin{macrocode}
    \tl_if_exist:cT { @#1hook }
      {
%    \end{macrocode}
%    当然，如果遗留钩子存在但为空，就没有必要在遗留标签下添加任何内容。
%    \begin{macrocode}
        \tl_if_empty:cF { @#1hook }
          {
%    \end{macrocode}
%    在这里，我们设置 \cs{@@_replacing_args_false:}，因为没有遗留代码会引用钩子参数。
%    \changes{v1.1b}{2023/04/16}
%            {\cs{@@_replacing_args_false:} 在 \cs{@@_include_legacy_code_chunk:n} 中。}
%    \begin{macrocode}
            \@@_replacing_args_false:
            \use:e
              {
                \@@_hook_gput_code_do:nnn {#1} { legacy }
                  { \exp_not:v { @#1hook } }
              }
            \@@_replacing_args_reset:
%    \end{macrocode}
%    添加到钩子后，我们需要将其清除，否则如果钩子数据更新，可能会在以后再次添加。
%    \begin{macrocode}
            \@@_tl_gclear:c { @#1hook }
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_include_legacy_code_chunk:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_include_legacy_code_chunk:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cT { @#1hook }
%<latexrelease>      {
%<latexrelease>        \tl_if_empty:cF { @#1hook }
%<latexrelease>          {
%<latexrelease>            \exp_args:Nnnv \@@_hook_gput_code_do:nnn
%<latexrelease>              {#1} { legacy } { @#1hook }
%<latexrelease>            \@@_tl_gclear:c { @#1hook }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{禁用和提供钩子}
%
% \changes{v1.0p}{2021/08/20}{通用钩子命令的重命名（gh/638）}
%
% \begin{macro}{\hook_disable_generic:n}
% \begin{macro}{\@@_disable:n}
% \begin{macro}[pTF]{\@@_if_disabled:n}
%
%    通过创建其 \cs[no-index]{g_@@_\meta{hook}_declared_tl} 来禁用一个钩子，
%    以便在使用 \cs{hook_new:n} 时出错，然后取消定义 \cs{@@\textvisiblespace\meta{hook}}，
%    以防止其执行。
%
%    这并不清除可能已经存储在钩子结构中的任何代码，但不允许添加更多代码。
%    \cs{@@_if_disabled:nTF} 使用该特定组合来检查钩子是否已禁用。
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\hook_disable_generic:n}
%<latexrelease>                 {Disable~hooks}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \hook_disable_generic:n #1
  { \@@_normalize_hook_args:Nn \@@_disable:n {#1} }
\cs_new_protected:Npn \@@_disable:n #1
  {
    \tl_gclear_new:c { g_@@_#1_declared_tl }
    \cs_undefine:c { @@~#1 }
  }
\prg_new_conditional:Npnn \@@_if_disabled:n #1 { p, T, F, TF }
  {
    \bool_lazy_and:nnTF
        { \tl_if_exist_p:c { g_@@_#1_declared_tl } }
        { ! \cs_if_exist_p:c { @@~#1 } }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_disable_generic:n}
%<latexrelease>                 {Disable~hooks}
%<latexrelease>
%<latexrelease>\cs_new_protected:Npn \hook_disable_generic:n #1 {}
%<latexrelease>
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hook_activate_generic:n}
% \begin{macro}{\@@_activate_generic:n}
%    \cs{hook_activate_generic:n} 声明了一个新的钩子，如果它还没有被声明的话，
%    此时它仅检查已经存在的钩子是否不是一个反向钩子。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_activate_generic:n}
%<latexrelease>                 {Providing~hooks}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \hook_activate_generic:n #1
  { \@@_normalize_hook_args:Nn \@@_activate_generic:nn {#1} {   } }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_activate_generic:nn #1 #2
  {
%    \end{macrocode}
%    如果要激活的钩子已被禁用，我们发出警告（目前是这样的 --- 这可能会改变）。
%    \begin{macrocode}
    \@@_if_disabled:nTF {#1}
      { \msg_warning:nnn { hooks } { activate-disabled } {#1} }
%    \end{macrocode}
%    否则，我们检查钩子是否未被声明，如果是，则确定它是反向的还是非反向的，然后相应地进行声明。
%    \begin{macrocode}
      {
        \@@_if_declared:nF {#1}
          {
            \tl_new:c { g_@@_#1_declared_tl }
            \@@_make_usable:nn {#1} { 0 }
            \tl_gset:cx { g_@@_#1_reversed_tl }
              { \@@_if_generic_reversed:nT {#1} { - } }
%    \end{macrocode}
%    反映我们已激活通用钩子并设置其执行代码。
% \changes{v1.0v}{2022/06/15}{确保新激活的通用钩子得到其执行代码的设置}
%    \begin{macrocode}
            \@@_update_hook_code:n {#1}
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\hook_activate_generic:n}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\cs_gset_protected:Npn \@@_activate_generic:nn #1 #2
%<latexrelease>  {
%<latexrelease>    \@@_if_disabled:nTF {#1}
%<latexrelease>      { \msg_warning:nnn { hooks } { activate-disabled } {#1} }
%<latexrelease>      {
%<latexrelease>        \@@_if_declared:nF {#1}
%<latexrelease>          {
%<latexrelease>            \tl_new:c { g_@@_#1_declared_tl }
%<latexrelease>            \@@_make_usable:n {#1}
%<latexrelease>            \tl_gset:cx { g_@@_#1_reversed_tl }
%<latexrelease>              { \@@_if_generic_reversed:nT {#1} { - } }
%<latexrelease>            \@@_update_hook_code:n {#1}
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_activate_generic:n}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\cs_gset_protected:Npn \hook_activate_generic:n #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{解析标签}
%
% \begin{macro}[EXP]{\@@_parse_label_default:n}
%   此宏检查是否提供了标签（不是 \cs{c_novalue_tl}），如果提供了标签，
%   则尝试解析标签以查找一个前导的 \verb|.|，将其替换为 \cs{@@_currname_or_default:}。
%    \begin{macrocode}
\cs_new:Npn \@@_parse_label_default:n #1
  {
    \tl_if_novalue:nTF {#1}
      { \@@_currname_or_default: }
      { \tl_trim_spaces_apply:nN {#1} \@@_parse_dot_label:n }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_parse_dot_label:n}
% \begin{macro}[EXP]{
%     \@@_parse_dot_label:w,
%     \@@_parse_dot_label_cleanup:w,
%     \@@_parse_dot_label_aux:w
%   }
%   首先检查标签是否为空，如果为空则引发错误，并使用回退值。如果不为空，
%   在可能的情况下将标签分割为 \verb|./|，并检查在 \verb|./| 前是否没有任何标记，
%   或者前面的唯一字符是 \verb|.|。
%   如果满足这些要求，则将前导的 \verb|.| 替换为 \cs{@@_currname_or_default:}。
%   否则，将标签不变地返回。
%    \begin{macrocode}
\cs_new:Npn \@@_parse_dot_label:n #1
  {
    \tl_if_empty:nTF {#1}
      {
        \msg_expandable_error:nn { hooks } { empty-label }
        \@@_currname_or_default:
      }
      {
        \str_if_eq:nnTF {#1} { . }
          { \@@_currname_or_default: }
          { \@@_parse_dot_label:w #1 ./ \s_@@_mark }
      }
  }
\cs_new:Npn \@@_parse_dot_label:w #1 ./ #2 \s_@@_mark
  {
    \tl_if_empty:nTF {#1}
      { \@@_parse_dot_label_aux:w #2 \s_@@_mark }
      {
        \tl_if_empty:nTF {#2}
          { \@@_make_name:n {#1} }
          { \@@_parse_dot_label_cleanup:w #1 ./ #2 \s_@@_mark }
      }
  }
\cs_new:Npn \@@_parse_dot_label_cleanup:w #1 ./ \s_@@_mark {#1}
\cs_new:Npn \@@_parse_dot_label_aux:w #1 ./ \s_@@_mark
  { \@@_currname_or_default: / \@@_make_name:n {#1} }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_currname_or_default:}
%   如果设置了 \cs{g_@@_hook_curr_name_tl}，则使用它；否则尝试使用 \cs{@currname}。
%   如果两者都没有设置，则引发错误并使用回退值 \verb|label-missing|。
%    \begin{macrocode}
\cs_new:Npn \@@_currname_or_default:
  {
    \tl_if_empty:NTF \g_@@_hook_curr_name_tl
      {
        \tl_if_empty:NTF \@currname
          {
            \msg_expandable_error:nnn { latex2e } { should-not-happen }
              { Empty~default~label. }
            \@@_make_name:n { label-missing }
          }
          { \@currname }
      }
      { \g_@@_hook_curr_name_tl }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_make_name:n,\@@_make_name:w}
%   这提供了钩子名称的标准清理。
%   它使用 \cs{cs:w} 构建钩子名称的控制序列，
%   然后使用 \cs{cs_to_str:N} 获取其字符串表示，不包括转义字符。
%   使用 \cs{cs:w} 的扩展方式，而不是 |e| 的方式，
%   因为 Unicode 字符在 \cs{expanded} 内部的行为不佳。
%   该宏将 \cs[no-index]{@@\textvisiblespace} 前缀添加到钩子名称，
%   以重用钩子的代码标记列表来构建控制序列，并避免在 TeX 内存中留下 \enquote{公共} 控制序列（如~\cs[no-index]{relax}）。
%    \begin{macrocode}
\cs_new:Npn \@@_make_name:n #1
  {
    \exp_after:wN \exp_after:wN \exp_after:wN \@@_make_name:w
    \exp_after:wN \token_to_str:N \cs:w @@~ #1 \cs_end:
  }
\exp_last_unbraced:NNNNo
\cs_new:Npn \@@_make_name:w #1 \tl_to_str:n { @@~ } { }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_normalize_hook_args:Nn}
% \begin{macro}{\@@_normalize_hook_args:Nnn}
% \begin{macro}{\@@_normalize_hook_rule_args:Nnnnn}
% \begin{macro}{\@@_normalize_hook_args_aux:Nn}
%   这是规范化钩子和标签参数的标准途径。主要宏在一个组内执行整个操作，
%   这样通过 \cs{@@_make_name:n} 创建的控制序列在继续之前会被清除。
%   这意味着此函数不能用于 \cs{hook_use:n}！
%    \begin{macrocode}
\cs_new_protected:Npn \@@_normalize_hook_args_aux:Nn #1 #2
  {
    \group_begin:
    \use:e
      {
        \group_end:
        \exp_not:N #1 #2
      }
  }
\cs_new_protected:Npn \@@_normalize_hook_args:Nn #1 #2
  {
    \@@_normalize_hook_args_aux:Nn #1
      { { \@@_parse_label_default:n {#2} } }
  }
\cs_new_protected:Npn \@@_normalize_hook_args:Nnn #1 #2 #3
  {
    \@@_normalize_hook_args_aux:Nn #1
      {
        { \@@_parse_label_default:n {#2} }
        { \@@_parse_label_default:n {#3} }
      }
  }
\cs_new_protected:Npn \@@_normalize_hook_rule_args:Nnnnn #1 #2 #3 #4 #5
  {
    \@@_normalize_hook_args_aux:Nn #1
      {
        { \@@_parse_label_default:n {#2} }
        { \@@_parse_label_default:n {#3} }
        { \tl_trim_spaces:n {#4} }
        { \@@_parse_label_default:n {#5} }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_curr_name_push:n,\@@_curr_name_push_aux:n}
% \begin{macro}{\@@_curr_name_pop:}
% \begin{macro}{\@@_end_document_label_check:}
%   符号列表 \cs{g_@@_hook_curr_name_tl} 存储当前要用作钩子默认标签的包名/文件名。
%   提供一致的接口很棘手，因为包可以在包中加载，并且一些包可能不使用 \cs{SetDefaultHookLabel} 来更改默认标签（这种情况下使用 \cs{@currname}）。
%
%   为了实现这一点，我们保持一个堆栈，其中包含每个输入级别的默认标签。
%   堆栈底部包含 |top-level| 的默认标签（此堆栈不应为空）。如果正在构建格式，则将默认标签设置为 |top-level|：
%    \begin{macrocode}
\tl_gset:Nn \g_@@_hook_curr_name_tl { top-level }
%    \end{macrocode}
%
%   然后，在我们位于 \pkg{latexrelease} 中的情况下，我们在堆栈上推送一些内容以支持向前滚动。
%   但在一些罕见的情况下，\pkg{latexrelease} 可能会在另一个包中加载（尤其是 \pkg{platexrelease}），
%   因此我们首先推送 |top-level| 条目：
%   \changes{v1.0i}{2021/03/18}
%           {仅在不存在时添加 \texttt{top-level}。}
%    \begin{macrocode}
%<latexrelease>\seq_if_empty:NT \g_@@_name_stack_seq
%<latexrelease>  { \seq_gput_right:Nn \g_@@_name_stack_seq { top-level } }
%    \end{macrocode}
%   然后我们分析 \cs{@currnamestack}，将 \cs{@currname} 添加到堆栈：
% \changes{v1.0f}{2020/11/24}{支持向前滚动（gh/434）}
%    \begin{macrocode}
%<latexrelease>\cs_set_protected:Npn \@@_tmp:w #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \quark_if_recursion_tail_stop:n {#1}
%<latexrelease>    \seq_gput_right:Nn \g_@@_name_stack_seq {#1}
%<latexrelease>    \@@_tmp:w
%<latexrelease>  }
%<latexrelease>\exp_after:wN \@@_tmp:w \@currnamestack
%<latexrelease>  \q_recursion_tail \q_recursion_tail
%<latexrelease>  \q_recursion_tail \q_recursion_stop
%    \end{macrocode}
%   最后将默认标签设置为 \cs{@currname}：
%   \changes{v1.0i}{2021/03/18}
%           {从 \cs{@currnamestack} 中删除（空的） \enquote{top-level}。}
%    \begin{macrocode}
%<latexrelease>\tl_gset:Nx \g_@@_hook_curr_name_tl { \@currname }
%<latexrelease>\seq_gpop_right:NN \g_@@_name_stack_seq \l_@@_tmpa_tl
%    \end{macrocode}
%
%   有两个命令来跟踪堆栈：当输入文件时，
%   \cs{@@_curr_name_push:n} 将当前默认标签推送到堆栈上并设置新的默认标签（一次完成所有操作）：
%    \begin{macrocode}
\cs_new_protected:Npn \@@_curr_name_push:n #1
  { \exp_args:Nx \@@_curr_name_push_aux:n { \@@_make_name:n {#1} } }
\cs_new_protected:Npn \@@_curr_name_push_aux:n #1
  {
    \tl_if_blank:nTF {#1}
      { \msg_error:nn { hooks } { no-default-label } }
      {
        \str_if_eq:nnTF {#1} { top-level }
          {
            \msg_error:nnnnn { hooks } { set-top-level }
              { to } { PushDefaultHookLabel } {#1}
          }
          {
            \seq_gpush:NV \g_@@_name_stack_seq \g_@@_hook_curr_name_tl
            \tl_gset:Nn \g_@@_hook_curr_name_tl {#1}
          }
      }
  }
%    \end{macrocode}
%   当输入结束时，堆栈的顶部项目将被弹出，因为该标签将不再使用，并且 \cs{g_@@_hook_curr_name_tl} 被更新为现在堆栈的顶部项目：
%    \begin{macrocode}
\cs_new_protected:Npn \@@_curr_name_pop:
  {
    \seq_gpop:NNTF \g_@@_name_stack_seq \l_@@_return_tl
      { \tl_gset_eq:NN \g_@@_hook_curr_name_tl \l_@@_return_tl }
      { \msg_error:nn { hooks } { extra-pop-label } }
  }
%    \end{macrocode}
%
%   在文档结束时，我们想要检查是否有没有匹配的 \cs{@@_curr_name_push:n} 和 \cs{@@_curr_name_pop:}（这不是一个关键错误，但可能表明其他地方存在问题）：
%    \begin{macrocode}
\tl_gput_right:Nn \@kernel@after@enddocument@afterlastpage
  { \@@_end_document_label_check: }
\cs_new_protected:Npn \@@_end_document_label_check:
  {
    \seq_gpop:NNT \g_@@_name_stack_seq \l_@@_return_tl
      {
        \msg_error:nnx { hooks } { missing-pop-label }
          { \g_@@_hook_curr_name_tl }
        \tl_gset_eq:NN \g_@@_hook_curr_name_tl \l_@@_return_tl
        \@@_end_document_label_check:
      }
  }
%    \end{macrocode}
%
%   符号列表 \cs{g_@@_hook_curr_name_tl} 仅是堆栈顶部的镜像。
%
% \begin{macro}{\@@_set_default_hook_label:n,\@@_set_default_label:n}
%   现在定义一个包装器，用参数替换堆栈的顶部项目，并相应地更新 \cs{g_@@_hook_curr_name_tl}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_default_hook_label:n #1
  {
    \seq_if_empty:NTF \g_@@_name_stack_seq
      {
        \msg_error:nnnnn { hooks } { set-top-level }
          { for } { SetDefaultHookLabel } {#1}
      }
      { \exp_args:Nx \@@_set_default_label:n { \@@_make_name:n {#1} } }
  }
\cs_new_protected:Npn \@@_set_default_label:n #1
  {
    \str_if_eq:nnTF {#1} { top-level }
      {
        \msg_error:nnnnn { hooks } { set-top-level }
          { to } { SetDefaultHookLabel } {#1}
      }
      { \tl_gset:Nn \g_@@_hook_curr_name_tl {#1} }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{添加或移除钩子代码}
%
% \begin{macro}{\hook_gput_code:nnn,\hook_gput_code_with_args:nnn}
% \begin{macro}{
%     \@@_gput_code:nnn,
%     \@@_gput_code_store:nnn,
%     \@@_hook_gput_code_do:nnn,
%     \@@_prop_gput_labeled_cleanup:nnn,
%     \@@_prop_gput_labeled_do:Nnnn
%    }
%
%    使用 \cs{hook_gput_code:nnn}\Arg{hook}\Arg{label}\Arg{code}，
%    将一段 \meta{code} 添加到已存在的带有 \meta{label} 标签的 \meta{hook} 中。
% \changes{v1.0o}{2021/07/22}{不要排队移除（gh/625）}
% \changes{v1.1a}{2023/04/06}
%         {添加 \cs{hook_gput_code_with_args:nnn}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_gput_code:nnn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_gput_code:nnn #1 #2 #3
  {
    \@@_replacing_args_false:
    \@@_normalize_hook_args:Nnn \@@_gput_code:nnn {#1} {#2} {#3}
    \@@_replacing_args_reset:
  }
\cs_new_protected:Npn \hook_gput_code_with_args:nnn #1 #2 #3
  {
    \@@_replacing_args_true:
    \@@_normalize_hook_args:Nnn \@@_gput_code:nnn {#1} {#2} {#3}
    \@@_replacing_args_reset:
  }
%    \end{macrocode}
%
% 如果使用了 \cs{AddToHookWithArguments}，进行一些合理性检查，如果此时不能使用参数，
% 通过使用 \cs{@@_replacing_args_false:} 回退到常规的 \cs{AddToHook}。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_code:nnn #1 #2 #3
  {
    \@@_chk_args_allowed:nn {#1} { AddToHook }
%    \end{macrocode}
%   然后检查代码是否应立即执行，而不是存储：
% \changes{v1.0r}{2021/09/06}{使用专用条件（gh/606）}
%    \begin{macrocode}
    \@@_if_execute_immediately:nTF {#1}
      {
%    \end{macrocode}
%   \cs{AddToHookWithArguments} 不能用于一次性钩子（已经使用过的）。
%    \begin{macrocode}
        \@@_if_replacing_args:TF
          {
            \msg_error:nnnn { hooks } { one-time-args }
              {#1} { AddToHook }
          }
          { }
        \use:n
      }
      { \@@_gput_code_store:nnn {#1} {#2} }
          {#3}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_code_store:nnn #1 #2 #3
  {
%    \end{macrocode}
%    然后检查钩子是否可用。
%    \begin{macrocode}
    \@@_if_usable:nTF {#1}
%    \end{macrocode}
%    如果可用，我们只需将新代码添加（或附加）到保存钩子不同代码块的属性列表中。
%    在 \verb=\begin{document}= 时，这些代码将被排序到一个令牌列表中以便快速执行。
%    \begin{macrocode}
      {
        \@@_hook_gput_code_do:nnn {#1} {#2} {#3}
%    \end{macrocode}
%    但是，如果文档中有更新，我们需要修改此执行代码，这通过 \cs{@@_update_hook_code:n} 完成。
%    在导言部分，这将不起作用。
%    \begin{macrocode}
        \@@_update_hook_code:n {#1}
      }
%    \end{macrocode}
%
%    如果钩子不可用，在放弃之前，检查它是否未禁用，否则尝试将其声明为通用钩子，如果其名称匹配有效模式之一。
%    \begin{macrocode}
      {
        \@@_if_disabled:nTF {#1}
          { \msg_error:nnn { hooks } { hook-disabled } {#1} }
          { \@@_try_declaring_generic_hook:nnn {#1} {#2} {#3} }
      }
  }
%    \end{macrocode}
%
%    此宏将无条件地向给定的钩子添加一段代码。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）。}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_hook_gput_code_do:nnn #1 #2 #3
  {
%    \end{macrocode}
%    但首先，如果启用了调试功能，显示一些调试信息：
%    \begin{macrocode}
    \@@_debug:n{\iow_term:x{****~ Add~ to~
                      \@@_if_usable:nF {#1} { undeclared~ }
                      hook~ #1~ (#2)
                      \on@line\space <-~ \tl_to_str:n{#3}} }
%    \end{macrocode}
%    然后尝试从钩子中获取标记为 \verb=#2= 的代码块。
%    如果已经有代码存在，那么将 \verb=#3= 附加到其中，否则只是放置 \verb=#3=。
%    如果当前标签为 |top-level|，则代码将被添加到一个专用的令牌列表 \cs{@@_toplevel\textvisiblespace\meta{hook}} 中，
%    该列表位于钩子的末尾（或者对于反向钩子，位于开头），就在 \cs[no-index]{@@_next\textvisiblespace\meta{hook}} 之前。
%    \begin{macrocode}
    \str_if_eq:nnTF {#2} { top-level }
      {
        \str_if_eq:eeTF { top-level } { \@@_currname_or_default: }
          {
%    \end{macrocode}
%   如果钩子的基本结构不存在，则需要用 \cs{@@_init_structure:n} 声明它。
%    \begin{macrocode}
            \@@_init_structure:n {#1}
%    \end{macrocode}
%   然后将其附加到钩子的 \verb|_toplevel| 容器中。
%    \begin{macrocode}
            \@@_cs_gput_right:nnn { _toplevel } {#1} {#3}
          }
          { \msg_error:nnn { hooks } { misused-top-level } {#1} }
      }
      {
%    \end{macrocode}
%   在添加到代码池时，如果使用了 \cs{AddToHook}（\verb|replacing_args| 为 false），我们必须双重哈希，
%   这样以后它会变成一个单参数令牌，而不是钩子宏的参数。
%    \begin{macrocode}
        \exp_args:Nx \@@_prop_gput_labeled_cleanup:nnn
          {
            \@@_if_replacing_args:TF
              { \exp_not:n }
              { \@@_double_hashes:n }
                {#3}
          }
          {#1} {#2}
      }
  }
%    \end{macrocode}
%
%   向钩子的代码池中添加代码。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_prop_gput_labeled_cleanup:nnn #1 #2 #3
  {
    \tl_set:Nn \l_@@_return_tl {#1}
    \@@_if_replacing_args:TF
      {
        \@@_if_usable:nT {#2}
          {
            \@@_set_normalise_fn:nn {#2}
              { Invalid~code~added~\msg_line_context: }
            \@@_normalise_fn:nn {#3} {#1}
            \prop_get:NnN \l_@@_work_prop {#3} \l_@@_return_tl
          }
      }
      { }
    \exp_args:NcV \@@_prop_gput_labeled_do:Nnn
      { g_@@_#2_code_prop } \l_@@_return_tl {#3}
  }
\cs_new_protected:Npn \@@_prop_gput_labeled_do:Nnn #1 #2 #3
  {
    \prop_get:NnNTF #1 {#3} \l_@@_return_tl
      { \prop_gput:Nno #1 {#3} { \l_@@_return_tl #2 } }
      { \prop_gput:Nnn #1 {#3} {#2} }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_gput_code:nnn}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\cs_gset_protected:Npn \hook_gput_code:nnn #1 #2
%<latexrelease>  { \@@_normalize_hook_args:Nnn \@@_gput_code:nnn {#1} {#2} }
%<latexrelease>\cs_gset_protected:Npn \@@_gput_code:nnn #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \@@_if_execute_immediately:nTF {#1}
%<latexrelease>      {#3}
%<latexrelease>      {
%<latexrelease>        \@@_if_usable:nTF {#1}
%<latexrelease>          {
%<latexrelease>            \@@_hook_gput_code_do:nnn {#1} {#2} {#3}
%<latexrelease>            \@@_update_hook_code:n {#1}
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \@@_if_disabled:nTF {#1}
%<latexrelease>              { \msg_error:nnn { hooks } { hook-disabled } {#1} }
%<latexrelease>              { \@@_try_declaring_generic_hook:nnn {#1} {#2} {#3} }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \@@_hook_gput_code_do:nnn #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \@@_debug:n{\iow_term:x{****~ Add~ to~
%<latexrelease>                      \@@_if_usable:nF {#1} { undeclared~ }
%<latexrelease>                      hook~ #1~ (#2)
%<latexrelease>                      \on@line\space <-~ \tl_to_str:n{#3}} }
%<latexrelease>    \str_if_eq:nnTF {#2} { top-level }
%<latexrelease>      {
%<latexrelease>        \str_if_eq:eeTF { top-level } { \@@_currname_or_default: }
%<latexrelease>          {
%<latexrelease>            \@@_init_structure:n {#1}
%<latexrelease>            \@@_tl_gput_right:cn { @@_toplevel~#1 } {#3}
%<latexrelease>          }
%<latexrelease>          { \msg_error:nnn { hooks } { misused-top-level } {#1} }
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \prop_get:cnNTF { g_@@_#1_code_prop } {#2} \l_@@_return_tl
%<latexrelease>          {
%<latexrelease>            \prop_gput:cno { g_@@_#1_code_prop } {#2}
%<latexrelease>              { \l_@@_return_tl #3 }
%<latexrelease>          }
%<latexrelease>          { \prop_gput:cnn { g_@@_#1_code_prop } {#2} {#3} }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \hook_gput_code_with_args:nnn #1#2#3 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_chk_args_allowed:nn}
%   此宏检查是否可以向钩子 \verb|#1| 添加带有引用的代码。
%   仅在运行函数为 \verb|replacing_args| 时才执行操作。
%   如果钩子已声明且不带参数，将引发错误，然后设置 \cs{@@_replacing_args_false:}，
%   以使调用它的宏可以正常添加代码。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_chk_args_allowed:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_chk_args_allowed:nn #1 #2
  {
    \@@_if_replacing_args:TF
      {
        \@@_if_declared:nT {#1}
          { \tl_if_empty:cT { c_@@_#1_parameter_tl } { \use_ii:nn } }
        \use_none:n
          {
            \msg_error:nnnn { hooks } { without-args } {#1} {#2}
            \@@_replacing_args_false:
          }
      }
      { }
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_chk_args_allowed:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_chk_args_allowed:nn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_gput_undeclared_hook:nnn}
%   经常会出现这样的情况，一个包 $A$ 定义了一个钩子 \verb=foo=，
%   但是在加载 $A$ 之前加载了向该钩子添加代码的包 $B$。
%   在这种情况下，我们需要在其声明之前向钩子添加代码。
%   隐式声明的钩子没有参数（原则上），所以在这里使用 \cs{c_false_bool}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_undeclared_hook:nnn #1 #2 #3
  {
    \@@_init_structure:n {#1}
    \@@_hook_gput_code_do:nnn {#1} {#2} {#3}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_try_declaring_generic_hook:nnn,
%               \@@_try_declaring_generic_next_hook:nn}
%
%   这些入口级宏只是将参数传递给通用的 \cs{@@_try_declaring_generic_hook:nNNnn}，
%   其中包含在采取某些操作时执行的正确函数。
%
%   包装器 \cs{@@_try_declaring_generic_hook:nnn} 接着推迟 \cs{hook_gput_code:nnn}，
%   如果通用钩子已声明，否则推迟到 \cs{@@_gput_undeclared_hook:nnn}（在此之前已经测试了钩子是否存在，
%   所以此时如果它不是通用的，它就不存在）。
%
%   包装器 \cs{@@_try_declaring_generic_next_hook:nn} 用于 next-execution 钩子，
%   它做的事情类似：如果通用钩子已声明，就推迟代码到 \cs{hook_gput_next_code:nn}，
%   否则推迟到 \cs{@@_gput_next_do:nn}。
% \changes{v1.0p}{2021/08/25}{标准化通用钩子名称（gh/648）}
% \changes{v1.1d}{2023/05/21}
%         {更改以支持命令钩子中的参数（cmd-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_try_declaring_generic_hook:nnn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_try_declaring_generic_hook:nnn #1
  {
    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
      \@@_gput_code:nnn
      \@@_gput_undeclared_hook:nnn
        {#1}
  }
\cs_new_protected:Npn \@@_try_declaring_generic_next_hook:nn #1
  {
    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
      \@@_gput_next_code:nn
      \@@_gput_next_do:nn
        {#1}
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_try_declaring_generic_hook:nnn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_gset_protected:Npn \@@_try_declaring_generic_hook:nnn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
%<latexrelease>      \hook_gput_code:nnn
%<latexrelease>      \@@_gput_undeclared_hook:nnn
%<latexrelease>        {#1}
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \@@_try_declaring_generic_next_hook:nn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
%<latexrelease>      \hook_gput_next_code:nn
%<latexrelease>      \@@_gput_next_do:nn
%<latexrelease>        {#1}
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_try_declaring_generic_hook:nnn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_hook:nnn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:nNNnn {#1}
%<latexrelease>      \hook_gput_code:nnn \@@_gput_undeclared_hook:nnn
%<latexrelease>  }
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_next_hook:nn #1
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:nNNnn {#1}
%<latexrelease>      \hook_gput_next_code:nn \@@_gput_next_do:nn
%<latexrelease>  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_try_declaring_generic_hook:nNNnn,
%               \@@_try_declaring_generic_hook_split:nNNnn}
%
%   \cs{@@_try_declaring_generic_hook:nNNnn}
% 现在在第一个 \texttt{/} 处（如果有）分割钩子名称，
% 并首先使用 \cs{@@_if_file_hook:wTF} 检查是否是特定于文件的钩子（它们需要一些规范化）。
% 如果不是，则检查它是否是预定义集合中的一个通用名称。
% 我们还分离出第二个组件，看看是否需要创建一个反向钩子。
% 在任一情况下，该函数对于通用钩子返回 \meta{true}，对于其他情况返回 \meta{false}。
%
% \changes{v1.0s}{2021/09/28}
%                {修复旧 \cs{@@_if_file_hook:wTF} 的使用（gh/675）}
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_hook:nNNnn #1
%<latexrelease>  {
%<latexrelease>    \@@_if_file_hook:wTF #1 / \s_@@_mark
%<latexrelease>      {
%<latexrelease>        \exp_args:Ne \@@_try_declaring_generic_hook_split:nNNnn
%<latexrelease>          { \exp_args:Ne \@@_file_hook_normalize:n {#1} }
%<latexrelease>      }
%<latexrelease>      { \@@_try_declaring_generic_hook_split:nNNnn {#1} }
%<latexrelease>  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_try_declaring_generic_hook_split:nNNnn #1 #2 #3
%<latexrelease>  {
%<latexrelease>    \@@_try_declaring_generic_hook:wnTF #1 / / / \scan_stop: {#1}
%<latexrelease>      { #2 }
%<latexrelease>      { #3 } {#1}
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\@@_try_declaring_generic_hook:wn}
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Hooks~with~args}
\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
  {
    \@@_if_generic:nTF {#5}
      {
        \@@_if_usable:nF {#5}
          {
%    \end{macrocode}
% 如果这个钩子还不存在，我们会检查它是否是一个 \texttt{cmd} 钩子，如果是，我们会尝试修补这个命令，除了声明这个钩子。
%
% 对于某些命令，这是不可能的，这种情况下，\cs{@@_patch_cmd_or_delay:Nnn}（在 \texttt{ltcmdhooks} 中定义）将生成一个相应的错误消息。
% \changes{v1.1d}{2023/05/21}
%         {对命令钩子（cmd-args）进行支持参数的更改。}
%    \begin{macrocode}
            \str_if_eq:nnT {#1} { cmd }
              {
                \@@_try_put_cmd_hook:n {#5}
                \@@_make_usable:nn {#5} { 9 }
                \use_none:nnn
              }
%    \end{macrocode}
%
% 即使无法真正使用这个钩子（错误消息将在其他地方生成），也要声明这个钩子。
%
% 在这里，我们使用 \cs{@@_make_usable:nn}，这样以后仍然可以使用 \cs{hook_new:n}。通用钩子（除了 \hook{cmd} 钩子）不接受参数，所以将零作为第二个参数。
%    \begin{macrocode}
            \@@_make_usable:nn {#5} { 0 }
          }
        \@@_if_generic_reversed:nT {#5}
          { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
        \prg_return_true:
      }
      {
%    \end{macrocode}
%
% 通用钩子都被命名为 \meta{type}/\meta{name}/\meta{place}，其中 \meta{type} 和 \meta{place} 是预定义的（\cs{c_@@_generic_\meta{type}/./\meta{place}_tl}），\meta{name} 是可变的部分。旧版本中有一些钩子的 \meta{name} 在第三部分，所以下面的代码一段时间内支持这种语法，并会发出警告。
%
% \cs{exp_after:wN} |...| \cs{exp:w} 的技巧是为了删除 \cs{@@_try_declaring_generic_hook:wnTF} 插入的条件结构，从而允许访问后续的标记，这对于保持事务正常进行是必要的。
%
% 当淘汰周期结束时，下面的行应该全部替换为 \cs{prg_return_false:}。
%    \begin{macrocode}
        \@@_if_deprecated_generic:nTF {#5}
          {
            \@@_deprecated_generic_warn:n {#5}
            \exp_after:wN \@@_declare_deprecated_generic:NNn
            \exp:w % \exp_end:
          }
          { \prg_return_false: }
      }
  }
%    \end{macrocode}
%
% \begin{macro}{
%     \@@_deprecated_generic_warn:Nn,
%     \@@_deprecated_generic_warn:Nw,
%   }
%   \cs{@@_deprecated_generic_warn:n} 会针对给定的钩子发出弃用警告，并标记该钩子，以确保不会再次发出警告（可以发出多个警告，但每个钩子只发出一次）。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_deprecated_generic_warn:n #1
  { \@@_deprecated_generic_warn:w #1 \s_@@_mark }
\cs_new_protected:Npn \@@_deprecated_generic_warn:w
    #1 / #2 / #3 \s_@@_mark
  {
    \if_cs_exist:w @@~#1/#2/#3 \cs_end: \else:
      \msg_warning:nnnnn { hooks } { generic-deprecated } {#1} {#2} {#3}
    \fi:
    \cs_gset_eq:cN { @@~#1/#2/#3 } \scan_stop:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{
%     \@@_do_deprecated_generic:Nn,
%     \@@_do_deprecated_generic:Nw,
%     \@@_declare_deprecated_generic:NNw,
%     \@@_declare_deprecated_generic:NNw,
%   }
%   现在用户已经被告知了这个废弃情况，我们通过交换 \meta{name} 和 \meta{place} 并将代码添加到正确的钩子中进行下一步处理。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_do_deprecated_generic:Nn #1 #2
  { \@@_do_deprecated_generic:Nw #1 #2 \s_@@_mark }
\cs_new_protected:Npn \@@_do_deprecated_generic:Nw #1
         #2 / #3 / #4 \s_@@_mark
  { #1 { #2 / #4 / #3 } }
\cs_new_protected:Npn \@@_declare_deprecated_generic:NNn #1 #2 #3
  { \@@_declare_deprecated_generic:NNw #1 #2 #3 \s_@@_mark }
\cs_new_protected:Npn \@@_declare_deprecated_generic:NNw #1 #2
    #3 / #4 / #5 \s_@@_mark
  {
    \@@_try_declaring_generic_hook:wnTF #3 / #5 / #4 / \scan_stop:
        { #3 / #5 / #4 }
      #1 #2 { #3 / #5 / #4 }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
%<latexrelease>    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
%<latexrelease>  {
%<latexrelease>    \@@_if_generic:nTF {#5}
%<latexrelease>      {
%<latexrelease>        \@@_if_usable:nF {#5}
%<latexrelease>          {
%<latexrelease>            \str_if_eq:nnT {#1} { cmd }
%<latexrelease>              { \@@_try_put_cmd_hook:n {#5} }
%<latexrelease>            \@@_make_usable:n {#5}
%<latexrelease>          }
%<latexrelease>        \@@_if_generic_reversed:nT {#5}
%<latexrelease>          { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>        \prg_return_true:
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \@@_if_deprecated_generic:nTF {#5}
%<latexrelease>          {
%<latexrelease>            \@@_deprecated_generic_warn:n {#5}
%<latexrelease>            \exp_after:wN \@@_declare_deprecated_generic:NNn
%<latexrelease>            \exp:w % \exp_end:
%<latexrelease>          }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Support~cmd~hooks}
%<latexrelease>\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
%<latexrelease>    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:nTF {#2}
%<latexrelease>      { \prg_return_false: }
%<latexrelease>      {
%<latexrelease>        \prop_if_in:NnTF \c_@@_generics_prop {#1}
%<latexrelease>          {
%<latexrelease>            \@@_if_usable:nF {#5}
%<latexrelease>              {
%<latexrelease>                \str_if_eq:nnT {#1} { cmd }
%<latexrelease>                  { \@@_try_put_cmd_hook:n {#5} }
%<latexrelease>                \@@_make_usable:n {#5}
%<latexrelease>              }
%<latexrelease>            \prop_if_in:NnTF \c_@@_generics_reversed_ii_prop {#2}
%<latexrelease>              { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              {
%<latexrelease>                \prop_if_in:NnT \c_@@_generics_reversed_iii_prop {#3}
%<latexrelease>                  { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              }
%<latexrelease>            \prg_return_true:
%<latexrelease>          }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_try_declaring_generic_hook:wn}
%<latexrelease>                 {Support~cmd~hooks}
%<latexrelease>\prg_new_protected_conditional:Npnn \@@_try_declaring_generic_hook:wn
%<latexrelease>    #1 / #2 / #3 / #4 \scan_stop: #5 { TF }
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:nTF {#2}
%<latexrelease>      { \prg_return_false: }
%<latexrelease>      {
%<latexrelease>        \prop_if_in:NnTF \c_@@_generics_prop {#1}
%<latexrelease>          {
%<latexrelease>            \@@_if_declared:nF {#5} { \hook_new:n {#5} }
%<latexrelease>            \prop_if_in:NnTF \c_@@_generics_reversed_ii_prop {#2}
%<latexrelease>              { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              {
%<latexrelease>                \prop_if_in:NnT \c_@@_generics_reversed_iii_prop {#3}
%<latexrelease>                  { \tl_gset:cn { g_@@_#5_reversed_tl } { - } }
%<latexrelease>              }
%<latexrelease>            \prg_return_true:
%<latexrelease>          }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[pTF]{\@@_if_file_hook:w}
%   \cs{@@_if_file_hook:wTF} 检查参数是否是有效的特定文件钩子（例如不是 |file/before|，而是 |file/foo.tex/before|）。如果是特定文件钩子，则执行 \meta{true} 分支，否则执行 \meta{false} 分支。
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_if_file_hook:w}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_if_file_hook:w}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prg_new_conditional:Npnn \@@_if_file_hook:w
%<latexrelease>    #1 / #2 / #3 \s_@@_mark { TF }
%<latexrelease>  {
%<latexrelease>    \str_if_eq:nnTF {#1} { file }
%<latexrelease>      {
%<latexrelease>        \bool_lazy_or:nnTF
%<latexrelease>            { \tl_if_empty_p:n {#3} }
%<latexrelease>            { \str_if_eq_p:nn {#3} { / } }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>          {
%<latexrelease>            \prop_if_in:NnTF \c_@@_generics_file_prop {#2}
%<latexrelease>              { \prg_return_true: }
%<latexrelease>              { \prg_return_false: }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>      { \prg_return_false: }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_file_hook_normalize:n}
% \begin{macro}[EXP]{\@@_strip_double_slash:n,\@@_strip_double_slash:w}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_file_hook_normalize:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%   当找到一个特定于文件的钩子时，在声明之前会被 \cs{@@_file_hook_normalize:n} 轻微规范化。当前的实现仅将两个连续的斜杠（|//|）替换为一个斜杠，以处理用户执行类似于 \verb|\def\input@path{{./mypath/}}| 的简单情况，在这种情况下，一个钩子将会是 \verb|\AddToHook{file/./mypath//file.tex/after}|。
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_file_hook_normalize:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new:Npn \@@_file_hook_normalize:n #1
%<latexrelease>  { \@@_strip_double_slash:n {#1} }
%<latexrelease>\cs_new:Npn \@@_strip_double_slash:n #1
%<latexrelease>  { \@@_strip_double_slash:w #1 // \s_@@_mark }
%    \end{macrocode}
%   这个函数总是在使用 \cs{@@_if_file_hook:wTF} 测试参数是否为文件钩子后调用的，所以我们可以假设它有三部分（要么是 \verb|file/.../before|，要么是 \verb|file/.../after|），因此我们使用 \verb|#1/#2/#3 //| 而不是仅仅 \verb|#1 //|，以防止如果文件名为空，则会丢失一个斜杠。
%   \changes{v1.0h}{2021/01/07}{假定钩子名称至少有三个非空部分（gh/464）}
%    \begin{macrocode}
%<latexrelease>\cs_new:Npn \@@_strip_double_slash:w #1/#2/#3 // #4 \s_@@_mark
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:nTF {#4}
%<latexrelease>      { #1/#2/#3 }
%<latexrelease>      { \@@_strip_double_slash:w #1/#2/#3 / #4 \s_@@_mark }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{
%    \c_@@_generic_cmd/./before_tl,\c_@@_generic_cmd/./after_tl,
%    \c_@@_generic_env/./before_tl,\c_@@_generic_env/./after_tl,
%    \c_@@_generic_file/./before_tl,\c_@@_generic_file/./after_tl,
%    \c_@@_generic_package/./before_tl,\c_@@_generic_package/./after_tl,
%    \c_@@_generic_class/./before_tl,\c_@@_generic_class/./after_tl,
%    \c_@@_generic_include/./before_tl,\c_@@_generic_include/./after_tl,
%    \c_@@_generic_env/./begin_tl,\c_@@_generic_env/./end_tl,
%    \c_@@_generic_include/./end_tl
%  }
%    定义可能的通用钩子的标记列表。我们不提供任何用户界面，因为这应该是静态的。
%    \begin{description}
%    \item[\texttt{cmd}]
%      用于命令的通用钩子。
%    \item[\texttt{env}]
%      用于 \cs{begin} 和 \cs{end} 中的通用钩子。
%    \item[\texttt{file}, \texttt{package}, \texttt{class}, \texttt{include}]
%      在加载文件时使用的通用钩子。
%    \end{description}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\c_@@_generics_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
\clist_map_inline:nn { cmd , env , file , package , class , include }
  {
    \tl_const:cn { c_@@_generic_#1/./before_tl } { + }
    \tl_const:cn { c_@@_generic_#1/./after_tl  } { - }
  }
\tl_const:cn { c_@@_generic_env/./begin_tl } { + }
\tl_const:cn { c_@@_generic_env/./end_tl   } { + }
%    \end{macrocode}
%
% \changes{v1.0t}{2022/04/01}{支持通用 \texttt{include/.../excluded} 钩子}
%    \begin{macrocode}
\tl_const:cn { c_@@_generic_include/./end_tl } { - }
\tl_const:cn { c_@@_generic_include/./excluded_tl } { + }
%    \end{macrocode}
%
%   废弃的通用钩子：
%    \begin{macrocode}
\clist_map_inline:nn { file , package , class , include }
  {
    \tl_const:cn { c_@@_deprecated_#1/./before_tl } { }
    \tl_const:cn { c_@@_deprecated_#1/./after_tl  } { }
  }
\tl_const:cn { c_@@_deprecated_include/./end_tl } { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_generics_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_prop
%<latexrelease>     {cmd=,env=,file=,package=,class=,include=}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\c_@@_generics_reversed_ii_prop,
%                \c_@@_generics_reversed_iii_prop,
%                \c_@@_generics_file_prop}
%    以下通用钩子应该使用反向排序（|ii| 和 |iii| 的名称保留用于淘汰周期）：
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\c_@@_generics_reversed_ii_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_generics_reversed_ii_prop}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_reversed_ii_prop {after=,end=}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_reversed_iii_prop {after=}
%<latexrelease>\prop_const_from_keyval:Nn \c_@@_generics_file_prop {before=,after=}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}{
%     \c_@@_parameter_cmd/./before_tl,\c_@@_parameter_cmd/./after_tl,
%   }
%   标记列表定义了特定类型的通用钩子的参数数量。
% \changes{v1.1d}{2023/05/21}
%         {添加了标记列表（cmd-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\c_@@_parameter_cmd/./before_tl}
%<latexrelease>                 {Hooks~with~args}
%    \end{macrocode}
%
%   \hook{cmd} 钩子被声明为具有9个参数，因为它们具有可变数量的参数（取决于它们所附加的命令），所以我们在这里使用了最大值。
%    \begin{macrocode}
\tl_const:cn { c_@@_parameter_cmd/./before_tl } { #1#2#3#4#5#6#7#8#9 }
\tl_const:cn { c_@@_parameter_cmd/./after_tl }  { #1#2#3#4#5#6#7#8#9 }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_parameter_cmd/./before_tl}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\hook_gremove_code:nn}
% \begin{macro}{\@@_gremove_code:nn}
%
%    使用 \cs{hook_gremove_code:nn}\Arg{hook}\Arg{label} 可以移除存储在 \meta{label} 下的 \meta{hook} 的任何代码。
% \changes{v1.0o}{2021/07/22}{不再排队移除（gh/625）}
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_gremove_code:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_gremove_code:nn #1 #2
  { \@@_normalize_hook_args:Nnn \@@_gremove_code:nn {#1} {#2} }
\cs_new_protected:Npn \@@_gremove_code:nn #1 #2
  {
%    \end{macrocode}
%    首先检查钩子代码池是否存在。这里不使用 \cs{@@_if_usable:nTF}，因为应该可以在钩子定义之前移除代码（见第~\ref{sec:querying} 节）。
%    \begin{macrocode}
    \@@_if_structure_exist:nTF {#1}
      {
%    \end{macrocode}
%    然后移除代码块并运行 \cs{@@_update_hook_code:n}，以便在我们在 \verb=\begin{document}= 之后对执行标记列表进行反映更改。
%
%    如果要移除所有代码，则清除代码池 \cs{g_@@_\meta{hook}_code_prop}，顶层代码 \cs{@@_toplevel\textvisiblespace\meta{hook}}，以及下一个执行代码 \cs{@@_next\textvisiblespace\meta{hook}}。
%    \begin{macrocode}
        \str_if_eq:nnTF {#2} {*}
          {
            \prop_gclear:c { g_@@_#1_code_prop }
            \@@_toplevel_gset:nn {#1} { }
            \@@_next_gset:nn {#1} { }
          }
          {
%    \end{macrocode}
%    如果标签是 |top-level|，则清除标记列表，因为所有代码都在相同的标签下。
%    \begin{macrocode}
            \str_if_eq:nnTF {#2} { top-level }
              { \@@_toplevel_gset:nn {#1} { } }
              {
                \prop_gpop:cnNF { g_@@_#1_code_prop } {#2} \l_@@_return_tl
                  { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
              }
          }
%    \end{macrocode}
%    最后，如果钩子存在，更新代码。
%    \begin{macrocode}
        \@@_if_usable:nT {#1}
          { \@@_update_hook_code:n {#1} }
      }
%    \end{macrocode}
%
%    如果这个钩子的代码池不存在，显示警告：
%    \begin{macrocode}
      {
        \@@_if_deprecated_generic:nTF {#1}
          {
            \@@_deprecated_generic_warn:n {#1}
            \@@_do_deprecated_generic:Nn \@@_gremove_code:nn {#1} {#2}
          }
          { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_gremove_code:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_gremove_code:nn #1 #2
%<latexrelease>  {
%<latexrelease>    \@@_if_structure_exist:nTF {#1}
%<latexrelease>      {
%<latexrelease>        \str_if_eq:nnTF {#2} {*}
%<latexrelease>          {
%<latexrelease>            \prop_gclear:c { g_@@_#1_code_prop }
%<latexrelease>            \@@_tl_gclear:c { @@_toplevel~#1 }
%<latexrelease>            \@@_tl_gclear:c { @@_next~#1 }
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \str_if_eq:nnTF {#2} { top-level }
%<latexrelease>              { \@@_tl_gclear:c { @@_toplevel~#1 } }
%<latexrelease>              {
%<latexrelease>                \prop_gpop:cnNF { g_@@_#1_code_prop } {#2} \l_@@_return_tl
%<latexrelease>                  { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>        \@@_if_usable:nT {#1}
%<latexrelease>          { \@@_update_hook_code:n {#1} }
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \@@_if_deprecated_generic:nTF {#1}
%<latexrelease>          {
%<latexrelease>            \@@_deprecated_generic_warn:n {#1}
%<latexrelease>            \@@_do_deprecated_generic:Nn \@@_gremove_code:nn {#1} {#2}
%<latexrelease>          }
%<latexrelease>          { \msg_warning:nnnn { hooks } { cannot-remove } {#1} {#2} }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_cs_gput_right:nnn}
% \begin{macro}{\@@_cs_gput_right_fast:nnn,\@@_cs_gput_right_slow:nnn}
% \begin{macro}{\@@_code_gset_auxi:nnnn,\@@_code_gset_auxi:eeen}
%   此宏用于将代码附加到 \verb|toplevel| 和 \verb|next| 标记列表中，并根据其参数数量正确处理它们，以及根据被添加的代码是否应将参数标记理解为参数，还是将其加倍以存储为参数标记。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
% \changes{v1.1e}{2023/06/06}
%         {当钩子声明为无参数时进行简化（gh1078）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_cs_gput_right:nnn}
%<latexrelease>                 {Hooks~with~args}
%    \end{macrocode}
%
%   检查当前钩子是否已声明且不带参数。在这种情况下，我们进行简化处理，并使用简单且更快速的方法，不需要进行哈希加倍。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cs_gput_right:nnn #1 #2
  {
    \if:w T
        \@@_if_declared:nF {#2} { F }
        \tl_if_empty:cF { c_@@_#2_parameter_tl } { F }
          T
      \exp_after:wN \@@_cs_gput_right_fast:nnn
    \else:
      \exp_after:wN \@@_cs_gput_right_slow:nnn
    \fi:
        {#1} {#2}
  }
\cs_new_protected:Npn \@@_cs_gput_right_fast:nnn #1 #2 #3
  { \cs_gset:cpx { @@#1~#2 } { \exp_not:v { @@#1~#2 } \exp_not:n {#3} } }
\cs_new_protected:Npn \@@_cs_gput_right_slow:nnn #1 #2 #3
  {
%    \end{macrocode}
%   辅助命令 \cs{@@_code_gset_auxi:eeen} 最终只是在末尾执行赋值操作。它的第一个参数是宏的参数文本，在这里的选择取决于 \cs[no-index]{c_@@_\meta{hook}_parameter_tl} 是否存在，钩子是否已声明，以及它是否是通用钩子。
%    \begin{macrocode}
    \cs_if_exist:cF { @@#1~#2 }
      { \@@_code_gset_aux:nnn {#1} {#2} { } }
    \@@_code_gset_auxi:eeen
      {
        \@@_if_declared:nTF {#2}
          { \tl_use:c { c_@@_#2_parameter_tl } }
          {
            \@@_if_generic:nTF {#2}
              { \@@_generic_parameter:n {#2} }
              { \c_@@_nine_parameters_tl }
          }
      }
%    \end{macrocode}
%   这里我们取宏中的现有代码，用它需要的参数进行展开，然后加倍哈希，以便可以重用代码。\pho{也许可以改进。通过快速检查 \cs{cs_replacement_spec}，可以优化添加到空 cs 的情况。}
%    \begin{macrocode}
      {
        \exp_args:NNo \exp_args:No \@@_double_hashes:n
          {
            \cs:w @@#1~#2 \exp_last_unbraced:Ne \cs_end:
              { \@@_braced_cs_parameter:n { @@#1~#2 } }
          }
      }
%    \end{macrocode}
%   现在是新代码：如果我们正在替换参数，则哈希保持不变，否则加倍。
%    \begin{macrocode}
      {
        \@@_if_replacing_args:TF
          { \exp_not:n }
          { \@@_double_hashes:n }
            {#3}
      }
%    \end{macrocode}
%   最后，我们将定义带有以上所有内容的控制序列名称。
%    \begin{macrocode}
      { @@#1~#2 }
  }
%    \end{macrocode}
%
%   正如承诺的那样，这是执行定义的辅助函数。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_code_gset_auxi:nnnn #1 #2 #3 #4
  { \cs_gset:cpn {#4} #1 { #2 #3 } }
\cs_generate_variant:Nn \@@_code_gset_auxi:nnnn { eeen }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_cs_gput_right:nnn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_cs_gput_right:nnn
%<latexrelease>\cs_undefine:N \@@_cs_gput_right_fast:nnn
%<latexrelease>\cs_undefine:N \@@_cs_gput_right_slow:nnn
%<latexrelease>\cs_undefine:N \@@_code_gset_auxi:nnnn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{
%     \@@_code_gset:nn,\@@_code_gset:ne,
%     \@@_toplevel_gset:nn,
%     \@@_next_gset:nn,
%     \@@_code_gset_aux:nnn
%   }
%   这些宏定义了 \cs[no-index]{@@\meta{type}\textvisiblespace\meta{hook}}（其中 \meta{type} 是 \verb|_next|、\verb|_toplevel| 或为空），其中包含给定的代码以及存储在 \cs[no-index]{c_@@_\meta{hook}_parameter_tl} 中的参数（如果该参数不存在，则为空）。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_code_gset:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_code_gset:nn
  { \@@_code_gset_aux:nnn { } }
\cs_new_protected:Npn \@@_toplevel_gset:nn
  { \@@_code_gset_aux:nnn { _toplevel } }
\cs_new_protected:Npn \@@_next_gset:nn
  { \@@_code_gset_aux:nnn { _next } }
\cs_new_protected:Npn \@@_code_gset_aux:nnn #1 #2 #3
  {
    \cs_gset:cpn { @@#1~#2 \exp_last_unbraced:Ne }
      { \@@_parameter:n {#2} }
      {#3}
  }
\cs_generate_variant:Nn \@@_code_gset:nn { ne }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_code_gset:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_code_gset:nn
%<latexrelease>\cs_undefine:N \@@_toplevel_gset:nn
%<latexrelease>\cs_undefine:N \@@_next_gset:nn
%<latexrelease>\cs_undefine:N \@@_code_gset_aux:nnn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_normalise_cs_args:nn}
%   此宏将 \cs[no-index]{@@\meta{type}\textvisiblespace\meta{hook}} 的参数标准化，以便在钩子声明后采用正确数量的参数。在此时，我们知道 \cs[no-index]{c_@@_\meta{hook}_parameter_tl} 存在，因此使用它来计算参数数量，并将其用作新（重新）定义的宏的 \meta{parameter text}。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_normalise_cs_args:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_normalise_cs_args:nn #1 #2
  {
    \cs_if_exist:cT { @@#1~#2 }
      {
        \@@_code_gset_auxi:eeen
          { \tl_use:c { c_@@_#2_parameter_tl } }
          {
            \exp_args:NNo \exp_args:No \@@_double_hashes:n
              {
                \cs:w @@#1~#2 \exp_last_unbraced:Ne \cs_end:
                  { \@@_braced_cs_parameter:n { @@#1~#2 } }
              }
          }
          { }
          { @@#1~#2 }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_normalise_cs_args:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_normalise_cs_args:nn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_normalise_code_pool:n}
% \begin{macro}{\@@_set_normalise_fn:nn}
%   这个有点巧妙。它接收一个钩子，在其代码池 (\cs[no-index]{g_@@_\meta{hook}_code_prop}) 上进行迭代，重新定义每个代码标签，以仅使用有效的参数。这在以下情况下使用：例如，添加的代码引用了参数 \verb|#1| 和 \verb|#2|，但是钩子只有 \verb|#1|。在这种情况下，每个对 \verb|#2| 的引用都被改为 \verb|##2|。这样做是因为否则，每当钩子发生某些更改（添加代码、设置规则等）时，\TeX{} 将抛出低级错误，这可能没有充分的理由会变得非常重复乏味。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_normalise_code_pool:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_normalise_code_pool:n #1
  {
%    \end{macrocode}
%   首先，使用钩子名称调用 \cs{@@_set_normalise_fn:nn} 来设置所有内容，然后我们将遍历钩子的代码池并应用上面的标准化。完成后，将临时属性列表复制回钩子的属性列表。
%    \begin{macrocode}
    \@@_set_normalise_fn:nn {#1} { Offending~label:~'##1' }
    \prop_clear:N \l_@@_work_prop
    \prop_map_function:cN { g_@@_#1_code_prop } \@@_normalise_fn:nn
    \prop_gset_eq:cN { g_@@_#1_code_prop } \l_@@_work_prop
  }
%    \end{macrocode}
%
%   此函数的唯一目的是定义 \cs{@@_normalise_fn:nn}，然后对添加到钩子的代码进行更正。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_normalise_fn:nn #1 #2
  {
%    \end{macrocode}
%   首先，我们定义两个辅助的记号列表。
%   \cs[no-index]{l_@@_tmpb_tl} 包含：
%\begin{verbatim}
%   {\c__hook_hashes_tl 1}
%   {\c__hook_hashes_tl 2}
%   ...
%   {\c__hook_hashes_tl 9}
%\end{verbatim}
%    \begin{macrocode}
    \cs_set:Npn \@@_tmp:w ##1##2##3##4##5##6##7##8##9 { }
    \tl_set:Ne \l_@@_tmpb_tl
      { \@@_braced_cs_parameter:n { @@_tmp:w } }
    \group_begin:
      \@@_tl_set:cn { c_@@_hash_tl } { \exp_not:N \c_@@_hashes_tl }
      \use:e
        {
    \group_end:
    \tl_set:Nn \exp_not:N \l_@@_tmpb_tl { \l_@@_tmpb_tl }
        }
%    \end{macrocode}
%   \cs[no-index]{l_@@_tmpa_tl} 包含：
%\begin{verbatim}
%   {\c__hook_hash_tl 1}
%   {\c__hook_hash_tl 2}
%   ...
%   {\c__hook_hash_tl <n>}
%\end{verbatim}
%   其中 \meta{n} 是钩子声明的参数数量。
%    \begin{macrocode}
    \exp_last_unbraced:NNf
    \cs_set:Npn \@@_tmp:w { \@@_parameter:n {#1} } { }
    \tl_set:Ne \l_@@_tmpa_tl { \@@_braced_cs_parameter:n { @@_tmp:w } }
%    \end{macrocode}
%   现在这个函数做的是有趣的部分。它被设计用于 \cs{prop_map_function:NN}，接收 \verb|##1| 中的标签名称和 \verb|##2| 中存储的代码。
%    \begin{macrocode}
    \cs_gset_protected:Npx \@@_normalise_fn:nn ##1 ##2
      {
%    \end{macrocode}
%   这里我们将定义两个辅助宏：第一个在检测到无效参数引用时引发错误。它利用 \TeX{} 的低级错误“Illegal parameter number”，但是定义了一个奇怪命名的控制序列，以便错误可以出现漂亮的格式。例如，如果标签“badpkg”添加了一些代码，在钩子“foo”中引用了参数 \verb|#3|，而钩子只有两个参数，那么错误将是：
%\begin{verbatim}
%   ! Illegal parameter number in definition of hook 'foo'.
%   (hooks)             Offending label: 'badpkg'.
%   <to be read again> 
%                      3
%\end{verbatim}
%   在此定义的点上，如果代码恰好引用了无效的参数，错误就会被引发。如果能够检测到此定义没有引发错误，下一步将是不必要的。我们将所有这些放在一个组中，以便这个奇怪的定义不会泄漏，并将 \cs{tex_escapechar:D} 设置为 $-1$，这样在出现错误时，这个 hack 将显示得更加漂亮。
%    \begin{macrocode}
        \group_begin:
          \int_set:Nn \tex_escapechar:D { -1 }
          \cs_set:cpn
              {
                hook~'#1'. ^^J
                (hooks) \prg_replicate:nn { 13 } { ~ }
                #2 % more message text
              }
              \exp_not:v { c_@@_#1_parameter_tl }
            {##2}
        \group_end:
%    \end{macrocode}
%   下一个宏，名称要低调得多，始终接受九个参数，它只是将代码 \verb|##2| 在标签 \verb|##1| 下传输到临时属性列表中。前 \meta{n} 个参数来自 \cs[no-index]{l_@@_tmpa_tl}，而另外的 $9-\meta{n}$ 个参数来自 \cs[no-index]{l_@@_tmpb_tl}（后者包含的 \verb|#| 个数是前者的两倍）。然后，\cs{@@_double_hashes:n} 用于将非参数哈希值加倍，并将 \cs{c_@@_hash_tl} 和 \cs{c_@@_hashes_tl} 展开为实际的参数标记。
%    \begin{macrocode}
        \cs_set:Npn \exp_not:N \@@_tmp:w
            \exp_not:V \c_@@_nine_parameters_tl
          {
            \prop_put:Nne \exp_not:N \l_@@_work_prop
              {##1} { \exp_not:N \@@_double_hashes:n {##2} }
          }
%    \end{macrocode}
%   下一个宏，名称要低调得多，始终接受九个参数，它只是将代码 \verb|##2| 在标签 \verb|##1| 下传输到临时属性列表中。前 \meta{n} 个参数来自 \cs[no-index]{l_@@_tmpa_tl}，而另外的 $9-\meta{n}$ 个参数来自 \cs[no-index]{l_@@_tmpb_tl}（后者包含的 \verb|#| 个数是前者的两倍）。然后，\cs{@@_double_hashes:n} 用于将非参数哈希值加倍，并将 \cs{c_@@_hash_tl} 和 \cs{c_@@_hashes_tl} 展开为实际的参数标记。
%    \begin{macrocode}
        \exp_not:N \@@_tmp:w
          \exp_not:V \l_@@_tmpa_tl
          \exp_args:No \exp_not:o
            { \exp_after:wN \@@_tmp:w \l_@@_tmpb_tl }
      }
  }
\cs_new_eq:NN \@@_normalise_fn:nn ?
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_normalise_code_pool:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_normalise_code_pool:n
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_cs_if_empty:c}
%   通过查看其替换文本来检查控制序列的展开是否为空。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_cs_if_empty:c}
%<latexrelease>                 {Hooks~with~args}
\prg_new_conditional:Npnn \@@_cs_if_empty:c #1 { p, T, F, TF }
  {
    \if:w \scan_stop: \@@_replacement_spec:c {#1} \scan_stop:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
\cs_new:Npn \@@_replacement_spec:c #1
  {
    \exp_args:Nc \token_if_macro:NT {#1}
      { \cs_replacement_spec:c {#1} }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_cs_if_empty:c}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_cs_if_empty:c
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_braced_cs_parameter:n}
% \begin{macro}{\@@_braced_hidden_loop:w}
% \begin{macro}{\@@_cs_parameter_count:N}
% \begin{macro}{\@@_cs_parameter_count:w,\@@_cs_end:w}
%   查看控制序列的 \meta{parameter text}，并返回该宏的一系列“隐藏”的大括号参数。
%   只要宏接受从零到九个简单参数的连续运行，这就能正常工作。
%   这些参数被“隐藏”，因为参数标记是在 \cs{c_@@_hash_tl} 中返回而不是显式地返回，这样 \cs{@@_double_hashes:n} 就不会触及它们。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_braced_cs_parameter:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \@@_braced_cs_parameter:n #1
  {
    \exp_last_unbraced:Ne \@@_braced_hidden_loop:w
      { \exp_args:Nc \@@_cs_parameter_count:N {#1} } ? \s_@@_mark
  }
\cs_new:Npn \@@_braced_hidden_loop:w #1
  {
    \if:w ? #1
      \@@_use_i_delimit_by_s_mark:nw
    \fi:
    { \exp_not:N \c_@@_hash_tl #1 }
    \@@_braced_hidden_loop:w
  }
\cs_new:Npn \@@_cs_parameter_count:N #1
  {
    \exp_last_unbraced:Nf \@@_cs_parameter_count:w
      { \token_if_macro:NT #1 { \cs_parameter_spec:N #1 } }
      ? \@@_cs_end:w ? \@@_cs_end:w ? \@@_cs_end:w
      ? \@@_cs_end:w ? \@@_cs_end:w ? \@@_cs_end:w
      ? \@@_cs_end:w ? \@@_cs_end:w ? \@@_cs_end:w
      \s_@@_mark
  }
\cs_new:Npn \@@_cs_parameter_count:w #1#2 #3#4 #5#6 #7#8
  { #2 #4 #6 #8 \@@_cs_parameter_count:w }
\cs_new:Npn \@@_cs_end:w #1 \s_@@_mark { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%   这个函数在回滚时不能被取消定义，因为它在该模块的末尾用于将钩子数据结构调整到先前版本。
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_braced_cs_parameter:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_braced_parameter:n}
% \begin{macro}{\@@_braced_real_loop:w}
%   在更简单的情况下使用此函数，不需要对井号进行特殊处理。
%   这仅在 \cs{@@_initialize_hook_code:n} 内部使用，因此它假定 \cs[no-index]{c_@@_\meta{hook}_parameter_tl} 已定义，但在其他情况下也应该有效。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_braced_parameter:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \@@_braced_parameter:n #1
  {
    \if_case:w
      \int_eval:n
        { \exp_args:Nv \str_count:n { c_@@_#1_parameter_tl } / 3 }
      \exp_stop_f:
    \or: {##1}
    \or: {##1} {##2}
    \or: {##1} {##2} {##3}
    \or: {##1} {##2} {##3} {##4}
    \or: {##1} {##2} {##3} {##4} {##5}
    \or: {##1} {##2} {##3} {##4} {##5} {##6}
    \or: {##1} {##2} {##3} {##4} {##5} {##6} {##7}
    \or: {##1} {##2} {##3} {##4} {##5} {##6} {##7} {##8}
    \or: {##1} {##2} {##3} {##4} {##5} {##6} {##7} {##8} {##9}
    \else:
      \msg_expandable_error:nnn { latex2e } { should-not-happen }
        { Invalid~parameter~spec. }
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_braced_parameter:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_braced_parameter:n
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_parameter:n}
%   这只是一个快捷方式，用于对钩子的 \meta{parameter text} 进行 \verb|e|- 或 \verb|f|-展开。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_parameter:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \@@_parameter:n #1
  {
    \cs:w c_@@_
    \tl_if_exist:cTF { c_@@_#1_parameter_tl }
      { #1_parameter } { empty }
    _tl \cs_end:
  }
\cs_new:Npn \@@_generic_parameter:n #1
  { \@@_generic_parameter:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_generic_parameter:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \cs_if_exist_use:cF { c_@@_parameter_#1/./#3_tl }
      { \c_@@_empty_tl }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_parameter:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_parameter:n
%<latexrelease>\cs_undefine:N \@@_generic_parameter:n
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
%  \subsection{为钩子代码设置规则}
%
% \begin{macro}{
%     \g_@@_??_code_prop,
%     \@@~??,
%     \g_@@_??_reversed_tl,
%     \c_@@_??_parameter_tl,
%   }
%
% 最初，这些变量只是使用空的“label”名称（不是两个问号）。这有点不太幸
% 运，因为此时 \texttt{l3doc} 在尝试排版文档时会抱怨命令名中间的
% \verb=__=。然而，使用“正常”的名称如\texttt{default}的缺点是它与真
% 实的钩子名称并无真正的区别。我现在选择了\texttt{??}，虽然需要一些巧
% 妙的技巧才能将其放入csname，但由于这被大量使用，代码应该是快速的，
% 所以在代码的后续部分并不使用\texttt{c}扩展。

% \cs{@@\textvisiblespace??} 没有被使用，但必须定义它来欺骗代码，让其
% 认为\texttt{??}实际上是一个钩子。
%    \begin{macrocode}
\prop_new:c { g_@@_??_code_prop }
\prop_new:c { @@~?? }
%    \end{macrocode}
%
% 默认规则总是以正常顺序给出（从不以相反顺序）。如果这样的规则应用
% 到了一个反转的钩子上，它会表现得好像规则被反转了（例如，
% \texttt{after} 变成了 \texttt{before}），因为这些规则首先被应用，
% 然后顺序被反转。
%    \begin{macrocode}
\tl_new:c { g_@@_??_reversed_tl }
%    \end{macrocode}
%
% “默认”钩子的参数文本是空的。
% \changes{v1.1a}{2023/04/06}
%         {添加了令牌列表（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\c_@@_??_parameter_tl}
%<latexrelease>                 {Hooks~with~args}
\tl_const:cn { c_@@_??_parameter_tl } { }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\c_@@_??_parameter_tl}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:c { c_@@_??_parameter_tl }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\hook_gset_rule:nnnn}
%  \begin{macro}{\@@_gset_rule:nnnn}
%    通过
%    \cs{hook_gset_rule:nnnn}\Arg{hook}\Arg{label1}\Arg{relation}\Arg{label2}
%    为给定的\meta{hook}定义了两个代码标签之间的关系。特殊的钩子\texttt{??}代表
%    “任何”钩子，它设置了一个默认规则（如果两个钩子之间没有其他关系，则使用该规则）。
%    \begin{macrocode}
\cs_new_protected:Npn \hook_gset_rule:nnnn #1#2#3#4
  {
    \@@_normalize_hook_rule_args:Nnnnn \@@_gset_rule:nnnn
      {#1} {#2} {#3} {#4}
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2022/06/01}{\@@_gset_rule:nnnn}
%<latexrelease>                 {Refuse~setting~rule~for~one-time~hooks}
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gset_rule:nnnn #1#2#3#4
  {
    \@@_if_deprecated_generic:nT {#1}
      {
        \@@_deprecated_generic_warn:n {#1}
        \@@_do_deprecated_generic:Nn \@@_gset_rule:nnnn {#1}
          {#2} {#3} {#4}
        \@@_use_none_delimit_by_s_mark:w
      }
    \@@_if_execute_immediately:nT {#1}
      {
        \msg_error:nnnnnn { hooks } { rule-too-late }
          {#1} {#2} {#3} {#4}
        \@@_use_none_delimit_by_s_mark:w
      }
%    \end{macrocode}
% 首先确保钩子的基本数据结构存在：
%    \begin{macrocode}
    \@@_init_structure:n {#1}
%    \end{macrocode}
% 然后清除两个标签之间的任何先前关系：
%    \begin{macrocode}
    \@@_rule_gclear:nnn {#1} {#2} {#4}
%    \end{macrocode}
% 接着调用处理给定规则的函数。如果规则无效，抛出错误。
%    \begin{macrocode}
    \cs_if_exist_use:cTF { @@_rule_#3_gset:nnn }
      {
          {#1} {#2} {#4}
        \@@_update_hook_code:n {#1}
      }
      {
        \msg_error:nnnnnn { hooks } { unknown-rule }
          {#1} {#2} {#3} {#4}
      }
    \s_@@_mark
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_gset_rule:nnnn}
%<latexrelease>                 {Refuse~setting~rule~for~one-time~hooks}
%<latexrelease>\cs_new_protected:Npn \@@_gset_rule:nnnn #1#2#3#4
%<latexrelease>  {
%<latexrelease>    \@@_if_deprecated_generic:nT {#1}
%<latexrelease>      {
%<latexrelease>        \@@_deprecated_generic_warn:n {#1}
%<latexrelease>        \@@_do_deprecated_generic:Nn \@@_gset_rule:nnnn {#1}
%<latexrelease>          {#2} {#3} {#4}
%<latexrelease>        \exp_after:wN \use_none:nnnnnnnnn \use_none:n
%<latexrelease>      }
%<latexrelease>    \@@_init_structure:n {#1}
%<latexrelease>    \@@_rule_gclear:nnn {#1} {#2} {#4}
%<latexrelease>    \cs_if_exist_use:cTF { @@_rule_#3_gset:nnn }
%<latexrelease>      {
%<latexrelease>          {#1} {#2} {#4}
%<latexrelease>        \@@_update_hook_code:n {#1}
%<latexrelease>      }
%<latexrelease>      {
%<latexrelease>        \msg_error:nnnnnn { hooks } { unknown-rule }
%<latexrelease>          {#1} {#2} {#3} {#4}
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_rule_before_gset:nnn, \@@_rule_after_gset:nnn,
%               \@@_rule_<_gset:nnn, \@@_rule_>_gset:nnn}
%    然后我们添加新规则。我们需要在这里对规则进行规范化，以便后续更快地进行处理。
%    对于一对标签 $l_A$ 和 $l_B$，规则 $l_A>l_B$ 与 $l_B<l_A$ 是相同的，
%    只是呈现方式不同。但通过将规则的形式规范化为单一表示，比如 $l_B<l_A$，
%    可大大减少后续寻找规则所需的时间。
%
%    在这里，我们使用\cs[no-index]{(pdf)strcmp}来按字典顺序排列标签 $l_A$ 和 $l_B$，
%    以固定顺序进行规范化。然后每次这两个标签一起使用时，都会强制执行这个顺序。
%
%    这里我们使用 \cs{@@_label_pair:nn}~\Arg{hook}~\Arg{l_A}~\Arg{l_B} 
%    来构建一个带有固定顺序的字符串 \texttt{$l_B$\string|$l_A$}，
%    并使用 \cs{@@_label_ordered:nnTF} 来根据是否排序应用正确的规则到这对标签。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_before_gset:nnn #1#2#3
  {
    \@@_tl_gset:cx { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
      { \@@_label_ordered:nnTF {#2} {#3} { < } { > } }
  }
\cs_new_eq:cN { @@_rule_<_gset:nnn } \@@_rule_before_gset:nnn
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_after_gset:nnn #1#2#3
  {
    \@@_tl_gset:cx { g_@@_#1_rule_ \@@_label_pair:nn {#3} {#2} _tl }
      { \@@_label_ordered:nnTF {#3} {#2} { < } { > } }
  }
\cs_new_eq:cN { @@_rule_>_gset:nnn } \@@_rule_after_gset:nnn
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_rule_voids_gset:nnn}
%   这个规则如果标签 |#2| 在钩子 |#1| 中，就会从标签 |#3| 中移除（实际上是清除）代码。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_voids_gset:nnn #1#2#3
  {
    \@@_tl_gset:cx { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
      { \@@_label_ordered:nnTF {#2} {#3} { -> } { <- } }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{
%     \@@_rule_incompatible-error_gset:nnn,
%     \@@_rule_incompatible-warning_gset:nnn,
%   }
%   如果标签 |#2| 和 |#3| 在钩子 |#1| 中同时出现，这些关系将产生错误/警告。
%    \begin{macrocode}
\cs_new_protected:cpn { @@_rule_incompatible-error_gset:nnn } #1#2#3
  { \@@_tl_gset:cn { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
                   { xE } }
\cs_new_protected:cpn { @@_rule_incompatible-warning_gset:nnn } #1#2#3
  { \@@_tl_gset:cn { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl }
                   { xW } }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_rule_unrelated_gset:nnn, \@@_rule_gclear:nnn}
%    撤销一个设置。\cs{@@_rule_unrelated_gset:nnn} 不需要执行任何操作，
%    因为我们在设置任何规则之前使用了 \cs{@@_rule_gclear:nnn}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_rule_unrelated_gset:nnn #1#2#3 { }
\cs_new_protected:Npn \@@_rule_gclear:nnn #1#2#3
  { \cs_undefine:c { g_@@_#1_rule_ \@@_label_pair:nn {#2} {#3} _tl } }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[EXP]{\@@_label_pair:nn}
%   确保字典顺序更大的标签排在前面。
%    \begin{macrocode}
\cs_new:Npn \@@_label_pair:nn #1#2
  {
    \if_case:w \@@_str_compare:nn {#1} {#2} \exp_stop_f:
           #1 | #1 %  0
    \or:   #1 | #2 % +1
    \else: #2 | #1 % -1
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_label_ordered:nn}
%   检查标签 |#1| 和 |#2| 是否按正确顺序排列（由 \cs{@@_label_pair:nn} 返回），
%   如果是则返回 true，否则返回 false。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_label_ordered:nn #1#2 { TF }
  {
    \if_int_compare:w \@@_str_compare:nn {#1} {#2} > 0 \exp_stop_f:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[EXP]{\@@_if_label_case:nnnnn}
%   为了避免在 \cs{@@_initialize_single:NNn} 中两次进行字符串比较
%   （一次是用 \cs{str_if_eq:nn}，另一次是用 \cs{@@_label_ordered:nn}），
%   我们使用一个三分支的宏来比较 |#1| 和 |#2|，
%   如果它们相等，则展开为 \cs{use_i:nnn}，
%   如果 |#1| 字典顺序更大，则展开为 \cs{use_ii:nn}，
%   否则展开为 \cs{use_iii:nn}。
%    \begin{macrocode}
\cs_new:Npn \@@_if_label_case:nnnnn #1#2
  {
    \cs:w use_
      \if_case:w \@@_str_compare:nn {#1} {#2}
         i \or: ii \else: iii \fi: :nnn
    \cs_end:
  }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@@_update_hook_code:n}
%    在 \verb=\begin{document}=  之前，这个命令不起作用；在文档正文中，它重新初始化了修改后的数据，
%    \begin{macrocode}
\cs_new_eq:NN \@@_update_hook_code:n \use_none:n
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\@@_initialize_all:}
%    初始化所有已知的钩子（在 \verb=\begin{document}= 处），即，更新快速执行令牌列表，
%    以正确顺序保存必要的代码。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_initialize_all:}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_initialize_all:
  {
%    \end{macrocode}
%    首先，我们将 \cs{@@_update_hook_code:n} 这个到目前为止什么都没做的命令改为现在初始化一个钩子。
%    这样，以后对钩子的任何更新都会运行该代码，并更新执行令牌列表。
%    \begin{macrocode}
    \cs_gset_eq:NN \@@_update_hook_code:n \@@_initialize_hook_code:n
%    \end{macrocode}
%    现在我们循环遍历所有已定义的钩子并更新每一个。在这里，我们必须确定钩子是否有参数，
%    这样辅助命令才知道如何处理井号（hash marks）。我们查看 \cs[no-index]{c_@@_\meta{hook}_parameter_tl}，
%    如果有任何参数，就相应地设置 \verb|replacing_args|。
%    \begin{macrocode}
    \@@_debug:n { \prop_gclear:N \g_@@_used_prop }
    \seq_map_inline:Nn \g_@@_all_seq
      {
        \tl_if_empty:cTF { c_@@_##1_parameter_tl }
          { \@@_replacing_args_false: }
          { \@@_replacing_args_true: }
        \@@_update_hook_code:n {##1}
        \@@_replacing_args_reset:
      }
%    \end{macrocode}
%    如果我们正在调试，我们逐个显示钩子的结果，对于所有具有数据的钩子。
%    \begin{macrocode}
    \@@_debug:n
      {
        \iow_term:x { ^^J All~initialized~(non-empty)~hooks: }
        \prop_map_inline:Nn \g_@@_used_prop
          {
            \iow_term:x
              { ^^J ~ ##1 ~ -> ~ \cs_replacement_spec:c { @@~##1 } ~ }
          }
      }
%    \end{macrocode}
%    在所有钩子被初始化之后，我们将“使用”更改为仅调用钩子代码，而不是初始化它（就像在导言部分做的那样）。
%    \begin{macrocode}
    \@@_post_initialization_defs:
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_initialize_all:}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_initialize_all:
%<latexrelease>  {
%<latexrelease>    \cs_gset_eq:NN \@@_update_hook_code:n \@@_initialize_hook_code:n
%<latexrelease>    \@@_debug:n { \prop_gclear:N \g_@@_used_prop }
%<latexrelease>    \seq_map_inline:Nn \g_@@_all_seq
%<latexrelease>      { \@@_update_hook_code:n {##1} }
%<latexrelease>    \@@_debug:n
%<latexrelease>      {
%<latexrelease>        \iow_term:x{^^JAll~ initialized~ (non-empty)~ hooks:}
%<latexrelease>        \prop_map_inline:Nn \g_@@_used_prop
%<latexrelease>          {
%<latexrelease>            \iow_term:x
%<latexrelease>              { ^^J ~ ##1 ~ -> ~ \cs_replacement_spec:c { @@~##1 } ~ }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>    \cs_gset_eq:NN \hook_use:n \@@_use_initialized:n
%<latexrelease>    \cs_gset_eq:NN \@@_preamble_hook:n \use_none:n
%<latexrelease>  }
%<@@=>
%<latexrelease>\cs_gset_eq:NN \@expl@@@initialize@all@@
%<latexrelease>               \__hook_initialize_all:
%<@@=hook>
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\@@_initialize_hook_code:n}
%    初始化或重新初始化快速执行的钩子代码。在导言部分，这是有选择地进行的，以防某个钩子被使用，
%    而在 \verb=\begin{document}= 处，这是对所有钩子进行的，然后仅在钩子代码更改后进行。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_initialize_hook_code:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_initialize_hook_code:n #1
  {
    \@@_debug:n
      { \iow_term:x { ^^J Update~code~for~hook~'#1' \on@line :^^J } }
%    \end{macrocode}
% 这部分负责排序和更新。
% 首先我们检查旧版钩子宏是否存在，如果存在，我们将其添加到标签 \texttt{legacy} 下的钩子中。
% 这可能会使钩子变得非空，因此我们必须在随后的测试之前执行此操作。
%    \begin{macrocode}
    \@@_include_legacy_code_chunk:n {#1}
%    \end{macrocode}
% 如果当前钩子没有任何代码块，那么甚至启动排序程序都没有意义，所以我们做了一个快速测试，在这种情况下，
% 只需更新 \cs{@@\textvisiblespace\meta{hook}} 以包含 |top-level| 和 |next| 代码块即可。
% 如果存在代码块，我们调用 \cs{@@_initialize_single:NNn} 并将其传递给它准备好的控制序列名称，
% 因为这些名称在内部需要多次使用。这样做可以节省一些处理时间，如果提前进行这些操作。
% \changes{v1.0u}{2022/05/17}{拒绝对一次性钩子进行排序 (gh/818)。}
%    \begin{macrocode}
    \@@_if_usable:nT {#1}
      {
        \prop_if_empty:cTF { g_@@_#1_code_prop }
          {
            \@@_code_gset:ne {#1}
              {
%    \end{macrocode}
% 钩子可能带有参数，因此我们在 \verb|_next| 和 \verb|_toplevel| 宏之后添加了一系列大括号参数，
% 以便将传递给钩子的参数转发给它们。
%    \begin{macrocode}
                \exp_not:c { @@_toplevel~#1 } \@@_braced_parameter:n {#1}
                \exp_not:c { @@_next~#1 } \@@_braced_parameter:n {#1}
              }
          }
          {
%    \end{macrocode}
% 默认情况下，算法对代码块进行排序，然后将结果保存在一个 token list 中以进行快速执行；
% 这是通过逐个添加代码块来完成的，使用 \cs{tl_gput_right:NV}。
% 当我们对反向钩子的代码进行排序时，我们所要做的就是按相反的顺序将代码块添加到 token list 中。
% 因此，在准备阶段，我们需要做的就是更改后续使用的两个定义。
%    \begin{macrocode}
            \@@_if_reversed:nTF {#1}
              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_left:Nn
                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_left:NV  }
              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_right:Nn
                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_right:NV }
%    \end{macrocode}
%
% 在排序过程中，某些关系（即 \verb|voids|）需要在代码属性列表上进行破坏性操作，
% 以删除不应出现在排序后的钩子 token list 中的代码，因此我们制作了代码属性列表的副本，
% 可以在不更改主要列表的情况下安全地进行操作。
%    \begin{macrocode}
            \prop_set_eq:Nc \l_@@_work_prop { g_@@_#1_code_prop }
            \@@_initialize_single:ccn
              { @@~#1 } { g_@@_#1_labels_clist } {#1}
%    \end{macrocode}
% 对于调试显示，我们希望跟踪实际添加了代码的那些钩子，因此我们在 plist 中记录下来。
% 我们使用 plist 来确保仅记录每个钩子名称一次，即，我们只对键进行记录，值是任意的。
%    \begin{macrocode}
            \@@_debug:n
              { \exp_args:NNx \prop_gput:Nnn \g_@@_used_prop {#1} { } }
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_initialize_hook_code:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_initialize_hook_code:n #1
%<latexrelease>  {
%<latexrelease>    \@@_debug:n
%<latexrelease>      { \iow_term:x { ^^J Update~code~for~hook~'#1' \on@line :^^J } }
%<latexrelease>    \@@_include_legacy_code_chunk:n {#1}
%<latexrelease>    \@@_if_usable:nT {#1}
%<latexrelease>      {
%<latexrelease>        \prop_if_empty:cTF { g_@@_#1_code_prop }
%<latexrelease>          {
%<latexrelease>            \@@_tl_gset:co { @@~#1 }
%<latexrelease>              {
%<latexrelease>                \cs:w @@_toplevel~#1 \exp_after:wN \cs_end:
%<latexrelease>                \cs:w @@_next~#1 \cs_end:
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \@@_if_reversed:nTF {#1}
%<latexrelease>              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_left:Nn
%<latexrelease>                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_left:NV  }
%<latexrelease>              { \cs_set_eq:NN \@@_tl_gput:Nn    \@@_tl_gput_right:Nn
%<latexrelease>                \cs_set_eq:NN \@@_clist_gput:NV \clist_gput_right:NV }
%<latexrelease>            \prop_set_eq:Nc \l_@@_work_prop { g_@@_#1_code_prop }
%<latexrelease>            \@@_initialize_single:ccn
%<latexrelease>              { @@~#1 } { g_@@_#1_labels_clist } {#1}
%<latexrelease>            \@@_debug:n
%<latexrelease>              { \exp_args:NNx \prop_gput:Nnn \g_@@_used_prop {#1} { } }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}[EXP]{\@@_tl_csname:n,\@@_seq_csname:n}
% 更快的方法是传递一个单一的记号，并在需要时展开它，而不是传递一堆字符记号。
% \fmiinline{自己的备注：验证}
%    \begin{macrocode}
\cs_new:Npn \@@_tl_csname:n #1 { l_@@_label_#1_tl }
\cs_new:Npn \@@_seq_csname:n #1 { l_@@_label_#1_seq }
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}{\l_@@_labels_seq,\l_@@_labels_int,\l_@@_front_tl,
%      \l_@@_rear_tl,\l_@@_label_0_tl}
%
% 对于排序，我基本上实现了Knuth在《计算机程序设计艺术》第1卷263--266页中给出的拓扑排序算法。
% 对于这个算法，我们需要一些局部变量：
% \begin{itemize}
% \item
%    用于标记代码块的当前钩子中使用的标签列表：
%    \begin{macrocode}
\seq_new:N \l_@@_labels_seq
%    \end{macrocode}
% \item
%   当前钩子中使用的标签数量。在Knuth的算法中，这被称为 $N$：
%    \begin{macrocode}
\int_new:N \l_@@_labels_int
%    \end{macrocode}
% \item
%   要构建的排序代码列表由两个指针管理，一个指向队列的前端，一个指向后端。我们使用记号列表指针来模拟这一点。
%   Knuth将它们称为 $F$ 和 $R$：
%    \begin{macrocode}
\tl_new:N \l_@@_front_tl
\tl_new:N \l_@@_rear_tl
%    \end{macrocode}
% \item
%   队列起始处的数据保存在此记号列表中，它对应于Don称之为 \texttt{QLINK[0]} 的内容，
%   但由于我们不是在内存中操作单个字，因此稍有不同的处理方式：
%    \begin{macrocode}
\tl_new:c { \@@_tl_csname:n { 0 } }
%    \end{macrocode}
%
%    \end{itemize}
%  \end{macro}
%
%
%  \begin{macro}{\@@_initialize_single:NNn,\@@_initialize_single:ccn}
%
% \cs{@@_initialize_single:NNn} 实现了钩子代码块的排序，并将结果保存在令牌列表中以便快速执行（\verb=#4=）。参数包括 \meta{hook-code-plist}、\meta{hook-code-tl}、\meta{hook-top-level-code-tl}、\meta{hook-next-code-tl}、\meta{hook-ordered-labels-clist} 和 \meta{hook-name}（后者仅用于调试---\meta{hook-rule-plist}通过 \meta{hook-name} 访问）。
%
% 与Don的算法相比，额外的复杂性在于我们不使用简单的正整数，而是任意的字母数字标签。与往常一样，Don的数据结构设计得可以省略很多测试，我尽可能地模仿了这一点。结果是一个我目前不测试的限制：标签不能等于数字 0！
% \fmiinline{需要检查一下，以防万一...也许}
%
%    ^^A #1 <- \@@~#1
%    ^^A #2 <- \g_@@_#1_labels_clist
%    ^^A #3 <- #1
%
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_initialize_single:NNn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_initialize_single:NNn #1#2#3
  {
%    \end{macrocode}
%    步骤 T1：初始化数据结构 \ldots
%    \begin{macrocode}
    \seq_clear:N \l_@@_labels_seq
    \int_zero:N  \l_@@_labels_int
%    \end{macrocode}
%
%    存储钩子的名称：
%    \begin{macrocode}
    \tl_set:Nn \l_@@_cur_hook_tl {#3}
%    \end{macrocode}
%
%    我们循环遍历持有代码的属性列表，并记录所有在其中列出的标签。我们只关心那些标签的规则。在此过程中，我们计数（这给了我们 Knuth 算法中的 $N$）。为了确保名为 |front|、|rear|、|labels| 或 |return| 的标签不会与我们的代码发生冲突，我们在变量前加上前缀 |label_|。
%    \begin{macrocode}
    \prop_map_inline:Nn \l_@@_work_prop
       {
         \int_incr:N \l_@@_labels_int
         \seq_put_right:Nn \l_@@_labels_seq {##1}
         \@@_tl_set:cn { \@@_tl_csname:n {##1} } { 0 }
         \seq_clear_new:c { \@@_seq_csname:n {##1} }
       }
%    \end{macrocode}
%    步骤 T2 和 T3：在这里，我们将相关的规则排序到数据结构中 \ldots
%
%    这个循环构成了 \cs{l_@@_work_prop} 中标签的垂直和水平方向上的方阵。然而，由于规则 $l_A\meta{rel}l_B$ 与 $l_B\meta{rel}^{-1}l_A$ 是相同的，我们可以在矩阵的对角线处提前结束循环（即，当两个标签相等时），节省了大量时间。规则的设置方式（参见上面的 \cs{@@_rule_before_gset:nnn} 的实现）确保我们在矩阵的被忽略侧没有规则，并且所有规则都被考虑到。规则在 \cs{@@_apply_label_pair:nnn} 中被应用，该命令以正确排序的标签对作为参数。
%    \begin{macrocode}
    \prop_map_inline:Nn \l_@@_work_prop
      {
        \prop_map_inline:Nn \l_@@_work_prop
          {
            \@@_if_label_case:nnnnn {##1} {####1}
              { \prop_map_break: }
              { \@@_apply_label_pair:nnn {##1} {####1} }
              { \@@_apply_label_pair:nnn {####1} {##1} }
                  {#3}
          }
      }
%    \end{macrocode}
%    现在休息一下，看看已经设置好的数据结构：
%    \begin{macrocode}
    \@@_debug:n { \@@_debug_label_data:N \l_@@_work_prop }
%    \end{macrocode}
%
%
%    步骤 T4：
%    \begin{macrocode}
    \tl_set:Nn \l_@@_rear_tl { 0 }
    \tl_set:cn { \@@_tl_csname:n { 0 } } { 0 }
    \seq_map_inline:Nn \l_@@_labels_seq
      {
        \int_compare:nNnT { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
            {
              \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } }{##1}
              \tl_set:Nn \l_@@_rear_tl {##1}
            }
      }
    \tl_set_eq:Nc \l_@@_front_tl { \@@_tl_csname:n { 0 } }
%    \end{macrocode}
%
%    \begin{macrocode}
    \@@_tl_gclear:N #1
    \clist_gclear:N #2
%    \end{macrocode}
%
%    整个循环在步骤 T5--T7 中组合起来：
%    \begin{macrocode}
    \bool_while_do:nn { ! \str_if_eq_p:Vn \l_@@_front_tl { 0 } }
      {
%    \end{macrocode}
%    这部分是步骤 T5：
%    \begin{macrocode}
        \int_decr:N \l_@@_labels_int
        \prop_get:NVN \l_@@_work_prop \l_@@_front_tl \l_@@_return_tl
        \exp_args:NNV \@@_tl_gput:Nn #1 \l_@@_return_tl
%    \end{macrocode}
%
%    \begin{macrocode}
        \@@_clist_gput:NV #2 \l_@@_front_tl
        \@@_debug:n{ \iow_term:x{Handled~ code~ for~ \l_@@_front_tl} }
%    \end{macrocode}
%
%    这是步骤 T6，不过我们不使用指针 $P$ 来遍历后继项，而是使用映射函数的 \verb=##1=。
%    \begin{macrocode}
        \seq_map_inline:cn { \@@_seq_csname:n { \l_@@_front_tl } }
          {
            \tl_set:cx { \@@_tl_csname:n {##1} }
                       { \int_eval:n
                           { \cs:w \@@_tl_csname:n {##1} \cs_end: - 1 }
                       }
            \int_compare:nNnT
                { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
                {
                  \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } } {##1}
                  \tl_set:Nn \l_@@_rear_tl            {##1}
                }
          }
%    \end{macrocode}
%    这是步骤 T7：
%    \begin{macrocode}
        \tl_set_eq:Nc \l_@@_front_tl
                      { \@@_tl_csname:n { \l_@@_front_tl } }
%    \end{macrocode}
%
%    这是步骤 T8：如果我们还没有移动所有标签的代码（即，如果 \cs{l_@@_labels_int} 仍大于零），我们就有一个循环，我们的偏序关系无法被展开。
%    \begin{macrocode}
      }
    \int_compare:nNnF \l_@@_labels_int = 0
      {
        \iow_term:x{====================}
        \iow_term:x{Error:~ label~ rules~ are~ incompatible:}
%    \end{macrocode}
%
%    在错误情况下，这不是真正需要的信息，但现在先这样吧 \ldots \fmiinline{在某个雨天改善输出}
%    \begin{macrocode}
        \@@_debug_label_data:N \l_@@_work_prop
        \iow_term:x{====================}
      }
%    \end{macrocode}
%    在我们将所有钩子代码添加到 \verb=#1= 后，我们通过为 |top-level| (\verb=#2=) 和单次执行 (\verb=#3=) 添加额外的代码来完成它。这些通常应该是空的。|top-level| 代码是用 \cs{@@_tl_gput:Nn} 添加的，因为对于反转钩子，它可能会发生变化（那么 |top-level| 就是添加的第一个代码块）。|next| 代码始终添加在最后（在右侧）。钩子可能带有参数，所以我们在 \verb|_next| 和 \verb|_toplevel| 宏之后添加了一串大括号参数，以便将传递给钩子的参数转发给它们。
%    \begin{macrocode}
    \exp_args:NNe \@@_tl_gput:Nn #1
      { \exp_not:c { @@_toplevel~#3 } \@@_braced_parameter:n {#3} }
    \@@_tl_gput_right:Ne #1
      { \exp_not:c { @@_next~#3 } \@@_braced_parameter:n {#3} }
    \use:e
      {
        \cs_gset:cpn { @@~#3 } \use:c { c_@@_#3_parameter_tl }
          { \exp_not:V #1 }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_initialize_single:NNn { cc }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_initialize_single:NNn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_initialize_single:NNn #1#2#3
%<latexrelease>  {
%<latexrelease>    \seq_clear:N \l_@@_labels_seq
%<latexrelease>    \int_zero:N  \l_@@_labels_int
%<latexrelease>    \tl_set:Nn \l_@@_cur_hook_tl {#3}
%<latexrelease>    \prop_map_inline:Nn \l_@@_work_prop
%<latexrelease>       {
%<latexrelease>         \int_incr:N \l_@@_labels_int
%<latexrelease>         \seq_put_right:Nn \l_@@_labels_seq {##1}
%<latexrelease>         \@@_tl_set:cn { \@@_tl_csname:n {##1} } { 0 }
%<latexrelease>         \seq_clear_new:c { \@@_seq_csname:n {##1} }
%<latexrelease>       }
%<latexrelease>    \prop_map_inline:Nn \l_@@_work_prop
%<latexrelease>      {
%<latexrelease>        \prop_map_inline:Nn \l_@@_work_prop
%<latexrelease>          {
%<latexrelease>            \@@_if_label_case:nnnnn {##1} {####1}
%<latexrelease>              { \prop_map_break: }
%<latexrelease>              { \@@_apply_label_pair:nnn {##1} {####1} }
%<latexrelease>              { \@@_apply_label_pair:nnn {####1} {##1} }
%<latexrelease>                  {#3}
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>    \@@_debug:n { \@@_debug_label_data:N \l_@@_work_prop }
%<latexrelease>    \tl_set:Nn \l_@@_rear_tl { 0 }
%<latexrelease>    \tl_set:cn { \@@_tl_csname:n { 0 } } { 0 }
%<latexrelease>    \seq_map_inline:Nn \l_@@_labels_seq
%<latexrelease>      {
%<latexrelease>        \int_compare:nNnT { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
%<latexrelease>            {
%<latexrelease>              \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } }{##1}
%<latexrelease>              \tl_set:Nn \l_@@_rear_tl {##1}
%<latexrelease>            }
%<latexrelease>      }
%<latexrelease>    \tl_set_eq:Nc \l_@@_front_tl { \@@_tl_csname:n { 0 } }
%<latexrelease>    \@@_tl_gclear:N #1
%<latexrelease>    \clist_gclear:N #2
%<latexrelease>    \bool_while_do:nn { ! \str_if_eq_p:Vn \l_@@_front_tl { 0 } }
%<latexrelease>      {
%<latexrelease>        \int_decr:N \l_@@_labels_int
%<latexrelease>        \prop_get:NVN \l_@@_work_prop \l_@@_front_tl \l_@@_return_tl
%<latexrelease>        \exp_args:NNV \@@_tl_gput:Nn #1 \l_@@_return_tl
%<latexrelease>        \@@_clist_gput:NV #2 \l_@@_front_tl
%<latexrelease>        \@@_debug:n{ \iow_term:x{Handled~ code~ for~ \l_@@_front_tl} }
%<latexrelease>        \seq_map_inline:cn { \@@_seq_csname:n { \l_@@_front_tl } }
%<latexrelease>          {
%<latexrelease>            \tl_set:cx { \@@_tl_csname:n {##1} }
%<latexrelease>                       { \int_eval:n
%<latexrelease>                           { \cs:w \@@_tl_csname:n {##1} \cs_end: - 1 }
%<latexrelease>                       }
%<latexrelease>            \int_compare:nNnT
%<latexrelease>                { \cs:w \@@_tl_csname:n {##1} \cs_end: } = 0
%<latexrelease>                {
%<latexrelease>                  \tl_set:cn { \@@_tl_csname:n { \l_@@_rear_tl } } {##1}
%<latexrelease>                  \tl_set:Nn \l_@@_rear_tl            {##1}
%<latexrelease>                }
%<latexrelease>          }
%<latexrelease>        \tl_set_eq:Nc \l_@@_front_tl
%<latexrelease>                      { \@@_tl_csname:n { \l_@@_front_tl } }
%<latexrelease>      }
%<latexrelease>    \int_compare:nNnF \l_@@_labels_int = 0
%<latexrelease>      {
%<latexrelease>        \iow_term:x{====================}
%<latexrelease>        \iow_term:x{Error:~ label~ rules~ are~ incompatible:}
%<latexrelease>        \@@_debug_label_data:N \l_@@_work_prop
%<latexrelease>        \iow_term:x{====================}
%<latexrelease>      }
%<latexrelease>    \exp_args:NNo \@@_tl_gput:Nn #1 { \cs:w @@_toplevel~#3 \cs_end: }
%<latexrelease>    \@@_tl_gput_right:No #1 { \cs:w @@_next~#3 \cs_end: }
%<latexrelease>  }
%<latexrelease>\cs_generate_variant:Nn \@@_tl_gput_right:Nn { No }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\@@_tl_gput:Nn,\@@_clist_gput:NV}
%    这些要么添加在右侧（正常钩子），要么添加在左侧（反转钩子）。这是在 \cs{@@_initialize_hook_code:n} 中设置的，在其他地方它们的行为是未定义的。
%    \begin{macrocode}
\cs_new:Npn \@@_tl_gput:Nn    { \ERROR }
\cs_new:Npn \@@_clist_gput:NV { \ERROR }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\@@_apply_label_pair:nnn,\@@_label_if_exist_apply:nnnF}
%
%    这是在上面描述的循环中执行的步骤 T2 和 T3 的有效载荷。这个宏假设 |#1| 和 |#2| 是有序的，这意味着与对应对 |#1| 和 |#2| 的任何规则是 \cs{g_@@_\meta{hook}_rule_\#1\string|\#2_tl} 相关，而不是 \cs{g_@@_\meta{hook}_rule_\#2\string|\#1_tl}。这也节省了大量时间，因为我们只需要检查标签的顺序一次。
%
%    这里的参数是 \meta{label1}、\meta{label2}、\meta{hook} 和 \meta{hook-code-plist}。我们将要应用下一个规则并将其输入到数据结构中。 \cs{@@_apply_label_pair:nnn} 将只为 \meta{hook} 调用 \cs{@@_label_if_exist_apply:nnnF}，如果找不到规则，还将尝试使用表示默认钩子规则的 \meta{hook} 名称 \texttt{??}。
%
%    \cs{@@_label_if_exist_apply:nnnF} 将检查给定钩子的规则是否存在，如果存在，则调用 \cs{@@_apply_rule:nnn}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_apply_label_pair:nnn #1#2#3
  {
%    \end{macrocode}
%    额外的复杂性：由于我们使用默认规则和本地钩子特定规则，我们首先必须检查是否存在本地规则，如果存在，则使用它。否则检查是否存在默认规则，然后使用它。
%    \begin{macrocode}
    \@@_label_if_exist_apply:nnnF {#1} {#2} {#3}
      {
%    \end{macrocode}
%    如果没有钩子特定的规则，我们检查是否存在默认规则，并在存在时使用它。
%    \begin{macrocode}
        \@@_label_if_exist_apply:nnnF {#1} {#2} { ?? } { }
      }
  }
\cs_new_protected:Npn \@@_label_if_exist_apply:nnnF #1#2#3
  {
    \if_cs_exist:w g_@@_ #3 _rule_ #1 | #2 _tl \cs_end:
%    \end{macrocode}
%    具体要做什么取决于我们遇到的规则类型。如果是一个 \texttt{before} 规则，它将由算法处理，但其他类型需要以不同的方式进行管理。所有这些都在 \cs{@@_apply_rule:nnnN} 中完成。
%    \begin{macrocode}
      \@@_apply_rule:nnn {#1} {#2} {#3}
      \exp_after:wN \use_none:n
    \else:
      \use:nn
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
%
%
%
%  \begin{macro}{\@@_apply_rule:nnn}
%    这是在循环遍历矩阵时执行的步骤 T2 和 T3 的代码。这是步骤 T3 的一部分。我们将要应用下一个规则并将其输入到数据结构中。参数是 \meta{label1}、\meta{label2}、\meta{hook-name} 和 \meta{hook-code-plist}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_apply_rule:nnn #1#2#3
  {
    \cs:w @@_apply_
      \cs:w g_@@_#3_reversed_tl \cs_end: rule_
        \cs:w g_@@_ #3 _rule_ #1 | #2 _tl \cs_end: :nnn \cs_end:
      {#1} {#2} {#3}
  }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\@@_apply_rule_<:nnn,\@@_apply_rule_>:nnn}
%    最常见的情况是 \texttt{\string<} 和 \texttt{\string>}，所以我们首先处理它们。它们在 TAOCP 中是关系 $\prec$ 和 $\succ$，并且它们决定了排序。
%    \begin{macrocode}
\cs_new_protected:cpn { @@_apply_rule_<:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \tl_set:cx { \@@_tl_csname:n {#2} }
       { \int_eval:n{ \cs:w \@@_tl_csname:n {#2} \cs_end: + 1 } }
    \seq_put_right:cn{ \@@_seq_csname:n {#1} }{#2}
  }
\cs_new_protected:cpn { @@_apply_rule_>:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \tl_set:cx { \@@_tl_csname:n {#1} }
       { \int_eval:n{ \cs:w \@@_tl_csname:n {#1} \cs_end: + 1 } }
    \seq_put_right:cn{ \@@_seq_csname:n {#2} }{#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_apply_rule_xE:nnn,\@@_apply_rule_xW:nnn}
%    这些关系使得钩子中的两个标签不兼容。
%    |xE| 如果在同一个钩子中发现这些标签，就会引发错误；|xW| 则会发出警告。
%    \begin{macrocode}
\cs_new_protected:cpn { @@_apply_rule_xE:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \msg_error:nnnnnn { hooks } { labels-incompatible }
      {#1} {#2} {#3} { 1 }
    \use:c { @@_apply_rule_->:nnn } {#1} {#2} {#3}
    \use:c { @@_apply_rule_<-:nnn } {#1} {#2} {#3}
  }
\cs_new_protected:cpn { @@_apply_rule_xW:nnn } #1#2#3
  {
    \@@_debug:n { \@@_msg_pair_found:nnn {#1} {#2} {#3} }
    \msg_warning:nnnnnn { hooks } { labels-incompatible }
      {#1} {#2} {#3} { 0 }
  }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\@@_apply_rule_->:nnn,\@@_apply_rule_<-:nnn}
%    如果我们看到 \texttt{\detokenize{->}}，我们必须丢弃标签 \verb=#3= 的代码并继续。我们可以更好地做一点，丢弃该标签的所有内容，因为我们放置这样的空代码并不重要。但是，这会使算法变得更加复杂，而收益很少。\footnote{这也有一个优点，即排序的结果不会改变，否则（如果我们不小心）可能会导致（对于不相关的代码块）结果发生变化。} 因此，我们仍然不必要地尝试对其进行排序，具体取决于规则，这可能会导致一个本来可以解决的循环。如果这变成了一个真正的问题，我们可以改进代码。
%
%    在这里，我们从 \cs{l_@@_cur_hook_tl} 中删除代码，而不是从 \verb=#3=，因为后者可能是 \texttt{??}，而默认钩子不存储任何代码。而是从 \cs{l_@@_cur_hook_tl} 中删除它，可以使默认规则 \verb=->= 和 \verb=<-= 正常工作。
%    \begin{macrocode}
\cs_new_protected:cpn { @@_apply_rule_->:nnn } #1#2#3
  {
    \@@_debug:n
       {
         \@@_msg_pair_found:nnn {#1} {#2} {#3}
         \iow_term:x{--->~ Drop~ '#2'~ code~ from~
           \iow_char:N \\ g_@@_ \l_@@_cur_hook_tl _code_prop ~
           because~ of~ '#1' }
       }
    \prop_put:Nnn \l_@@_work_prop {#2} { }
  }
\cs_new_protected:cpn { @@_apply_rule_<-:nnn } #1#2#3
  {
    \@@_debug:n
       {
         \@@_msg_pair_found:nnn {#1} {#2} {#3}
         \iow_term:x{--->~ Drop~ '#1'~ code~ from~
           \iow_char:N \\ g_@@_ \l_@@_cur_hook_tl _code_prop ~
           because~ of~ '#2' }
       }
    \prop_put:Nnn \l_@@_work_prop {#1} { }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{
%     \@@_apply_-rule_<:nnn,
%     \@@_apply_-rule_>:nnn,
%     \@@_apply_-rule_<-:nnn,
%     \@@_apply_-rule_->:nnn,
%     \@@_apply_-rule_xW:nnn,
%     \@@_apply_-rule_xE:nnn,
%   }
%   反转规则。
%    \begin{macrocode}
\cs_new_eq:cc { @@_apply_-rule_<:nnn } { @@_apply_rule_>:nnn }
\cs_new_eq:cc { @@_apply_-rule_>:nnn } { @@_apply_rule_<:nnn }
\cs_new_eq:cc { @@_apply_-rule_<-:nnn } { @@_apply_rule_<-:nnn }
\cs_new_eq:cc { @@_apply_-rule_->:nnn } { @@_apply_rule_->:nnn }
\cs_new_eq:cc { @@_apply_-rule_xE:nnn } { @@_apply_rule_xE:nnn }
\cs_new_eq:cc { @@_apply_-rule_xW:nnn } { @@_apply_rule_xW:nnn }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_msg_pair_found:nnn}
%   一个宏，用来避免移动这么多标记。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_msg_pair_found:nnn #1#2#3
  {
    \iow_term:x{~ \str_if_eq:nnTF {#3} {??} {default} {~normal} ~
        rule~ \@@_label_pair:nn {#1} {#2}:~
        \use:c { g_@@_#3_rule_ \@@_label_pair:nn {#1} {#2} _tl } ~
        found}
  }
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}{\@@_debug_label_data:N}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_debug_label_data:N #1 {
  \iow_term:x{Code~ labels~ for~ sorting:}
  \iow_term:x{~ \seq_use:Nnnn\l_@@_labels_seq {~and~}{,~}{~and~} }
  \iow_term:x{^^J Data~ structure~ for~ label~ rules:}
  \prop_map_inline:Nn #1
       {
         \iow_term:x{~ ##1~ =~ \tl_use:c{ \@@_tl_csname:n {##1} }~ ->~
           \seq_use:cnnn{ \@@_seq_csname:n {##1} }{~->~}{~->~}{~->~}
         }
       }
  \iow_term:x{}
}
%    \end{macrocode}
%  \end{macro}
%
%
%
% \begin{macro}{\hook_show:n,\hook_log:n}
% \begin{macro}{\@@_log_line:x,\@@_log_line_indent:x}
% \begin{macro}{\@@_log:nN}
%  这个宏根据其参数提供的钩子信息将内容写入到 \texttt{.log} 文件和终端（如果使用了 \cs{show_hook:n}）。在内部，两者共享相同的结构，除了在最后，\cs{hook_show:n} 会触发 TeX 的提示。
%    \begin{macrocode}
\cs_new_protected:Npn \hook_log:n #1
  {
    \cs_set_eq:NN \@@_log_cmd:x \iow_log:x
    \@@_normalize_hook_args:Nn \@@_log:nN {#1} \tl_log:x
  }
\cs_new_protected:Npn \hook_show:n #1
  {
    \cs_set_eq:NN \@@_log_cmd:x \iow_term:x
    \@@_normalize_hook_args:Nn \@@_log:nN {#1} \tl_show:x
  }
\cs_new_protected:Npn \@@_log_line:x #1
  { \@@_log_cmd:x { >~#1 } }
\cs_new_protected:Npn \@@_log_line_indent:x #1
  { \@@_log_cmd:x { >~\@spaces #1 } }
%    \end{macrocode}
%
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_log:nN}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_log:nN #1 #2
  {
    \@@_if_deprecated_generic:nT {#1}
      {
        \@@_deprecated_generic_warn:n {#1}
        \@@_do_deprecated_generic:Nn \@@_log:nN {#1} #2
        \exp_after:wN \use_none:nnnnnnnnn \use_none:nnnnn
      }
    \@@_preamble_hook:n {#1}
    \@@_log_cmd:x
      {
        ^^J ->~The~
        \@@_if_generic:nT {#1} { generic~ }
        hook~'#1'
        \@@_if_disabled:nF {#1}
          {
            \exp_args:Nf \@@_print_args:nn {#1}
              {
                \int_eval:n
                  { \str_count:e { \@@_parameter:n {#1} } / 3 }
              }
          }
        :
      }
%    \end{macrocode}
%
%    \begin{macrocode}
    \@@_if_usable:nF {#1}
      { \@@_log_line:x { The~hook~is~not~declared. } }
    \@@_if_disabled:nT {#1}
      { \@@_log_line:x { The~hook~is~disabled. } }
    \hook_if_empty:nTF {#1}
      { #2 { The~hook~is~empty } }
      {
        \@@_log_line:x { Code~chunks: }
        \prop_if_empty:cTF { g_@@_#1_code_prop }
          { \@@_log_line_indent:x { --- } }
          {
            \prop_map_inline:cn { g_@@_#1_code_prop }
              {
                \exp_after:wN \cs_set:Npn \exp_after:wN \@@_tmp:w
                  \c_@@_nine_parameters_tl {##2}
                \@@_log_line_indent:x
                  { ##1~->~\cs_replacement_spec:N \@@_tmp:w }
              }
          }
%    \end{macrocode}
%
%    如果在 |top-level| 令牌列表中有代码，则打印它：
%    \begin{macrocode}
        \@@_log_line:x
          {
            Document-level~(top-level)~code
            \@@_if_usable:nT {#1}
              { ~(executed~\@@_if_reversed:nTF {#1} {first} {last} ) } :
          }
        \@@_log_line_indent:x
          {
            \@@_cs_if_empty:cTF { @@_toplevel~#1 }
              { --- }
              { -> ~ \cs_replacement_spec:c { @@_toplevel~#1 } }
          }
%    \end{macrocode}
%
%    \begin{macrocode}
        \@@_log_line:x { Extra~code~for~next~invocation: }
        \@@_log_line_indent:x
          {
            \@@_cs_if_empty:cTF { @@_next~#1 }
              { --- }
%    \end{macrocode}
%
% 如果令牌列表不为空，我们想要显示它，但不包括第一个标记（用于清除自身的代码），所以我们调用一个辅助命令来去掉它们。
%    \begin{macrocode}
              {
                -> ~ \exp_last_unbraced:Nf \@@_log_next_code:w
                  { \cs_replacement_spec:c { @@_next~#1 } }
              }
          }
%    \end{macrocode}
%
% 循环遍历钩子中的规则，并对找到的每个规则进行打印。如果没有规则，则打印 |---|。这里的布尔变量 \cs{l_@@_tmpa_bool} 表示钩子是否没有规则。
%    \begin{macrocode}
        \@@_log_line:x { Rules: }
        \bool_set_true:N \l_@@_tmpa_bool
        \@@_list_rules:nn {#1}
          {
            \bool_set_false:N \l_@@_tmpa_bool
            \@@_log_line_indent:x
              {
                ##2~ with~
                \str_if_eq:nnT {##3} {??} { default~ }
                relation~ ##1
              }
          }
        \bool_if:NT \l_@@_tmpa_bool
          { \@@_log_line_indent:x { --- } }
%    \end{macrocode}
%
% 当钩子被声明（即，排序算法应用到该钩子上）且不为空时
%    \begin{macrocode}
        \bool_lazy_and:nnTF
            { \@@_if_usable_p:n {#1} }
            { ! \hook_if_empty_p:n {#1} }
          {
            \@@_log_line:x
              {
                Execution~order
                \bool_if:NTF \l_@@_tmpa_bool
                  { \@@_if_reversed:nT {#1} { ~(after~reversal) } }
                  { ~(after~
                    \@@_if_reversed:nT {#1} { reversal~and~ }
                    applying~rules)
                  } :
              }
            #2 % \tl_show:n
              {
                \@spaces
                \clist_if_empty:cTF { g_@@_#1_labels_clist }
                  { --- }
                  { \clist_use:cn { g_@@_#1_labels_clist } { ,~ } }
              }
          }
          {
            \@@_log_line:x { Execution~order: }
            #2
              {
                \@spaces Not~set~because~the~hook~ \@@_if_usable:nTF {#1}
                  { code~pool~is~empty }
                  { is~\@@_if_disabled:nTF {#1} {disabled} {undeclared} }
              }
          }
      }
  }
%<latexrelease>\EndIncludeInRelease
%
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_log:nN}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_log:nN #1 #2
%<latexrelease>  {
%<latexrelease>    \@@_if_deprecated_generic:nT {#1}
%<latexrelease>      {
%<latexrelease>        \@@_deprecated_generic_warn:n {#1}
%<latexrelease>        \@@_do_deprecated_generic:Nn \@@_log:nN {#1} #2
%<latexrelease>        \exp_after:wN \use_none:nnnnnnnnn \use_none:nnnnn
%<latexrelease>      }
%<latexrelease>    \@@_preamble_hook:n {#1}
%<latexrelease>    \@@_log_cmd:x
%<latexrelease>      { ^^J ->~The~ \@@_if_generic:nT {#1} { generic~ } hook~'#1': }
%<latexrelease>    \@@_if_usable:nF {#1}
%<latexrelease>      { \@@_log_line:x { The~hook~is~not~declared. } }
%<latexrelease>    \@@_if_disabled:nT {#1}
%<latexrelease>      { \@@_log_line:x { The~hook~is~disabled. } }
%<latexrelease>    \hook_if_empty:nTF {#1}
%<latexrelease>      { #2 { The~hook~is~empty } }
%<latexrelease>      {
%<latexrelease>        \@@_log_line:x { Code~chunks: }
%<latexrelease>        \prop_if_empty:cTF { g_@@_#1_code_prop }
%<latexrelease>          { \@@_log_line_indent:x { --- } }
%<latexrelease>          {
%<latexrelease>            \prop_map_inline:cn { g_@@_#1_code_prop }
%<latexrelease>              { \@@_log_line_indent:x { ##1~->~\tl_to_str:n {##2} } }
%<latexrelease>          }
%<latexrelease>        \@@_log_line:x
%<latexrelease>          {
%<latexrelease>            Document-level~(top-level)~code
%<latexrelease>            \@@_if_usable:nT {#1}
%<latexrelease>              { ~(executed~\@@_if_reversed:nTF {#1} {first} {last} ) } :
%<latexrelease>          }
%<latexrelease>        \@@_log_line_indent:x
%<latexrelease>          {
%<latexrelease>            \tl_if_empty:cTF { @@_toplevel~#1 }
%<latexrelease>              { --- }
%<latexrelease>              { -> ~ \exp_args:Nv \tl_to_str:n { @@_toplevel~#1 } }
%<latexrelease>          }
%<latexrelease>        \@@_log_line:x { Extra~code~for~next~invocation: }
%<latexrelease>        \@@_log_line_indent:x
%<latexrelease>          {
%<latexrelease>            \tl_if_empty:cTF { @@_next~#1 }
%<latexrelease>              { --- }
%<latexrelease>              { ->~ \exp_args:Nv \@@_log_next_code:n { @@_next~#1 } }
%<latexrelease>          }
%<latexrelease>        \@@_log_line:x { Rules: }
%<latexrelease>        \bool_set_true:N \l_@@_tmpa_bool
%<latexrelease>        \@@_list_rules:nn {#1}
%<latexrelease>          {
%<latexrelease>            \bool_set_false:N \l_@@_tmpa_bool
%<latexrelease>            \@@_log_line_indent:x
%<latexrelease>              {
%<latexrelease>                ##2~ with~
%<latexrelease>                \str_if_eq:nnT {##3} {??} { default~ }
%<latexrelease>                relation~ ##1
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>        \bool_if:NT \l_@@_tmpa_bool
%<latexrelease>          { \@@_log_line_indent:x { --- } }
%<latexrelease>        \bool_lazy_and:nnTF
%<latexrelease>            { \@@_if_usable_p:n {#1} }
%<latexrelease>            { ! \hook_if_empty_p:n {#1} }
%<latexrelease>          {
%<latexrelease>            \@@_log_line:x
%<latexrelease>              {
%<latexrelease>                Execution~order
%<latexrelease>                \bool_if:NTF \l_@@_tmpa_bool
%<latexrelease>                  { \@@_if_reversed:nT {#1} { ~(after~reversal) } }
%<latexrelease>                  { ~(after~
%<latexrelease>                    \@@_if_reversed:nT {#1} { reversal~and~ }
%<latexrelease>                    applying~rules)
%<latexrelease>                  } :
%<latexrelease>              }
%<latexrelease>            #2 % \tl_show:n
%<latexrelease>              {
%<latexrelease>                \@spaces
%<latexrelease>                \clist_if_empty:cTF { g_@@_#1_labels_clist }
%<latexrelease>                  { --- }
%<latexrelease>                  { \clist_use:cn { g_@@_#1_labels_clist } { ,~ } }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>          {
%<latexrelease>            \@@_log_line:x { Execution~order: }
%<latexrelease>            #2
%<latexrelease>              {
%<latexrelease>                \@spaces Not~set~because~the~hook~ \@@_if_usable:nTF {#1}
%<latexrelease>                  { code~pool~is~empty }
%<latexrelease>                  { is~\@@_if_disabled:nTF {#1} {disabled} {undeclared} }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
% \begin{macro}{\@@_log_next_code:n}
%    To display the code for next invocation only (i.e., from
%    \cs{AddToHookNext} we have to remove the string
%    \cs{@@_clear_next:n}\Arg{hook}, so the simplest is to use a macro
%    delimited by a \verb|}|$_12$.
% \changes{v1.1a}{2023/04/06}
%         {Changes to add hook arguments (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_log_next_code:n}
%<latexrelease>                 {Hooks~with~args}
\exp_last_unbraced:NNNNo
\cs_new:Npn \@@_log_next_code:w #1 \c_right_brace_str { }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_log_next_code:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset:Npn \@@_log_next_code:n #1
%<latexrelease>  { \exp_args:No \tl_to_str:n { \use_none:nn #1 } }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_print_args:n}
%    美化打印钩子的参数数量。
%    \begin{macrocode}
\cs_new:Npn \@@_print_args:nn #1 #2
  {
    \int_compare:nNnT {#2} > { 0 }
      {
        \@@_if_declared:nT {#1} { \use_none:nnn }
        \@@_if_cmd_hook:nT {#1}
          { \use_i:nnn { ~ (unknown ~ } }
        \use:n { ~ (#2 ~ }
        argument \int_compare:nNnT {#2} > { 1 } { s } )
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_list_rules:nn}
% \begin{macro}{\@@_list_one_rule:nnn,\@@_list_if_rule_exists:nnnF}
%    这个宏接受一个 \meta{hook} 和一个 \meta{inline function}，并循环遍历 \meta{hook} 中每一对 \meta{labels}，如果这对 \meta{labels} 之间有关系，那么使用 |#1|${}={}$\meta{relation}，|#2|${}={}$\meta{label_1}\verb=|=\meta{label_2}，以及 |#3|${}={}$\meta{hook}（后者可能是对 \cs{@@_list_rules:nn} 的参数 |#1|，或者如果它是默认规则，则是 \texttt{??}）来执行 \meta{inline function}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_list_rules:nn #1 #2
  {
    \cs_set_protected:Npn \@@_tmp:w ##1 ##2 ##3 {#2}
    \prop_map_inline:cn { g_@@_#1_code_prop }
      {
        \prop_map_inline:cn { g_@@_#1_code_prop }
          {
            \@@_if_label_case:nnnnn {##1} {####1}
              { \prop_map_break: }
              { \@@_list_one_rule:nnn {##1} {####1} }
              { \@@_list_one_rule:nnn {####1} {##1} }
                  {#1}
          }
      }
  }
%    \end{macrocode}
%
%   这两个与 \cs{@@_apply_label_pair:nnn} 和 \cs{@@_label_if_exist_apply:nnnF} 非常相似，但不是应用规则，而是将其传递给 \meta{inline function}。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_list_one_rule:nnn #1#2#3
  {
    \@@_list_if_rule_exists:nnnF {#1} {#2} {#3}
      { \@@_list_if_rule_exists:nnnF {#1} {#2} { ?? } { } }
  }
\cs_new_protected:Npn \@@_list_if_rule_exists:nnnF #1#2#3
  {
    \if_cs_exist:w g_@@_ #3 _rule_ #1 | #2 _tl \cs_end:
      \exp_args:Nv \@@_tmp:w
        { g_@@_ #3 _rule_ #1 | #2 _tl } { #1 | #2 } {#3}
      \exp_after:wN \use_none:nn
    \fi:
    \use:n
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_debug_print_rules:n}
%   用于调试的快捷方式，类似于 \cs{prop_show:N} 打印输出。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_debug_print_rules:n #1
  {
    \iow_term:n { The~hook~#1~contains~the~rules: }
    \cs_set_protected:Npn \@@_tmp:w ##1
      {
        \@@_list_rules:nn {#1}
          {
            \iow_term:x
              {
                > ##1 {####2} ##1 => ##1 {####1}
                \str_if_eq:nnT {####3} {??} { ~(default) }
              }
          }
      }
    \exp_args:No \@@_tmp:w { \use:nn { ~ } { ~ } }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%  \subsection{指定下一次调用的代码}
%
% \begin{macro}{\hook_gput_next_code:nn}
% \changes{v1.1a}{2023/04/06}
%         {添加 \cs{hook_gput_next_code_with_args:nn}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_gput_next_code:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_gput_next_code:nn #1 #2
  {
    \@@_replacing_args_false:
    \@@_normalize_hook_args:Nn \@@_gput_next_code:nn {#1} {#2}
    \@@_replacing_args_reset:
  }
\cs_new_protected:Npn \hook_gput_next_code_with_args:nn #1 #2
  {
    \@@_replacing_args_true:
    \@@_normalize_hook_args:Nn \@@_gput_next_code:nn {#1} {#2}
    \@@_replacing_args_reset:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_gput_next_code:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_gput_next_code:nn #1
%<latexrelease>  { \@@_normalize_hook_args:Nn \@@_gput_next_code:nn {#1} }
%<latexrelease>\cs_gset_protected:Npn \hook_gput_next_code_with_args:nn #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_gput_next_code:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_gput_next_code:nn #1 #2
  {
    \@@_if_disabled:nTF {#1}
      { \msg_error:nnn { hooks } { hook-disabled } {#1} }
      {
        \@@_if_structure_exist:nTF {#1}
          { \@@_gput_next_do:nn }
          { \@@_try_declaring_generic_next_hook:nn }
              {#1} {#2}
      }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_gput_next_do:nn}
%   通过 \cs{@@_chk_args_allowed:nn} 进行合法性检查。
%   然后检查是否“下一个代码”令牌列表为空：如果是，我们需要添加 \cs{tl_gclear:c} 来清除它，以便代码只持续一次使用。令牌列表被提前清除，以防嵌套使用导致遗失。在仅展开的环境中使用钩子时，使用 \cs{tl_gclear:c} 而不是 \cs{tl_gclear:N}，这样在 \cs{tl_gclear:N} 之前令牌列表不会展开：否则会导致无限循环。此外，如果主代码令牌列表为空，则需要更新钩子代码以添加下一个执行的令牌列表。
% \changes{v1.1a}{2023/04/06}
%         {添加钩子参数（hook-args）的更改。}
% \changes{v1.1c}{2023/04/19}
%         {在添加“下一个”代码时初始化钩子结构（gh/1052）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_gput_next_do:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_gput_next_do:nn #1
  {
    \@@_init_structure:n {#1}
    \@@_chk_args_allowed:nn {#1} { AddToHookNext }
    \@@_cs_if_empty:cT { @@~#1 }
      { \@@_update_hook_code:n {#1} }
    \@@_cs_if_empty:cT { @@_next~#1 }
      { \@@_next_gset:nn {#1} { \@@_clear_next:n {#1} } }
    \@@_cs_gput_right:nnn { _next } {#1}
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_gput_next_do:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_gput_next_do:nn #1
%<latexrelease>  {
%<latexrelease>    \exp_args:Nc \@@_gput_next_do:Nnn
%<latexrelease>      { @@_next~#1 } {#1}
%<latexrelease>  }
%<latexrelease>\cs_gset_protected:Npn \@@_gput_next_do:Nnn #1 #2
%<latexrelease>  {
%<latexrelease>    \tl_if_empty:cT { @@~#2 }
%<latexrelease>      { \@@_update_hook_code:n {#2} }
%<latexrelease>    \tl_if_empty:NT #1
%<latexrelease>      { \@@_tl_gset:Nn #1 { \@@_clear_next:n {#2} } }
%<latexrelease>    \@@_tl_gput_right:Nn #1
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\hook_gclear_next_code:n}
%    丢弃为下一次调用钩子设置的任何内容。
% \changes{v1.0o}{2021/07/27}{宏公开}
%    \begin{macrocode}
\cs_new_protected:Npn \hook_gclear_next_code:n #1
  { \@@_normalize_hook_args:Nn \@@_clear_next:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\@@_clear_next:n}
% \changes{v1.1a}{2023/04/06}{添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_clear_next:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_clear_next:n #1
  { \@@_next_gset:nn {#1} { } }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_clear_next:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_clear_next:n #1
%<latexrelease>  { \cs_gset_eq:cN { @@_next~#1 } \c_empty_tl }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{使用钩子}
%
% \begin{macro}{\hook_use:n}
% \begin{macro}[EXP]{\@@_use_initialized:n}
% \begin{macro}{\@@_preamble_hook:n}
%   此处定义的 \cs{hook_use:n} 用于导言部分，在那里钩子默认不被初始化。
%   \cs{@@_use_initialized:n} 也被定义，它是用于文档内的非保护版本。
%   它们的定义是相同的，除了 \cs{@@_preamble_hook:n}（在可展开版本中不会有影响，但这将是一个不必要的额外展开）。
%
%   \cs{@@_use_initialized:n} 在导言部分保持可展开的定义。
%   \cs{@@_preamble_hook:n} 在导言部分初始化钩子，并在 |\begin{document}| 处被重新定义为 \cs{use_none:n}。
%
%   这两个版本在内部执行相同的操作：它们检查给定的钩子是否存在，如果存在则尽快使用它。
%
%   在 |\begin{document}| 处，所有钩子都被初始化，并且它们的任何更改都会引起更新，因此 \cs{hook_use:n} 可以被制作成可展开的版本。
%   最好不要保护它，这样如果它不包含任何代码，就可以展开为空。
%   对于通用钩子而言也很重要，我们不会生成 \cs[no-index]{relax} 作为检查控制序列名的副作用。
%   与 \TeX{} 低级的 \verb=\csname ...\endcsname= 构造不同，\cs{tl_if_exist:c} 小心避免这种情况。
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_use:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_use:n #1
  {
    \@@_preamble_hook:n {#1}
    \@@_use_initialized:n {#1}
  }
\cs_new:Npn \@@_use_initialized:n #1
  {
    \if_cs_exist:w @@~#1 \cs_end:
      \cs:w @@~#1 \use_i:nn
    \fi:
    \use_none:n
    \cs_end:
  }
\cs_new_protected:Npn \@@_preamble_hook:n #1
  {
    \if_cs_exist:w @@~#1 \cs_end:
      \@@_initialize_hook_code:n {#1}
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\hook_use:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new_protected:Npn \hook_use:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cT { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \@@_preamble_hook:n {#1}
%<latexrelease>        \cs:w @@~#1 \cs_end:
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\cs_new:Npn \@@_use_initialized:n #1
%<latexrelease>  {
%<latexrelease>    \if_cs_exist:w @@~#1 \cs_end:
%<latexrelease>      \cs:w @@~#1 \exp_after:wN \cs_end:
%<latexrelease>    \fi:
%<latexrelease>  }
%<latexrelease>\cs_new_protected:Npn \@@_preamble_hook:n #1
%<latexrelease>  { \@@_initialize_hook_code:n {#1} }
%<latexrelease>\cs_new:Npn \hook_use:nnw #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_use:n}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new_protected:Npn \hook_use:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cTF { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \@@_preamble_hook:n {#1}
%<latexrelease>        \cs:w @@~#1 \cs_end:
%<latexrelease>      }
%<latexrelease>      { \@@_use:wn #1 / \s_@@_mark {#1} }
%<latexrelease>  }
%<latexrelease>\cs_new:Npn \@@_use_initialized:n #1
%<latexrelease>  {
%<latexrelease>    \if_cs_exist:w @@~#1 \cs_end:
%<latexrelease>    \else:
%<latexrelease>      \@@_use_undefined:w
%<latexrelease>    \fi:
%<latexrelease>    \cs:w @@~#1 \@@_use_end:
%<latexrelease>  }
%<latexrelease>\cs_new:Npn \@@_use_undefined:w #1 #2 @@~#3 \@@_use_end:
%<latexrelease>  {
%<latexrelease>    #1 % fi
%<latexrelease>    \@@_use:wn #3 / \s_@@_mark {#3}
%<latexrelease>  }
%<latexrelease>\cs_new_protected:Npn \@@_preamble_hook:n #1
%<latexrelease>  { \@@_initialize_hook_code:n {#1} }
%<latexrelease>\cs_new_eq:NN \@@_use_end: \cs_end:
%<latexrelease>\cs_new:Npn \hook_use:nnw #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\hook_use:nnw}
% \begin{macro}[EXP]{\@@_use_initialized:nnw}
% \changes{v1.1a}{2023/04/06}{添加 \cs{hook_use:nnw}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_use:nnw}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_use:nnw #1
  {
    \@@_preamble_hook:n {#1}
    \@@_use_initialized:nnw {#1}
  }
\cs_new:Npn \@@_use_initialized:nnw #1 #2
  {
    \cs:w
      \if_cs_exist:w @@~#1 \cs_end:
        @@~#1
      \else:
        use_none: \prg_replicate:nn {#2} { n }
      \fi:
    \cs_end:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_use:nnw}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset:Npn \hook_use:nnw #1 #2
%<latexrelease>  { \use:c { use_none: \prg_replicate:nn {#2} { n } } }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\@@_post_initialization_defs:}
% \changes{v1.1a}{2023/04/06}
%         {Macro added (hook-args).}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_post_initialization_defs:}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_post_initialization_defs:
  {
    \cs_gset_eq:NN \hook_use:n \@@_use_initialized:n
    \cs_gset_eq:NN \hook_use:nnw \@@_use_initialized:nnw
    \cs_gset_eq:NN \@@_preamble_hook:n \use_none:n
    \cs_gset_eq:NN \@@_post_initialization_defs: \prg_do_nothing:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_post_initialization_defs:}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_post_initialization_defs:
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[EXP]{\@@_use:wn}
% \begin{macro}{\@@_try_file_hook:n,\@@_if_usable_use:n}
%   \cs{@@_use:wn} 进行了一个快速检查，以测试当前钩子是否是文件钩子：这些需要特殊处理。
%   如果不是，钩子不存在。如果是，那么调用 \cs{@@_try_file_hook:n}，并使用 \cs{@@_if_file_hook:wTF} 检查当前钩子是否是文件特定钩子。
%   如果不是，那么它就是一个通用的 |file/| 钩子，如果存在则使用它。
%
%   如果它是一个文件特定的钩子，它将通过与声明期间相同的规范化流程，然后如果定义了就使用它。
%   \cs{@@_if_usable_use:n} 检查钩子是否存在，如果存在，则调用 \cs{@@_preamble_hook:n}，然后使用该钩子。
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/11/15}{\@@_use:wn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_use:wn}
%<latexrelease>                 {Standardise~generic~hook~names}
%<latexrelease>\cs_new:Npn \@@_use:wn #1 / #2 \s_@@_mark #3
%<latexrelease>  {
%<latexrelease>    \str_if_eq:nnTF {#1} { file }
%<latexrelease>      { \@@_try_file_hook:n {#3} }
%<latexrelease>      { } % Hook doesn't exist
%<latexrelease>  }
%    \end{macrocode}
%
% \changes{v1.0s}{2021/09/28}
%                {修正老版本 \cs{@@_if_file_hook:wTF} 的使用 (gh/675)}
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_try_file_hook:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_file_hook:wTF #1 / \s_@@_mark
%<latexrelease>      {
%<latexrelease>        \exp_args:Ne \@@_if_usable_use:n
%<latexrelease>          { \exp_args:Ne \@@_file_hook_normalize:n {#1} }
%<latexrelease>      }
%<latexrelease>      { \@@_if_usable_use:n {#1} } % file/ generic hook (e.g. file/before)
%<latexrelease>  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\cs_new_protected:Npn \@@_if_usable_use:n #1
%<latexrelease>  {
%<latexrelease>    \tl_if_exist:cT { @@~#1 }
%<latexrelease>      {
%<latexrelease>        \@@_preamble_hook:n {#1}
%<latexrelease>        \cs:w @@~#1 \cs_end:
%<latexrelease>      }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\hook_use_once:n,\hook_use_once:nnw}
%   对于只能且应该仅使用一次的钩子，我们有一个特殊的使用命令，可以进一步禁止向其添加更多代码。
%   这样做的效果是，任何进一步添加到钩子的代码会立即执行，而不是存储在钩子中。
%
%   代码需要一些技巧来防止钩子名称被空格修剪，因为 \cs{hook_use:n} 和 \cs{hook_use_once:n} 被记录为不修剪空格。
%
% \changes{v1.0r}{2021/09/06}{清理 \cs{UseOneTimeHook} 后的代码 (gh/606)}
% \changes{v1.1a}{2023/04/06}{添加 \cs{hook_use_once:nnw} (hook-args)。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_use_once:nnw}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \hook_use_once:n #1
  {
    \@@_if_execute_immediately:nF {#1}
      { \@@_normalize_hook_args:Nn \@@_use_once:nn { \use:n {#1} } { 0 } }
  }
\cs_new_protected:Npn \hook_use_once:nnw #1 #2
  {
    \@@_if_execute_immediately:nF {#1}
      { \@@_normalize_hook_args:Nn \@@_use_once:nn { \use:n {#1} } {#2} }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_use_once:nnw}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \hook_use_once:n #1
%<latexrelease>  {
%<latexrelease>    \@@_if_execute_immediately:nF {#1}
%<latexrelease>      { \@@_normalize_hook_args:Nn \@@_use_once:n { \use:n {#1} } }
%<latexrelease>  }
%<latexrelease>\cs_gset:Npn \hook_use_once:nnw #1 #2
%<latexrelease>  { \use:c { use_none: \prg_replicate:nn {#2} { n } } }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
% \begin{macro}{\@@_use_once:nn}
% \changes{v1.1a}{2023/04/06}{添加钩子参数（hook-args）的更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_use_once:nn}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_use_once:nn #1 #2
  {
    \@@_preamble_hook:n {#1}
    \@@_use_once_set:n {#1}
%    \end{macrocode}
%   当一个钩子带有参数时，对 \cs{@@_use_initialized:n} 的调用应该是最后发生的事情，
%   否则抓取的参数会出错。因此，在钩子之后进行清理，我们需要有些技巧，将清理代码偷偷放在钩子的末尾，
%   同时还要与下一次执行代码放在一起。
%    \begin{macrocode}
    \@@_replacing_args_false:
    \@@_cs_gput_right:nnn { _next } {#1} { \@@_use_once_clear:n {#1} }
    \@@_replacing_args_reset:
    \@@_if_usable:nTF {#1}
      { \@@_use_initialized:n {#1} }
      {
        \int_compare:nNnT {#2} > { 0 }
          { \use:c { use_none: \prg_replicate:nn {#2} { n } } }
      }
  }
%<latexrelease>\EndIncludeInRelease
%
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_use_once:nn}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_gset_protected:Npn \@@_use_once:n #1
%<latexrelease>  {
%<latexrelease>    \@@_preamble_hook:n {#1}
%<latexrelease>    \@@_use_once_set:n {#1}
%<latexrelease>    \@@_use_initialized:n {#1}
%<latexrelease>    \@@_use_once_clear:n {#1}
%<latexrelease>  }
%<latexrelease>\cs_undefine:N \@@_use_once:nn
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_use_once_set:n}
% \begin{macro}{\@@_use_once_clear:n}
%   在实际钩子代码执行之前使用 \cs{@@_use_once_set:n}，
%   这样钩子内部使用 \cs{AddToHook} 会导致代码立即执行。
%   将 \cs[no-index]{g_@@_\meta{hook}_reversed_tl} 设置为 |I| 阻止进一步向钩子添加代码。
%   然后 \cs{@@_use_once_clear:n} 清除钩子，以便进一步调用 \cs{hook_use:n} 或 \cs{hook_use_once:n} 时会展开为空。
%
% \changes{v1.0r}{2021/09/06}{清理 \cs{UseOneTimeHook} 后的代码 (gh/606)}
% \changes{v1.0u}{2022/05/13}{检查属性是否存在以避免 l3debug 错误}
% \changes{v1.1a}{2023/04/06}{为添加钩子参数（hook-args）进行更改。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_use_once_clear:n}
%<latexrelease>                 {Hooks~with~args}
\cs_new_protected:Npn \@@_use_once_set:n #1
  { \@@_tl_gset:cn { g_@@_#1_reversed_tl } { I } }
\cs_new_protected:Npn \@@_use_once_clear:n #1
  {
    \@@_code_gset:nn {#1} { }
    \@@_next_gset:nn {#1} { }
    \@@_toplevel_gset:nn {#1} { }
    \prop_gclear_new:c { g_@@_#1_code_prop }
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_use_once_clear:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \@@_use_once_clear:n #1
%<latexrelease>  {
%<latexrelease>    \@@_tl_gclear:c { @@~#1 }
%<latexrelease>    \@@_tl_gclear:c { @@_next~#1 }
%<latexrelease>    \@@_tl_gclear:c { @@_toplevel~#1 }
%<latexrelease>    \prop_gclear_new:c { g_@@_#1_code_prop }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_if_execute_immediately:n}
%   要检查要添加的代码是否应立即执行（即，如果钩子是一次性钩子），
%   我们检查 \cs[no-index]{g_@@_\meta{hook}_reversed_tl} 是否为 |I|。
%   \cs{if:w} 的技巧在于允许 |reversed| 令牌列表为空。
%
% \changes{v1.0r}{2021/09/06}{添加宏（gh/606）}
% \changes{v1.1a}{2023/04/06}{为添加钩子参数（hook-args）进行更改。}
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_execute_immediately:n #1 { T, F, TF }
  {
    \exp_after:wN \@@_use_none_delimit_by_s_mark:w
    \if:w I
        \if_cs_exist:w g_@@_#1_reversed_tl \cs_end:
          \cs:w g_@@_#1_reversed_tl \exp_after:wN \cs_end:
        \fi:
        X
      \s_@@_mark \prg_return_true:
    \else:
      \s_@@_mark \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \subsection{查询钩子}
%
% 更简单的数据类型，比如记号列表，有三种可能的状态：它们可以存在且为空，
% 存在且非空，也可能不存在，在这种情况下就不适用空（尽管在这种情况下 \cs{tl_if_empty:N} 返回假）。
%
% 钩子则稍微复杂一些：它们有几个其他状态，如 \ref{sec:existence} 中讨论的那样。
% 一个钩子可能存在，也可能不存在，无论哪种情况，它可能为空，也可能非空（即使一个不存在的钩子可能也是非空的）或者可能被禁用。
%
% 当一个钩子没有添加任何代码时，无论是添加到其永久代码池还是其“下一个”记号列表，它被称为空。
% 钩子不需要声明为已添加代码到其代码池（可能发生的情况是包 $A$ 定义了一个钩子 \hook{foo}，
% 但在加载包 $B$ 之后，包 $B$ 向该钩子添加了一些代码。在这种情况下，重要的是记住包 $B$ 添加的代码，
% 直到加载包 $A$ 为止）。
%
% 其他所有状态只能通过内部测试进行查询，因为对于包代码来说，不同的状态是无关紧要的。
%
% \begin{macro}[pTF]{\hook_if_empty:n}
%   测试一个钩子是否为空（即，该钩子未添加任何代码）。
%   一个 \meta{hook} 为空意味着它的三个部分 \cs{g_@@_\meta{hook}_code_prop}，
%   \cs{@@_toplevel\textvisiblespace\meta{hook}} 和 \cs{@@_next\textvisiblespace\meta{hook}} 都为空。
% \changes{v1.1a}{2023/04/06}{为添加钩子参数（hook-args）进行更改。}
% \changes{v1.1c}{2023/04/19}{更简单更快的版本（gh/1052）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\hook_if_empty:n}
%<latexrelease>                 {Hooks~with~args}
\prg_new_conditional:Npnn \hook_if_empty:n #1 { p , T , F , TF }
  {
    \if:w
        T
        \prop_if_exist:cT { g_@@_#1_code_prop }
          { \prop_if_empty:cF { g_@@_#1_code_prop } { F } }
        \@@_cs_if_empty:cF { @@_toplevel~#1 } { F }
        \@@_cs_if_empty:cF { @@_next~#1 } { F }
        T
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\hook_if_empty:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\prg_new_conditional:Npnn \hook_if_empty:n #1 { p , T , F , TF }
%<latexrelease>  {
%<latexrelease>    \@@_if_structure_exist:nTF {#1}
%<latexrelease>      {
%<latexrelease>        \bool_lazy_and:nnTF
%<latexrelease>            { \prop_if_empty_p:c { g_@@_#1_code_prop } }
%<latexrelease>            {
%<latexrelease>              \bool_lazy_and_p:nn
%<latexrelease>                { \tl_if_empty_p:c { @@_toplevel~#1 } }
%<latexrelease>                { \tl_if_empty_p:c { @@_next~#1 } }
%<latexrelease>            }
%<latexrelease>          { \prg_return_true: }
%<latexrelease>          { \prg_return_false: }
%<latexrelease>      }
%<latexrelease>      { \prg_return_true: }
%<latexrelease>  }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[pTF]{\@@_if_usable:n}
%   如果存储钩子排序代码的记号列表 \cs[no-index]{@@\textvisiblespace\meta{hook}} 存在，
%   那么该钩子是可用的。不能在这里使用属性列表 \cs[no-index]{g_@@_\meta{hook}_code_prop}，
%   因为通常需要向钩子添加代码，而不知道是否已经声明了这样的钩子，甚至是否将来会有声明（例如，
%   如果定义它的包尚未加载）。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_usable:n #1 { p , T , F , TF }
  {
    \cs_if_exist:cTF { @@~#1 }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\@@_if_structure_exist:n}
%
%    内部检查钩子是否已经使用 \cs{@@_init_structure:n} 设置了其基本的内部结构。
%    这意味着钩子已经以某种方式被使用过（向其添加了代码块或规则），但仍然没有使用 \cs{hook_new:n} 声明。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_structure_exist:n #1 { p , T , F , TF }
  {
    \prop_if_exist:cTF { g_@@_#1_code_prop }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
%
%  \begin{macro}[pTF]{\@@_if_declared:n}
%
%    内部测试，检查钩子是否已经使用 \cs{hook_new:n} 或其变体正式声明。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_declared:n #1 { p, T, F, TF }
  {
    \tl_if_exist:cTF { g_@@_#1_declared_tl }
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_reversed:n}
%   一个内部条件，用于检查钩子是否是反转的。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_reversed:n #1 { p , T , F , TF }
  {
    \exp_after:wN \@@_use_none_delimit_by_s_mark:w
    \if:w - \cs:w g_@@_#1_reversed_tl \cs_end:
      \s_@@_mark \prg_return_true:
    \else:
      \s_@@_mark \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_generic:n}
% \begin{macro}[pTF]{\@@_if_deprecated_generic:n}
%   一个内部条件，用于检查名称是否属于通用钩子。已弃用版本需要检查 |#3| 是否为空，
%   以避免在例如 \hook{file/before} 上返回 true。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_generic:n #1 { T, TF }
  { \@@_if_generic:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_if_generic:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \cs_if_exist:cTF { c_@@_generic_#1/./#3_tl }
      { \prg_return_true: }
      { \prg_return_false: }
  }
\prg_new_conditional:Npnn \@@_if_deprecated_generic:n #1 { T, TF }
  { \@@_if_deprecated_generic:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_if_deprecated_generic:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \cs_if_exist:cTF { c_@@_deprecated_#1/./#2_tl }
      {
        \tl_if_empty:nTF {#3}
          { \prg_return_false: }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_cmd_hook:n}
% \begin{macro}[pTF]{\@@_if_cmd_hook:w}
%   一个内部条件，用于检查给定的钩子是否是有效的通用 \hook{cmd} 钩子。
% \changes{v1.1d}{2023/05/21}
%         {允许 cmd 钩子支持参数（cmd-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\@@_if_cmd_hook:n}
%<latexrelease>                 {Hooks~with~args}
\prg_new_conditional:Npnn \@@_if_cmd_hook:n #1 { T }
  { \@@_if_cmd_hook:w #1 / / / \s_@@_mark }
\cs_new:Npn \@@_if_cmd_hook:w #1 / #2 / #3 / #4 \s_@@_mark
  {
    \if:w Y
          \str_if_eq:nnF {#1} { cmd } { N }
          \tl_if_exist:cF { c_@@_generic_#1/./#3_tl } { N }
          Y
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\@@_if_cmd_hook:n}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_undefine:N \@@_if_cmd_hook:nT
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}[pTF]{\@@_if_generic_reversed:n}
%   一个内部条件，用于检查名称是否属于通用反转钩子。
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_generic_reversed:n #1 { T }
  { \@@_if_generic_reversed:w #1 / / / \scan_stop: }
\cs_new:Npn \@@_if_generic_reversed:w #1 / #2 / #3 / #4 \scan_stop:
  {
    \if_charcode:w - \cs:w c_@@_generic_#1/./#3_tl \cs_end:
      \prg_return_true:
    \else:
      \prg_return_false:
    \fi:
  }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}[EXP]{\@@_if_replacing_args:TF}
% \begin{macro}[EXP]{\@@_misused_if_replacing_args:nn}
% \begin{macro}{\@@_replacing_args_true:}
% \begin{macro}{\@@_replacing_args_false:}
% \begin{macro}{\@@_replacing_args_reset:}
% \begin{macro}{\g_@@_replacing_stack_seq}
%   一个内部条件，用于检查添加到钩子的代码是否包含参数。
% \changes{v1.1a}{2023/04/06}
%         {添加宏（hook-args）。}
%    \begin{macrocode}
\seq_new:N \g_@@_replacing_stack_seq
\cs_new:Npn \@@_misused_if_replacing_args:nn #1 #2
  {
    \msg_expandable_error:nnn { latex2e } { should-not-happen }
      { Misused~\@@_if_replacing_args:. }
  }
\cs_new:Npn \@@_if_replacing_args:TF
  { \@@_misused_if_replacing_args:nn }
\cs_new_protected:Npn \@@_replacing_args_true:
  {
    \seq_gpush:No \g_@@_replacing_stack_seq
      { \@@_if_replacing_args:TF }
    \cs_set:Npn \@@_if_replacing_args:TF { \use_i:nn }
  }
\cs_new_protected:Npn \@@_replacing_args_false:
  {
    \seq_gpush:No \g_@@_replacing_stack_seq
      { \@@_if_replacing_args:TF }
    \cs_set:Npn \@@_if_replacing_args:TF { \use_ii:nn }
  }
\cs_new_protected:Npn \@@_replacing_args_reset:
  {
    \seq_gpop:NN \g_@@_replacing_stack_seq \l_@@_return_tl
    \cs_gset_eq:NN \@@_if_replacing_args:TF \l_@@_return_tl
  }
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \subsection{消息}
%
%    钩子错误是 LaTeX 内核错误：
%    \begin{macrocode}
\prop_gput:Nnn \g_msg_module_type_prop { hooks } { LaTeX }
%    \end{macrocode}
% \changes{v1.0q}{2021/08/27}{内部消息名称更改}
%    内核错误也是如此（这应该最终移动到其他地方）。
%    \begin{macrocode}
\prop_gput:Nnn \g_msg_module_type_prop { latex2e } { LaTeX }
\prop_gput:Nnn \g_msg_module_name_prop { latex2e } { kernel }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { labels-incompatible }
  {
    Labels~'#1'~and~'#2'~are~incompatible
    \str_if_eq:nnF {#3} {??} { ~in~hook~'#3' } .~
    \int_compare:nNnTF {#4} = { 1 }
      { The~ code~ for~ both~ labels~ will~ be~ dropped. }
      { You~ may~ see~ errors~ later. }
  }
  { LaTeX~found~two~incompatible~labels~in~the~same~hook.~
    This~indicates~an~incompatibility~between~packages.  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { exists }
    { Hook~'#1'~ has~ already~ been~ declared. }
    { There~ already~ exists~ a~ hook~ declaration~ with~ this~
      name.\\
      Please~ use~ a~ different~ name~ for~ your~ hook.}
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{too-many-args}
%<latexrelease>                 {Hooks~with~args}
%    \end{macrocode}
%
% \changes{v1.1a}{2023/04/06}
%         {添加消息 'too-many-args'、'without-args' 和 'one-time-args'（hook-args）。}
%    \begin{macrocode}
\msg_new:nnnn { hooks } { too-many-args }
  { Too~many~arguments~for~hook~'#1'. }
  {
    You~tried~to~declare~a~hook~with~#2~arguments,~but~a~
    hook~can~only~have~up~to~nine.~LaTeX~will~define~this~
    hook~with~nine~arguments.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { without-args }
  { Hook~'#1'~has~no~arguments. }
  {
    You~tried~to~use~\iow_char:N\\#2WithArguments~
    on~a~hook~that~takes~no~arguments.\\
    Check~the~usage~of~the~hook~or~use~\iow_char:N\\#2~instead.\\
    \\
    LaTeX~will~use~\iow_char:N\\#2.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { one-time-args }
  { You~can't~have~arguments~in~used~one-time~hook~'#1'. }
  {
    You~tried~to~use~\iow_char:N\\#2WithArguments~
    on~a~one-time~hook~that~has~already~been~used.~
    You~have~to~add~the~code~before~the~hook~is~used,~
    or~add~the~code~without~arguments~using~\iow_char:N\\#2~instead.\\
    \\
    LaTeX~will~use~\iow_char:N\\#2.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{too-many-args}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { hook-disabled }
  { Cannot~add~code~to~disabled~hook~'#1'. }
  {
    The~hook~'#1'~you~tried~to~add~code~to~was~previously~disabled~
    with~\iow_char:N\\hook_disable_generic:n~or~\iow_char:N\\DisableGenericHook,~so~
    it~cannot~have~code~added~to~it.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { empty-label }
  {
    Empty~code~label~\msg_line_context:.~
    Using~'\@@_currname_or_default:'~instead.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { no-default-label }
  {
    Missing~(empty)~default~label~\msg_line_context:. \\
    This~command~was~ignored.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { unknown-rule }
  {
    Unknown~ relationship~ '#3'~
    between~ labels~ '#2'~ and~ '#4'~
    \str_if_eq:nnF {#1} {??} { ~in~hook~'#1' }. ~
    Perhaps~ a~ misspelling?
  }
  {
    The~ relation~ used~ not~ known~ to~ the~ system.~ Allowed~ values~ are~
    'before'~ or~ '<',~
    'after'~ or~ '>',~
    'incompatible-warning',~
    'incompatible-error',~
    'voids'~ or~
    'unrelated'.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { rule-too-late }
  {
    Sorting~rule~for~'#1'~hook~applied~too~late.\\
    Try~setting~this~rule~earlier.
  }
  {
    You~tried~to~set~the~ordering~of~hook~'#1'~using\\
    \ \ \iow_char:N\\DeclareHookRule{#1}{#2}{#3}{#4}\\
    but~hook~'#1'~was~already~used~as~a~one-time~hook,~
    thus~sorting~is\\
    no~longer~possible.~Declare~the~rule~
    before~the~hook~is~used.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnnn { hooks } { misused-top-level }
  {
    Illegal~use~of~\iow_char:N \\AddToHook{#1}[top-level]{...}.\\
    'top-level'~is~reserved~for~the~user's~document.
  }
  {
    The~'top-level'~label~is~meant~for~user~code~only,~and~should~only~
    be~used~(sparingly)~in~the~main~document.~Use~the~default~label~
    '\@@_currname_or_default:'~for~this~\@cls@pkg,~or~another~
    suitable~label.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { set-top-level }
  {
    You~cannot~change~the~default~label~#1~'top-level'.~Illegal \\
    \use:nn { ~ } { ~ } \iow_char:N \\#2{#3} \\
    \msg_line_context:.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { extra-pop-label }
  {
    Extra~\iow_char:N \\PopDefaultHookLabel. \\
    This~command~will~be~ignored.
  }
\msg_new:nnn { hooks } { missing-pop-label }
  {
    Missing~\iow_char:N \\PopDefaultHookLabel. \\
    The~label~'#1'~was~pushed~but~never~popped.~Something~is~wrong.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { latex2e } { should-not-happen }
  {
    This~should~not~happen.~#1 \\
    Please~report~at~https://github.com/latex3/latex2e.
  }
%    \end{macrocode}
%
%
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { activate-disabled }
  {
    Cannot~ activate~ hook~ '#1'~ because~ it~ is~ disabled!
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { cannot-remove }
  {
    Cannot~remove~chunk~'#2'~from~hook~'#1'~because~
    \@@_if_structure_exist:nTF {#1}
      { it~does~not~exist~in~that~hook. }
      { the~hook~does~not~exist. }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { hooks } { generic-deprecated }
  {
    Generic~hook~'#1/#2/#3'~is~deprecated. \\
    Use~hook~'#1/#3/#2'~instead.
  }
%    \end{macrocode}
%
%
%  \subsection{\LaTeXe{} 包接口命令}
%
%
%
%  \begin{macro}{\NewHook,\NewReversedHook,\NewMirroredHookPair}
%    声明新钩子 \ldots
%    \begin{macrocode}
\NewDocumentCommand \NewHook             { m }
  { \hook_new:n {#1} }
\NewDocumentCommand \NewReversedHook     { m }
  { \hook_new_reversed:n {#1} }
\NewDocumentCommand \NewMirroredHookPair { mm }
  { \hook_new_pair:nn {#1}{#2} }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{
%    \NewHookWithArguments,
%    \NewReversedHookWithArguments,
%    \NewMirroredHookPairWithArguments
%  }
%    声明带参数的新钩子\ldots
% \changes{v1.1a}{2023/04/06}
%         {添加 \cs{NewHookWithArguments}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\NewHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
\NewDocumentCommand \NewHookWithArguments             { mm }
  { \hook_new_with_args:nn {#1} {#2} }
\NewDocumentCommand \NewReversedHookWithArguments     { mm }
  { \hook_new_reversed_with_args:nn {#1} {#2} }
\NewDocumentCommand \NewMirroredHookPairWithArguments { mmm }
  { \hook_new_pair_with_args:nnn {#1} {#2} {#3} }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\NewHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \NewHookWithArguments #1 #2 { }
%<latexrelease>\cs_new_protected:Npn \NewReversedHookWithArguments #1 #2 { }
%<latexrelease>\cs_new_protected:Npn \NewMirroredHookPairWithArguments #1 #2 #3 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2021/06/01}{\ActivateGenericHook}
%<latexrelease>                 {Providing~hooks}
%    \end{macrocode}
%
%  \begin{macro}{\ActivateGenericHook}
%    提供新的钩子 \ldots
% \changes{v1.0m}{2021/04/29}{添加 \cs{ProvideHook} 等。}
% \changes{v1.0o}{2021/08/02}{更改名称}
%    \begin{macrocode}
\NewDocumentCommand \ActivateGenericHook { m }
  { \hook_activate_generic:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DisableGenericHook}
%    禁用通用钩子。
% \changes{v1.0o}{2021/08/02}{更改名称}
%    \begin{macrocode}
\NewDocumentCommand \DisableGenericHook { m }
  { \hook_disable_generic:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
%    \begin{macrocode}
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2020/10/01}{\ActivateGenericHook}
%<latexrelease>                 {Providing~hooks}
%<latexrelease>\def \ActivateGenericHook #1 { }
%<latexrelease>\def \DisableGenericHook #1 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%
%
%  \begin{macro}{\AddToHook,\AddToHookWithArguments}
% \changes{v1.1a}{2023/04/06}{添加 \cs{AddToHookWithArguments}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\AddToHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
\NewDocumentCommand \AddToHook { m o +m }
  { \hook_gput_code:nnn {#1} {#2} {#3} }
\NewDocumentCommand \AddToHookWithArguments { m o +m }
  { \hook_gput_code_with_args:nnn {#1} {#2} {#3} }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\AddToHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \AddToHookWithArguments #1 #2 #3 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\AddToHookNext,\AddToHookNextWithArguments}
% \changes{v1.1a}{2023/04/06}{添加 \cs{AddToHookNextWithArguments}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\AddToHookNextWithArguments}
%<latexrelease>                 {Hooks~with~args}
\NewDocumentCommand \AddToHookNext { m +m }
  { \hook_gput_next_code:nn {#1} {#2} }
\NewDocumentCommand \AddToHookNextWithArguments { m +m }
  { \hook_gput_next_code_with_args:nn {#1} {#2} }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\AddToHookNextWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new_protected:Npn \AddToHookNextWithArguments #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ClearHookNext}
% \changes{v1.0o}{2021/07/27}{添加宏}
%    \begin{macrocode}
\NewDocumentCommand \ClearHookNext { m }
  { \hook_gclear_next_code:n {#1} }
%    \end{macrocode}
%  \end{macro}
%
%
%  \begin{macro}{\RemoveFromHook}
%    \begin{macrocode}
\NewDocumentCommand \RemoveFromHook { m o }
  { \hook_gremove_code:nn {#1} {#2} }
%    \end{macrocode}
%  \end{macro}
%
% \begin{macro}{\SetDefaultHookLabel}
% \begin{macro}{\PushDefaultHookLabel}
% \begin{macro}{\PopDefaultHookLabel}
%   现在定义一个包装器，用传入的参数替换堆栈顶部，并相应更新 \cs{g_@@_hook_curr_name_tl}。
%    \begin{macrocode}
\NewDocumentCommand \SetDefaultHookLabel { m }
  { \@@_set_default_hook_label:n {#1} }
%    \end{macrocode}
%
%   标签只会在 \cs{@onefilewithoptions}（\cs{usepackage} 和 \cs{documentclass}）中自动更新，
%   但是一些包（例如 Ti\emph{k}Z）定义了类似包的接口，比如 \cs{usetikzlibrary}，它们是 \cs{input} 的包装器，
%   因此它们继承了当前生效的默认标签（通常是 |top-level|，但如果在另一个包中加载，则可能会更改）。
%   为了为这些文件中的钩子提供类似包的行为，我们提供对默认标签栈的高级访问。
%    \begin{macrocode}
\NewDocumentCommand \PushDefaultHookLabel { m }
  { \@@_curr_name_push:n {#1} }
\NewDocumentCommand \PopDefaultHookLabel { }
  { \@@_curr_name_pop: }
%    \end{macrocode}
%
%   当前标签栈保存除当前文件之外的所有文件的标签（更或多，类似于 \cs{@currnamestack}），
%   而当前标签记号列表 \cs{g_@@_hook_curr_name_tl} 保存当前文件的标签。
%   但是 \cs{@pushfilename} 发生在 \cs{@currname} 设置之前，所以我们需要向前查找以获取标签的 \cs{@currname}。
%   \pkg{expl3} 还需要 \cs{@pushfilename} 中的当前文件，因此这里我们滥用了 \cs{@expl@push@filename@aux@@@@}，
%   来执行 \cs{@@_curr_name_push:n}。
%    \begin{macrocode}
\cs_gset_protected:Npn \@expl@push@filename@aux@@@@ #1#2#3
  {
    \@@_curr_name_push:n {#3}
    \str_gset:Nx \g_file_curr_name_str {#3}
    #1 #2 {#3}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
%  \begin{macro}{
%    \UseHook,
%    \UseOneTimeHook,
%    \UseHookWithArguments,
%    \UseOneTimeHookWithArguments,
%  }
%    避免使用 \pkg{xparse} 的开销和保护，这里我们不需要（因为如果空，钩子应该毫无痕迹地消失）！
% \changes{v1.1a}{2023/04/06}{添加 \cs{UseHookWithArguments}（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\IncludeInRelease{2023/06/01}{\UseHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
\cs_new:Npn \UseHook        { \hook_use:n }
\cs_new:Npn \UseOneTimeHook { \hook_use_once:n }
\cs_new:Npn \UseHookWithArguments        { \hook_use:nnw }
\cs_new:Npn \UseOneTimeHookWithArguments { \hook_use_once:nnw }
%<latexrelease>\EndIncludeInRelease
%<latexrelease>\IncludeInRelease{2020/10/01}{\UseHookWithArguments}
%<latexrelease>                 {Hooks~with~args}
%<latexrelease>\cs_new:Npn \UseHookWithArguments #1 #2 { }
%<latexrelease>\cs_new:Npn \UseOneTimeHookWithArguments #1 #2 { }
%<latexrelease>\EndIncludeInRelease
%    \end{macrocode}
%  \end{macro}
%
%
%
% \begin{macro}{\ShowHook,\LogHook}
%    \begin{macrocode}
\cs_new_protected:Npn \ShowHook { \hook_show:n }
\cs_new_protected:Npn \LogHook { \hook_log:n }
%    \end{macrocode}
% \end{macro}
%
%  \begin{macro}{\DebugHooksOn,\DebugHooksOff}
%
%    \begin{macrocode}
\cs_new_protected:Npn \DebugHooksOn  { \hook_debug_on:  }
\cs_new_protected:Npn \DebugHooksOff { \hook_debug_off: }
%    \end{macrocode}
%  \end{macro}
%
%
%
%  \begin{macro}{\DeclareHookRule}
%
%    \begin{macrocode}
\NewDocumentCommand \DeclareHookRule { m m m m }
                    { \hook_gset_rule:nnnn {#1}{#2}{#3}{#4} }
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DeclareDefaultHookRule}
%    这个声明仅在 \verb=\begin{document}= 之前受支持。
%    \begin{macrocode}
\NewDocumentCommand \DeclareDefaultHookRule { m m m }
                    { \hook_gset_rule:nnnn {??}{#1}{#2}{#3} }
\@onlypreamble\DeclareDefaultHookRule
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ClearHookRule}
%    一个特殊的设置规则，用于移除现有的关系。
%    基本上是 {@@_rule_gclear:nnn} 加上修复调试用的属性列表。
%    \fmiinline{也许需要一个 L3 接口，或者也许应该删除？}
%    \begin{macrocode}
\NewDocumentCommand \ClearHookRule { m m m }
{ \hook_gset_rule:nnnn {#1}{#2}{unrelated}{#3} }
%    \end{macrocode}
%  \end{macro}
%
%
% \begin{macro}[EXP]{\IfHookEmptyTF}
%   这里我们避免了 \pkg{xparse} 的开销，因为 \cs{IfHookEmptyTF} 被用在 \cs{end} 中
%   （也就是说，每个 \LaTeX{} 环境中）。作为进一步的优化，使用 \cs{let} 而不是 \cs{def}，
%   以避免一次展开步骤。
%    \begin{macrocode}
\cs_new_eq:NN \IfHookEmptyTF \hook_if_empty:nTF
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,int]{\IfHookExistsTF}
%    标记为待移除，并且不再在文档部分记录！
% \phoinline{\cs{IfHookExistsTF} 在 \texttt{jlreq.cls}、\texttt{pxatbegshi.sty}、
% \texttt{pxeverysel.sty}、\texttt{pxeveryshi.sty} 中使用，因此公共名称可能是一段时间内内部条件的别名。
% 无论如何，这些包对 \cs{IfHookExistsTF} 的使用实际上并不正确，可以进行更改。}
%    \begin{macrocode}
\cs_new_eq:NN \IfHookExistsTF \@@_if_usable:nTF
%    \end{macrocode}
% \end{macro}
%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% \subsection{需要清理的弃用部分}
%
% \changes{v1.0p}{2021/08/20}{为旧的通用钩子命令添加弃用警告（gh/638）}
%
% \begin{macro}[int]{
%     \hook_disable:n,
%     \hook_provide:n,
%     \hook_provide_reversed:n,
%     \hook_provide_pair:nn,
%     \@@_activate_generic_reversed:n,
%     \@@_activate_generic_pair:nn,
%   }
%   弃用。
%    \begin{macrocode}
\cs_new_protected:Npn \hook_disable:n
  {
    \@@_deprecated_warn:nn
      { hook_disable:n }
      { hook_disable_generic:n }
    \hook_disable_generic:n
  }
\cs_new_protected:Npn \hook_provide:n
  {
    \@@_deprecated_warn:nn
      { hook_provide:n }
      { hook_activate_generic:n }
    \hook_activate_generic:n
  }
\cs_new_protected:Npn \hook_provide_reversed:n
  {
    \@@_deprecated_warn:nn
      { hook_provide_reversed:n }
      { hook_activate_generic:n }
    \@@_activate_generic_reversed:n
  }
\cs_new_protected:Npn \hook_provide_pair:nn
  {
    \@@_deprecated_warn:nn
      { hook_provide_pair:nn }
      { hook_activate_generic:n }
    \@@_activate_generic_pair:nn
  }
\cs_new_protected:Npn \@@_activate_generic_reversed:n #1
  { \@@_normalize_hook_args:Nn \@@_activate_generic:nn {#1} { - } }
\cs_new_protected:Npn \@@_activate_generic_pair:nn #1#2
  { \hook_activate_generic:n {#1} \@@_activate_generic_reversed:n {#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{
%     \DisableHook,
%     \ProvideHook,
%     \ProvideReversedHook,
%     \ProvideMirroredHookPair,
%   }
%   弃用。
%    \begin{macrocode}
\cs_new_protected:Npn \DisableHook
  {
    \@@_deprecated_warn:nn
      { DisableHook }
      { DisableGenericHook }
    \hook_disable_generic:n
  }
\cs_new_protected:Npn \ProvideHook
  {
    \@@_deprecated_warn:nn
      { ProvideHook }
      { ActivateGenericHook }
    \hook_activate_generic:n
  }
\cs_new_protected:Npn \ProvideReversedHook
  {
    \@@_deprecated_warn:nn
      { ProvideReversedHook }
      { ActivateGenericHook }
    \@@_activate_generic_reversed:n
  }
\cs_new_protected:Npn \ProvideMirroredHookPair
  {
    \@@_deprecated_warn:nn
      { ProvideMirroredHookPair }
      { ActivateGenericHook }
    \@@_activate_generic_pair:nn
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_deprecated_warn:nn}
%   警告有关弃用的信息，告知应该使用的替代方法。
%    \begin{macrocode}
\cs_new_protected:Npn \@@_deprecated_warn:nn #1 #2
  { \msg_warning:nnnn { hooks } { deprecated } {#1} {#2} }
\msg_new:nnn { hooks } { deprecated }
  {
    Command~\iow_char:N\\#1~is~deprecated~and~will~be~removed~in~a~
    future~release. \\ \\
    Use~\iow_char:N\\#2~instead.
  }
%    \end{macrocode}
% \end{macro}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% \subsection{其他地方需要的内部命令}
%
% 在这里，我们设置了一些可怕的（但是一致的）\LaTeXe{} 名称，以允许在此模块之外使用内部命令。
% 我们必须取消 \texttt{@\/@}，因为我们想要用双“at”符号代替双下划线。
%
%    \begin{macrocode}
%<@@=>
%    \end{macrocode}
%
%  \begin{macro}[int]{
%      \@expl@@@initialize@all@@,
%      \@expl@@@hook@curr@name@pop@@
%  }
%
% \InternalDetectionOff
%    \begin{macrocode}
\cs_new_eq:NN \@expl@@@initialize@all@@
              \__hook_initialize_all:
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_eq:NN \@expl@@@hook@curr@name@pop@@
              \__hook_curr_name_pop:
%    \end{macrocode}
% \InternalDetectionOn
%  \end{macro}
%
%    这里回滚并不会取消定义接口命令，因为它们可能在没有回滚功能的包中使用。
%    所以我们只是让它们什么都不做，这取决于代码的使用情况可能会起作用也可能不会。
% \changes{v1.0d}{2020/10/04}{\cs{AddToHookNext} 的定义应该是为了 \cs{AddToHook}，反之亦然 (gh/401)}
%    \begin{macrocode}
%
%<latexrelease>\IncludeInRelease{0000/00/00}{lthooks}
%<latexrelease>                 {The~hook~management}%
%<latexrelease>
%<latexrelease>\def \NewHook#1{}
%<latexrelease>\def \NewReversedHook#1{}
%<latexrelease>\def \NewMirroredHookPair#1#2{}
%<latexrelease>
%<latexrelease>\def \DisableGenericHook #1{}
%<latexrelease>
%<latexrelease>\long\def\AddToHookNext#1#2{}
%<latexrelease>
%<latexrelease>\def\AddToHook#1{\@gobble@AddToHook@args}
%<latexrelease>\providecommand\@gobble@AddToHook@args[2][]{}
%<latexrelease>
%<latexrelease>\def\RemoveFromHook#1{\@gobble@RemoveFromHook@arg}
%<latexrelease>\providecommand\@gobble@RemoveFromHook@arg[1][]{}
%<latexrelease>
%<latexrelease>\def \UseHook        #1{}
%<latexrelease>\def \UseOneTimeHook #1{}
%<latexrelease>\def \ShowHook #1{}
%<latexrelease>\let \DebugHooksOn \@empty
%<latexrelease>\let \DebugHooksOff\@empty
%<latexrelease>
%<latexrelease>\def \DeclareHookRule #1#2#3#4{}
%<latexrelease>\def \DeclareDefaultHookRule #1#2#3{}
%<latexrelease>\def \ClearHookRule #1#2#3{}
%    \end{macrocode}
%    如果未提供钩子管理，我们将存在性测试设为 false，将空性测试设为 true，
%    希望这在大多数情况下是合理的。如果不是，那么包需要防范在旧内核中运行。
%    \begin{macrocode}
%<latexrelease>\long\def \IfHookExistsTF #1#2#3{#3}
%<latexrelease>\long\def \IfHookEmptyTF #1#2#3{#2}
%<latexrelease>
%<latexrelease>\EndModuleRelease
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=hook>
%    \end{macrocode}
%
% \changes{v1.1a}{2023/04/06}{为恢复数据结构添加专用的回滚代码（hook-args）。}
%    \begin{macrocode}
%<latexrelease>\cs:w @@_rollback_tidying: \cs_end:
%<latexrelease>\bool_lazy_and:nnT
%<latexrelease>    { \int_compare_p:nNn { \sourceLaTeXdate } > { 20230600 } }
%<latexrelease>    { \int_compare_p:nNn { \requestedLaTeXdate } < { 20230601 } }
%<latexrelease>  {
%<latexrelease>    \cs_gset_protected:Npn \@@_rollback_tidying:
%<latexrelease>      {
%<latexrelease>        \@latex@error { Rollback~code~executed~twice }
%<latexrelease>          {
%<latexrelease>            Something~went~wrong~(unless~this~was~
%<latexrelease>            done~on~purpose~in~a~testing~environment).
%<latexrelease>          }
%<latexrelease>        \use_none:nnnn
%<latexrelease>      }
%<latexrelease>    \cs_set:Npn \@@_tmp:w #1 #2
%<latexrelease>      {
%<latexrelease>        \@@_tl_gset:cx { @@#1~#2 }
%<latexrelease>          {
%<latexrelease>            \exp_args:No \exp_not:o
%<latexrelease>              {
%<latexrelease>                \cs:w @@#1~#2 \exp_last_unbraced:Ne \cs_end:
%<latexrelease>                  { \@@_braced_cs_parameter:n { @@#1~#2 } }
%<latexrelease>              }
%<latexrelease>          }
%<latexrelease>      }
%<latexrelease>    \seq_map_inline:Nn \g_@@_all_seq
%<latexrelease>      {
%<latexrelease>        \exp_after:wN \cs_gset_nopar:Npn
%<latexrelease>          \cs:w g_@@_#1_code_prop \exp_args:NNo \exp_args:No
%<latexrelease>            \cs_end: { \cs:w g_@@_#1_code_prop \cs_end: }
%<latexrelease>        \@@_tmp:w { _toplevel } {#1}
%<latexrelease>        \@@_tmp:w { _next } {#1}
%<latexrelease>      }
%<latexrelease>  }
\ExplSyntaxOff
%</2ekernel|latexrelease>
%    \end{macrocode}
%
%    \begin{macrocode}
%<@@=>
%    \end{macrocode}
%
% \end{implementation}
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\endinput

^^A  Needed for emacs
^^A
^^A  Local Variables: 
^^A  mode: latex
^^A  coding: utf-8-unix
^^A  End: 
